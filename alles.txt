
--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/arduino_drehteller_steuerung.ino ---
// arduino_drehteller_steuerung.ino

// Definiere den Pin für das Relais
#define RELAIS_PIN 8

void setup() {
  // Initialisiere die serielle Kommunikation mit 9600 Baud
  Serial.begin(9600);

  // Konfiguriere den Relais-Pin als Ausgang
  pinMode(RELAIS_PIN, OUTPUT);

  // Stelle sicher, dass das Relais zu Beginn ausgeschaltet ist
  digitalWrite(RELAIS_PIN, LOW);

  Serial.println("Arduino Drehteller Steuerung bereit");
}

void loop() {
  // Prüfe, ob Daten verfügbar sind
  if (Serial.available() > 0) {
    // Lese eingehende Daten
    char command = Serial.read();

    // Interpretiere Befehl
    if (command == '1') {
      // Relais einschalten
      digitalWrite(RELAIS_PIN, HIGH);
      Serial.println("Relais eingeschaltet - Drehteller läuft");
    }
    else if (command == '0') {
      // Relais ausschalten
      digitalWrite(RELAIS_PIN, LOW);
      Serial.println("Relais ausgeschaltet - Drehteller gestoppt");
    }
    else {
      // Unbekannter Befehl
      Serial.println("Unbekannter Befehl empfangen. Verwende '1' zum Einschalten und '0' zum Ausschalten.");
    }
  }

  // Kurze Pause, um CPU-Last zu reduzieren
  delay(10);
}


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/create_project_zip.sh ---
#!/bin/bash
# Skript zum Erstellen einer ZIP-Datei des drehteller-360 Projekts

# Farbige Ausgabe
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Drehteller 360° ZIP-Erstellungstool${NC}"
echo "======================================"

# Prüfen, ob zip installiert ist
if ! command -v zip &> /dev/null; then
    echo -e "${RED}Das 'zip'-Programm ist nicht installiert. Bitte installiere es zuerst.${NC}"
    echo "Auf Ubuntu/Debian: sudo apt-get install zip"
    echo "Auf Fedora: sudo dnf install zip"
    echo "Auf macOS: sollte bereits installiert sein"
    exit 1
fi

# Erstellen der Projektstruktur
echo -e "${YELLOW}Erstelle temporäre Projektstruktur...${NC}"

# Temporäres Verzeichnis
TEMP_DIR="drehteller-360-temp"
ZIP_NAME="drehteller-360-projekt.zip"

# Bereinigen des temporären Verzeichnisses, falls es existiert
rm -rf "$TEMP_DIR"
mkdir -p "$TEMP_DIR"

# Erstellen der Verzeichnisstruktur
mkdir -p "$TEMP_DIR/templates"
mkdir -p "$TEMP_DIR/static/css"
mkdir -p "$TEMP_DIR/static/js"
mkdir -p "$TEMP_DIR/static/photos"
mkdir -p "$TEMP_DIR/static/projects"
mkdir -p "$TEMP_DIR/static/sample_images"

# Python-Hauptdateien
echo -e "${YELLOW}Erstelle Python-Hauptdateien...${NC}"

# main.py
cat > "$TEMP_DIR/main.py" << 'EOL'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Hauptanwendungseinstiegspunkt für die 360° Drehteller-Steuerung.
Startet den Webserver und initialisiert alle benötigten Komponenten.
"""

import os
import sys
import logging
from threading import Thread

# Stelle sicher, dass wir im richtigen Verzeichnis sind
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

# Initialisiere Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("drehteller360.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("drehteller360")

# Stelle sicher, dass die benötigten Verzeichnisse existieren
os.makedirs('static/photos', exist_ok=True)
os.makedirs('static/sample_images', exist_ok=True)
os.makedirs('static/projects', exist_ok=True)

# Importiere erst nach Verzeichnissetup
from web import app
from device_detector import DeviceDetector
from config_manager import config_manager

def check_dependencies():
    """Überprüft, ob alle erforderlichen Abhängigkeiten installiert sind."""
    try:
        import flask
        import cv2
        import serial
        import numpy
        logger.info("Alle erforderlichen Python-Pakete sind installiert.")
        return True
    except ImportError as e:
        logger.error(f"Fehlende Abhängigkeit: {e}")
        print(f"Fehler: {e}. Bitte führen Sie 'pip install -r requirements.txt' aus.")
        return False

if __name__ == "__main__":
    logger.info("Starte 360° Drehteller-Steuerung...")
    
    if not check_dependencies():
        sys.exit(1)
    
    # Initialisiere Gerätedetektor im Hintergrund
    device_detector = DeviceDetector()
    detection_thread = Thread(target=device_detector.start_detection, daemon=True)
    detection_thread.start()
    
    # Starte den Flask-Server
    host = config_manager.get('web.host', '0.0.0.0')
    port = config_manager.get('web.port', 5000)
    debug = config_manager.get('web.debug', True)
    
    logger.info(f"Webserver wird gestartet auf {host}:{port}")
    app.run(host=host, port=port, debug=debug)
EOL

# web.py
cat > "$TEMP_DIR/web.py" << 'EOL'
from flask import Flask, render_template, request, send_from_directory, jsonify
import os
import json
import time
import serial
import subprocess

# Import config manager
from config_manager import config_manager

# Import the webcam capture simulator
from webcam_simulator import WebcamCaptureSimulator
from sample_images_generator import SampleImagesGenerator
from webcam_detection_helper import find_working_webcam, get_camera_capabilities, test_webcam_capture
from device_detector import device_detector
from viewer_generator import viewer_generator

app = Flask(__name__)

# Configuration retrieval
USE_SIMULATOR = config_manager.get('simulator.enabled', True)

# Initialize webcam capture simulator
webcam_simulator = WebcamCaptureSimulator()

# Initialize sample images generator (optional, run once to generate images)
if not os.path.exists('static/sample_images') or len(os.listdir('static/sample_images')) < 5:
    image_generator = SampleImagesGenerator()
    image_generator.generate_sample_images(10)

# Arduino connection
def get_arduino_connection():
    """
    Establish Arduino connection based on configuration
    """
    try:
        if USE_SIMULATOR:
            return None
        
        port = config_manager.get('arduino.port', '/dev/ttyACM0')
        baudrate = config_manager.get('arduino.baudrate', 9600)
        
        arduino = serial.Serial(port, baudrate, timeout=1)
        time.sleep(2)  # Wait for initialization
        return arduino
    except Exception as e:
        print(f"Arduino connection error: {e}")
        return None

# Global Arduino connection
arduino = get_arduino_connection()

def rotate_teller(degrees):
    """
    Rotate the platform
    
    :param degrees: Rotation angle
    """
    if USE_SIMULATOR:
        print(f"Simulated rotation: {degrees} degrees")
        return
    
    if arduino is None:
        print("Arduino not connected!")
        return
    
    # Berechnung der Drehzeit basierend auf der Gradzahl (0,8 Grad pro Sekunde)
    rotation_time = degrees / 0.8
    
    # Relais einschalten (Drehteller starten)
    arduino.write(b'1')  # '1' senden, um das Relais einzuschalten
    time.sleep(rotation_time)  # Warte für die berechnete Zeit
    arduino.write(b'0')  # '0' senden, um das Relais auszuschalten
    print(f"Drehteller um {degrees} Grad gedreht.")

def take_photo(filename=None):
    """
    Capture a photo
    
    :param filename: Optional custom filename
    :return: Path to the saved photo
    """
    if USE_SIMULATOR:
        # Use the webcam simulator to generate a photo
        # Ensure filename is just the basename
        if filename:
            filename = os.path.basename(filename)
        return webcam_simulator.capture_photo(filename)
    
    try:
        # Camera device path and resolution from configuration
        camera_device = config_manager.get('camera.device_path', '/dev/video0')
        camera_type = config_manager.get('camera.type', 'webcam')
        
        # Get camera resolution
        camera_width = config_manager.get('camera.resolution.width')
        camera_height = config_manager.get('camera.resolution.height')
        
        # Use actual webcam capture for real hardware
        if not filename:
            filename = f'photo_{int(time.time())}.jpg'
        
        # Ensure filename is just the basename
        filename = os.path.basename(filename)
        full_path = os.path.join('static/photos', filename)
        
        # Choose capture method based on camera type
        if camera_type == 'gphoto2':
            # Use gphoto2 for DSLR cameras
            subprocess.call(['gphoto2', '--capture-image-and-download', '--filename', full_path])
        else:
            # Default to OpenCV for webcams
            import cv2
            cap = cv2.VideoCapture(camera_device)
            
            # Set resolution if specified
            if camera_width and camera_height:
                cap.set(cv2.CAP_PROP_FRAME_WIDTH, camera_width)
                cap.set(cv2.CAP_PROP_FRAME_HEIGHT, camera_height)
            
            ret, frame = cap.read()
            if ret:
                cv2.imwrite(full_path, frame)
                cap.release()
            else:
                # Fallback to fswebcam if OpenCV fails
                subprocess.call(['fswebcam', '--no-banner', 
                                 '-d', camera_device, 
                                 full_path])
        
        print(f"Foto aufgenommen und als {filename} gespeichert.")
        return filename
    except Exception as e:
        print(f"Fehler beim Aufnehmen des Fotos: {e}")
        return None

@app.route('/generate_sample_images', methods=['POST'])
def generate_sample_images():
    """
    Generate sample images for the simulator
    """
    try:
        # Ensure sample images directory exists
        os.makedirs('static/sample_images', exist_ok=True)
        
        # Generate sample images
        image_generator = SampleImagesGenerator()
        generated_images = image_generator.generate_sample_images(10)
        
        return jsonify({
            "status": "success", 
            "message": f"{len(generated_images)} sample images generated",
            "images": generated_images
        })
    except Exception as e:
        print(f"Error generating sample images: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

@app.route('/test_webcam_simulator', methods=['POST'])
def test_webcam_simulator():
    """
    Test the webcam simulator by capturing a sample image
    """
    try:
        # Ensure photos directory exists
        os.makedirs('static/photos', exist_ok=True)
        
        # Capture a test photo using the simulator
        photo_path = webcam_simulator.capture_photo('test_simulator.jpg')
        
        # Return the photo path relative to static folder
        return photo_path.replace('static/', '/static/')
    except Exception as e:
        print(f"Error testing webcam simulator: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

@app.route('/camera_capabilities', methods=['GET'])
def camera_capabilities():
    """
    Get camera device capabilities
    """
    try:
        # Get camera device from configuration
        camera_device = config_manager.get('camera.device_path', '/dev/video0')
        
        # Get camera capabilities
        capabilities = get_camera_capabilities(camera_device)
        
        return jsonify({
            "status": "success",
            "capabilities": capabilities
        })
    except Exception as e:
        print(f"Error getting camera capabilities: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

# Routes
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/settings')
def settings():
    return render_template('settings.html')

@app.route('/viewer')
def view_360():
    """Zeigt den 360°-Viewer an."""
    return render_template('viewer.html')

@app.route('/get_config')
def get_config():
    """
    Retrieve current configuration
    """
    return jsonify(config_manager.config)

@app.route('/save_config', methods=['POST'])
def save_config():
    """
    Save new configuration
    """
    try:
        new_config = request.json
        if not new_config:
            return jsonify({"status": "error", "message": "Keine Konfigurationsdaten empfangen"}), 400
            
        # Konfiguration speichern
        success = config_manager.save_config(new_config)
        
        if success:
            return jsonify({"status": "success"})
        else:
            return jsonify({"status": "error", "message": "Fehler beim Speichern der Konfiguration"}), 500
    except Exception as e:
        print(f"Error saving configuration: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/project/<project_id>')
def get_project(project_id):
    """Liefert Projektdaten für den 360°-Viewer."""
    try:
        project_dir = os.path.join('static/projects', project_id)
        metadata_path = os.path.join(project_dir, 'metadata.json')
        
        if not os.path.exists(metadata_path):
            return jsonify({"error": "Projekt nicht gefunden"}), 404
        
        with open(metadata_path, 'r') as f:
            metadata = json.load(f)
        
        return jsonify(metadata)
    except Exception as e:
        print(f"Fehler beim Laden der Projektdaten: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/devices')
def get_devices():
    """Liefert eine Liste aller erkannten Geräte."""
    return jsonify(device_detector.get_devices())

@app.route('/generate_360', methods=['POST'])
def generate_360():
    """Generiert einen 360°-Viewer aus den aufgenommenen Bildern."""
    try:
        # Liste der Fotos nach Zeitstempel sortieren
        photo_dir = 'static/photos'
        photos = sorted([f for f in os.listdir(photo_dir) 
                        if f.lower().endswith(('.jpg', '.jpeg', '.png'))])
        
        if not photos:
            return jsonify({"error": "Keine Fotos gefunden"}), 400
        
        # Optionale Metadaten aus der Anfrage
        metadata = request.get_json() if request.is_json else {}
        
        # 360°-Viewer generieren
        viewer_url = viewer_generator.generate_viewer(photos, metadata)
        
        if viewer_url:
            return jsonify({"status": "success", "url": viewer_url})
        else:
            return jsonify({"error": "Fehler beim Generieren des Viewers"}), 500
    except Exception as e:
        print(f"Fehler beim Generieren des 360°-Viewers: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/rotate', methods=['POST'])
def rotate():
    degrees = int(request.form['degrees'])
    interval = float(request.form.get('interval', 5))  # Default 5 seconds if not specified
    
    # Rotate platform
    rotate_teller(degrees)
    
    # Capture photo with timestamp to prevent caching
    filename = f'photo_{int(time.time())}_{degrees}.jpg'
    photo_path = take_photo(filename)
    
    # Return photo name relative to static folder
    if photo_path:
        return f'/static/photos/{os.path.basename(photo_path)}'
    else:
        return 'Error capturing photo', 500

@app.route('/static/photos/<filename>')
def serve_photo(filename):
    return send_from_directory('static/photos', filename)

if __name__ == '__main__':
    # Ensure static directories exist
    os.makedirs('static/photos', exist_ok=True)
    os.makedirs('static/sample_images', exist_ok=True)
    
    # Run the Flask app
    app.run(host='0.0.0.0', port=5000, debug=True)
EOL

# device_detector.py
cat > "$TEMP_DIR/device_detector.py" << 'EOL'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modul zur Erkennung von Kameras und Arduino-Geräten.
Erkennt automatisch verfügbare Geräte und aktualisiert regelmäßig die Liste.
"""

import os
import time
import logging
import subprocess
import glob
import threading
from serial.tools import list_ports

from webcam_detection_helper import find_working_webcam

# Logger konfigurieren
logger = logging.getLogger("drehteller360.device_detector")

class DeviceDetector:
    """Erkennt und verfolgt verfügbare Kameras und Arduino-Geräte."""
    
    def __init__(self, scan_interval=10):
        """
        Initialisiert den Gerätedetektor.
        
        Args:
            scan_interval: Zeit in Sekunden zwischen Geräte-Scans
        """
        self.scan_interval = scan_interval
        self.devices = {
            'cameras': {
                'webcams': [],
                'gphoto2': []
            },
            'arduinos': []
        }
        self.running = False
        self.lock = threading.Lock()
    
    def detect_webcams(self):
        """Erkennt angeschlossene Webcams."""
        webcam_devices = []
        
        try:
            # Videoeingabegeräte finden
            video_devices = glob.glob('/dev/video*')
            working_webcam = find_working_webcam(video_devices)
            
            if working_webcam:
                webcam_devices.append(working_webcam)
                
            for device in video_devices:
                if device != working_webcam and os.path.exists(device):
                    webcam_devices.append(device)
        except Exception as e:
            logger.error(f"Fehler bei der Webcam-Erkennung: {e}")
        
        return webcam_devices
    
    def detect_gphoto2_cameras(self):
        """Erkennt Kameras, die mit gphoto2 kompatibel sind."""
        gphoto2_cameras = []
        
        try:
            # Prüfen, ob gphoto2 installiert ist
            result = subprocess.run(['which', 'gphoto2'], 
                                     stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE)
            
            if result.returncode == 0:
                # Kameras auflisten
                result = subprocess.run(['gphoto2', '--auto-detect'], 
                                        stdout=subprocess.PIPE, 
                                        stderr=subprocess.PIPE, 
                                        text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[2:]:  # Überschriften überspringen
                        if line.strip():
                            gphoto2_cameras.append(line.strip())
        except Exception as e:
            logger.error(f"Fehler bei der gphoto2-Kamera-Erkennung: {e}")
        
        return gphoto2_cameras
    
    def detect_arduinos(self):
        """Erkennt angeschlossene Arduino-Geräte."""
        arduino_devices = []
        
        try:
            # Serielle Ports auflisten
            ports = list(list_ports.comports())
            for port in ports:
                if "Arduino" in port.description or "ACM" in port.device:
                    arduino_devices.append({
                        'port': port.device,
                        'description': port.description
                    })
        except Exception as e:
            logger.error(f"Fehler bei der Arduino-Erkennung: {e}")
        
        return arduino_devices
    
    def scan_devices(self):
        """Scannt nach allen verfügbaren Geräten."""
        with self.lock:
            self.devices['cameras']['webcams'] = self.detect_webcams()
            self.devices['cameras']['gphoto2'] = self.detect_gphoto2_cameras()
            self.devices['arduinos'] = self.detect_arduinos()
            
        logger.info(f"Geräte erkannt: {len(self.devices['cameras']['webcams'])} Webcams, "
                   f"{len(self.devices['cameras']['gphoto2'])} gphoto2-Kameras, "
                   f"{len(self.devices['arduinos'])} Arduino-Geräte")
    
    def get_devices(self):
        """Gibt die aktuell erkannten Geräte zurück."""
        with self.lock:
            return self.devices.copy()
    
    def start_detection(self):
        """Startet den Erkennungsprozess in einer Schleife."""
        self.running = True
        
        while self.running:
            self.scan_devices()
            time.sleep(self.scan_interval)
    
    def stop_detection(self):
        """Stoppt den Erkennungsprozess."""
        self.running = False

# Globale Instanz für die Anwendung
device_detector = DeviceDetector()
EOL

# viewer_generator.py
cat > "$TEMP_DIR/viewer_generator.py" << 'EOL'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modul zur Generierung des 360°-Viewers aus einer Serie von Bildern.
Bereitet Bilder auf und erstellt HTML/JavaScript für den interaktiven Viewer.
"""

import os
import json
import shutil
import logging
import time
from datetime import datetime
from PIL import Image

# Logger konfigurieren
logger = logging.getLogger("drehteller360.viewer_generator")

class ViewerGenerator:
    """Generiert einen interaktiven 360°-Viewer aus einer Serie von Bildern."""
    
    def __init__(self, photo_dir='static/photos', output_dir='static/projects'):
        """
        Initialisiert den Viewer-Generator.
        
        Args:
            photo_dir: Verzeichnis mit den Quellfotos
            output_dir: Ausgabeverzeichnis für generierte Projekte
        """
        self.photo_dir = photo_dir
        self.output_dir = output_dir
        
        # Stelle sicher, dass das Ausgabeverzeichnis existiert
        os.makedirs(output_dir, exist_ok=True)
    
    def prepare_images(self, images, project_name):
        """
        Bereitet Bilder für den 360°-Viewer vor (Größenanpassung, Optimierung).
        
        Args:
            images: Liste der Bildpfade
            project_name: Name des Projekts
            
        Returns:
            Pfad zum Projektverzeichnis
        """
        project_dir = os.path.join(self.output_dir, project_name)
        os.makedirs(project_dir, exist_ok=True)
        
        processed_images = []
        
        for i, img_path in enumerate(images):
            try:
                # Lade Bild
                img = Image.open(os.path.join(self.photo_dir, img_path))
                
                # Passe Größe an (max. 1200px Breite für optimale Performance)
                max_width = 1200
                if img.width > max_width:
                    ratio = max_width / img.width
                    new_height = int(img.height * ratio)
                    img = img.resize((max_width, new_height), Image.LANCZOS)
                
                # Speichere optimiertes Bild
                img_filename = f"image_{i:03d}.jpg"
                output_path = os.path.join(project_dir, img_filename)
                img.save(output_path, "JPEG", quality=85, optimize=True)
                
                processed_images.append(img_filename)
            except Exception as e:
                logger.error(f"Fehler bei der Bildverarbeitung für {img_path}: {e}")
        
        return project_dir, processed_images
    
    def generate_viewer(self, images, metadata=None):
        """
        Generiert einen 360°-Viewer aus den gegebenen Bildern.
        
        Args:
            images: Liste der Bildpfade
            metadata: Zusätzliche Metadaten für das Projekt
            
        Returns:
            URL zum erstellten Viewer
        """
        if not images:
            logger.error("Keine Bilder zum Generieren des Viewers gefunden")
            return None
            
        # Projektname erstellen (Zeitstempel)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        project_name = f"project_{timestamp}"
        
        # Bilder vorbereiten
        project_dir, processed_images = self.prepare_images(images, project_name)
        
        # Erstelle Projektmetadaten
        project_metadata = {
            "name": project_name,
            "created": time.time(),
            "image_count": len(processed_images),
            "images": processed_images,
            "user_metadata": metadata or {}
        }
        
        # Speichere Metadaten
        metadata_path = os.path.join(project_dir, "metadata.json")
        with open(metadata_path, "w") as f:
            json.dump(project_metadata, f)
            
        return f"/viewer?project={project_name}"

# Globale Instanz für die Anwendung
viewer_generator = ViewerGenerator()
EOL

# config_manager.py
cat > "$TEMP_DIR/config_manager.py" << 'EOL'
import os
import json
import logging

# Logger konfigurieren
logger = logging.getLogger("drehteller360.config_manager")

class ConfigManager:
    DEFAULT_CONFIG = {
        'camera': {
            'device_path': '/dev/video0',
            'type': 'webcam',  # or 'gphoto2'
            'resolution': {
                'width': 1280,
                'height': 720
            }
        },
        'arduino': {
            'port': '/dev/ttyACM0',
            'baudrate': 9600
        },
        'rotation': {
            'default_degrees': 15,
            'default_interval': 5
        },
        'simulator': {
            'enabled': True
        },
        'web': {
            'host': '0.0.0.0',
            'port': 5000,
            'debug': True
        }
    }

    def __init__(self, config_path=None):
        """
        Initialize configuration manager
        
        :param config_path: Path to the configuration file
        """
        # Determine the project directory
        self.project_dir = os.path.dirname(os.path.abspath(__file__))
        
        # If no config path provided, use a default in the project directory
        if config_path is None:
            config_path = os.path.join(self.project_dir, 'config.json')
        
        self.config_path = config_path
        self.config = self.load_config()
    
    def load_config(self):
        """
        Load configuration from file or create default
        
        :return: Configuration dictionary
        """
        try:
            # Ensure config directory exists
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            
            # Try to load existing config
            if os.path.exists(self.config_path):
                with open(self.config_path, 'r') as f:
                    loaded_config = json.load(f)
                    
                    # Rekursives Zusammenführen von Konfigurationen
                    return self._merge_configs(self.DEFAULT_CONFIG, loaded_config)
            else:
                # Create default config file
                config = self.DEFAULT_CONFIG.copy()
                self.save_config(config)
                return config
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            # If loading fails, use default config and try to save it
            try:
                self.save_config(self.DEFAULT_CONFIG)
            except Exception as save_error:
                logger.error(f"Error saving default config: {save_error}")
            return self.DEFAULT_CONFIG.copy()
    
    def _merge_configs(self, default_config, user_config):
        """
        Rekursives Zusammenführen von Konfigurationen
        
        :param default_config: Default-Konfiguration
        :param user_config: Benutzerkonfiguration
        :return: Zusammengeführte Konfiguration
        """
        result = default_config.copy()
        
        for key, value in user_config.items():
            # Wenn der Wert ein Dictionary ist und im Default-Config existiert
            if isinstance(value, dict) and key in result and isinstance(result[key], dict):
                # Rekursiv zusammenführen
                result[key] = self._merge_configs(result[key], value)
            else:
                # Sonst den Wert überschreiben
                result[key] = value
                
        return result
    
    def save_config(self, new_config=None):
        """
        Save configuration to file
        
        :param new_config: Optional new configuration to save
        """
        try:
            # Use provided config or current config
            if new_config is not None:
                # Merge with current config to ensure all keys exist
                config_to_save = self._merge_configs(self.config, new_config)
            else:
                config_to_save = self.config
            
            # Ensure full path exists
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            
            # Save configuration
            with open(self.config_path, 'w') as f:
                json.dump(config_to_save, f, indent=4)
            
            # Update current config
            self.config = config_to_save
            logger.info(f"Konfiguration erfolgreich gespeichert in {self.config_path}")
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def get(self, key, default=None):
        """
        Get a configuration value
        
        :param key: Dot-separated key (e.g. 'camera.device_path')
        :param default: Default value if key not found
        :return: Configuration value
        """
        try:
            # Split the key into parts
            parts = key.split('.')
            
            # Navigate through nested dictionary
            value = self.config
            for part in parts:
                if part in value:
                    value = value[part]
                else:
                    return default
            
            return value
        except Exception as e:
            logger.error(f"Error getting config value: {e}")
            return default

# Create a global config manager
config_manager = ConfigManager()

# Standalone usage example
if __name__ == '__main__':
    # Example usage
    print("Camera Device Path:", config_manager.get('camera.device_path'))
    print("Arduino Port:", config_manager.get('arduino.port'))
    
    # Example of updating config
    test_config = {
        'camera': {
            'device_path': '/dev/video1',
            'type': 'gphoto2'
        }
    }
    config_manager.save_config(test_config)
    
    # Verify changes
    print("\nAfter Update:")
    print("Camera Device Path:", config_manager.get('camera.device_path'))
    print("Arduino Port:", config_manager.get('arduino.port'))
EOL

# webcam_detection_helper.py
cat > "$TEMP_DIR/webcam_detection_helper.py" << 'EOL'
import cv2
import os
import time
import subprocess
import warnings

def find_working_webcam(preferred_devices=None):
    """
    Find a working webcam device
    
    :param preferred_devices: List of device paths to try first
    :return: Working device path or None
    """
    # Prioritize video0 for Microsoft LifeCam HD-5000
    if preferred_devices is None:
        preferred_devices = ['/dev/video0', '/dev/video1']
    
    # First, try fswebcam to check device functionality
    for device in preferred_devices:
        try:
            # Use subprocess to run fswebcam test
            result = subprocess.run([
                'fswebcam', 
                '-d', device, 
                '--no-banner', 
                '--device-timeout', '2',  # Short timeout
                '/dev/null'  # Discard output
            ], capture_output=True, text=True, timeout=3)
            
            # If fswebcam succeeds, return this device
            if result.returncode == 0:
                return device
        except subprocess.TimeoutExpired:
            continue
        except Exception:
            continue
    
    # Fallback to OpenCV detection
    for device in preferred_devices:
        try:
            # Try OpenCV capture
            cap = cv2.VideoCapture(device)
            ret, frame = cap.read()
            if ret and frame is not None and frame.size > 0:
                cap.release()
                return device
            cap.release()
        except Exception:
            pass
    
    # Comprehensive search if all else fails
    try:
        # Use v4l2-ctl to list all video devices
        result = subprocess.run(['v4l2-ctl', '--list-devices'], 
                                capture_output=True, 
                                text=True)
        
        # Extract all /dev/video* devices
        devices = [
            line.strip() 
            for line in result.stdout.split('\n') 
            if line.startswith('/dev/video')
        ]
        
        # Try each discovered device
        for device in devices:
            try:
                # Try fswebcam first
                result = subprocess.run([
                    'fswebcam', 
                    '-d', device, 
                    '--no-banner', 
                    '--device-timeout', '2',
                    '/dev/null'
                ], capture_output=True, text=True, timeout=3)
                
                if result.returncode == 0:
                    return device
                
                # Fallback to OpenCV
                cap = cv2.VideoCapture(device)
                ret, frame = cap.read()
                if ret and frame is not None and frame.size > 0:
                    cap.release()
                    return device
                cap.release()
            except Exception:
                continue
    except Exception:
        pass
    
    return None

def get_camera_capabilities(device_path):
    """
    Retrieve camera capabilities
    
    :param device_path: Path to the video device
    :return: Dictionary of camera capabilities
    """
    capabilities = {
        'supported_resolutions': [],
        'max_width': 0,
        'max_height': 0
    }
    
    try:
        # Use v4l2-ctl to get detailed device information
        result = subprocess.run([
            'v4l2-ctl', 
            '-d', device_path, 
            '--list-formats-ext'
        ], capture_output=True, text=True, timeout=3)
        
        # Parse output to extract resolutions
        resolutions = []
        for line in result.stdout.split('\n'):
            if 'Size' in line:
                try:
                    # Extract resolution like '640x480'
                    resolution = line.split(':')[-1].strip()
                    width, height = map(int, resolution.split('x'))
                    resolutions.append((width, height))
                    
                    # Track max resolution
                    capabilities['max_width'] = max(capabilities['max_width'], width)
                    capabilities['max_height'] = max(capabilities['max_height'], height)
                except Exception:
                    pass
        
        capabilities['supported_resolutions'] = sorted(set(resolutions))
    except Exception as e:
        print(f"Error getting camera capabilities: {e}")
    
    return capabilities

def test_webcam_capture(device_path, width=None, height=None):
    """
    Attempt to capture an image from the specified device with optional resolution
    
    :param device_path: Path to the video device
    :param width: Optional desired width
    :param height: Optional desired height
    :return: Tuple (success, captured_image_path)
    """
    try:
        # Ensure output directory exists
        os.makedirs('static/photos', exist_ok=True)
        
        # Generate unique filename
        filename = f'webcam_test_{int(time.time())}.jpg'
        full_path = os.path.join('static/photos', filename)
        
        # Prepare fswebcam command
        cmd = ['fswebcam', 
               '-d', device_path, 
               '--no-banner', 
               '--device-timeout', '2']
        
        # Add resolution if specified
        if width and height:
            cmd.extend(['-r', f'{width}x{height}'])
        
        cmd.append(full_path)
        
        # Try fswebcam first
        subprocess.run(cmd, check=True, timeout=5)
        
        # Verify file was created
        if os.path.exists(full_path) and os.path.getsize(full_path) > 0:
            return True, full_path
        
        # Fallback to OpenCV with resolution
        cap = cv2.VideoCapture(device_path)
        
        # Set resolution if specified
        if width and height:
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)
        
        ret, frame = cap.read()
        if ret:
            cv2.imwrite(full_path, frame)
            cap.release()
            return True, full_path
        cap.release()
        
        return False, None
    
    except subprocess.TimeoutExpired:
        print(f"Timeout capturing from {device_path}")
        return False, None
    except Exception as e:
        print(f"Webcam capture error: {e}")
        return False, None

# Standalone usage example
if __name__ == '__main__':
    # Find a working webcam
    working_device = find_working_webcam()
    
    if working_device:
        print(f"Found working webcam at: {working_device}")
        
        # Get camera capabilities
        capabilities = get_camera_capabilities(working_device)
        print("\nCamera Capabilities:")
        print(f"Supported Resolutions: {capabilities['supported_resolutions']}")
        print(f"Max Resolution: {capabilities['max_width']}x{capabilities['max_height']}")
        
        # Try capturing at a specific resolution
        success, image_path = test_webcam_capture(working_device, 1280, 720)
        
        if success:
            print(f"\nTest image captured: {image_path}")
        else:
            print("\nFailed to capture test image")
    else:
        print("No working webcam found")
EOL

# webcam_simulator.py
cat > "$TEMP_DIR/webcam_simulator.py" << 'EOL'
import cv2
import os
import time
import random
import subprocess
import warnings
from datetime import datetime

from webcam_detection_helper import find_working_webcam, test_webcam_capture

class WebcamCaptureSimulator:
    def __init__(self, base_path='static/photos', sample_images_path='static/sample_images'):
        """
        Initialize webcam capture simulator
        
        :param base_path: Directory to save captured photos
        :param sample_images_path: Directory containing sample images to use
        """
        self.base_path = base_path
        self.sample_images_path = sample_images_path
        
        # Ensure base and sample image directories exist
        os.makedirs(base_path, exist_ok=True)
        os.makedirs(sample_images_path, exist_ok=True)
        
        # Find the best webcam device
        self.camera_device = self._find_best_camera_device()
    
    def _find_best_camera_device(self, preferred_devices=None):
        """
        Find the best camera device to use
        
        :param preferred_devices: Optional list of preferred device paths
        :return: Best working device path
        """
        # If specific devices are known, try those first
        if preferred_devices is None:
            preferred_devices = ['/dev/video0', '/dev/video1']
        
        # Find a working webcam
        return find_working_webcam(preferred_devices)
    
    def capture_photo(self, filename=None):
        """
        Capture a photo - either from a real webcam or simulate with a sample image
        
        :param filename: Optional custom filename
        :return: Path to the saved image
        """
        # Ensure the base path exists
        os.makedirs(self.base_path, exist_ok=True)
        
        # If no filename provided, generate a unique one
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'webcam_photo_{timestamp}.jpg'
        
        # Ensure filename is just the basename
        filename = os.path.basename(filename)
        
        # Full path for the new image
        full_path = os.path.join(self.base_path, filename)
        
        # Try to capture from the detected camera device
        if self.camera_device:
            try:
                success, captured_path = test_webcam_capture(self.camera_device)
                if success:
                    # Copy the captured image to the desired filename
                    import shutil
                    shutil.copy(captured_path, full_path)
                    return full_path
            except Exception as e:
                print(f"Camera capture error: {e}")
        
        # Fallback to sample image simulation
        sample_images = [
            f for f in os.listdir(self.sample_images_path) 
            if f.lower().endswith(('.png', '.jpg', '.jpeg'))
        ]
        
        if sample_images:
            # Randomly select a sample image
            selected_sample = random.choice(sample_images)
            sample_path = os.path.join(self.sample_images_path, selected_sample)
            
            # Copy the sample image to the photos directory
            import shutil
            shutil.copy(sample_path, full_path)
            return full_path
        
        # Last resort - create a blank image
        import numpy as np
        blank_image = np.zeros((480,640,3), dtype=np.uint8)
        cv2.putText(blank_image, "No Image Available", (50,250), 
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,255), 2)
        cv2.imwrite(full_path, blank_image)
        return full_path
    
    def list_photos(self):
        """
        List all photos in the base path
        
        :return: List of photo filenames
        """
        return [f for f in os.listdir(self.base_path) 
                if f.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Standalone usage example
if __name__ == '__main__':
    # Initialize the webcam capture simulator
    webcam_simulator = WebcamCaptureSimulator()
    
    # Capture 5 photos
    for i in range(5):
        captured_image = webcam_simulator.capture_photo()
        print(f"Captured image: {captured_image}")
    
    # List captured images
    print("\nCaptured Images:")
    for photo in webcam_simulator.list_photos():
        print(photo)
EOL

# sample_images_generator.py
cat > "$TEMP_DIR/sample_images_generator.py" << 'EOL'
import os
import random
import math
from PIL import Image, ImageDraw, ImageFont

class SampleImagesGenerator:
    def __init__(self, output_path='static/sample_images', width=800, height=600):
        """
        Generate sample images for webcam simulator
        
        :param output_path: Directory to save generated images
        :param width: Image width
        :param height: Image height
        """
        self.output_path = output_path
        self.width = width
        self.height = height
        
        # Ensure output directory exists
        os.makedirs(output_path, exist_ok=True)
    
    def generate_color_gradient_image(self, index):
        """
        Generate an image with a color gradient
        
        :param index: Unique identifier for the image
        :return: Path to the generated image
        """
        # Create a new image with a gradient
        image = Image.new('RGB', (self.width, self.height))
        draw = ImageDraw.Draw(image)
        
        # Generate gradient colors
        for y in range(self.height):
            r = int(255 * y / self.height)
            g = int(255 * (1 - y / self.height))
            b = int(128 + 127 * math.sin(y / 50))
            
            draw.line([(0, y), (self.width, y)], fill=(r, g, b))
        
        # Add text to identify the image
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 36)
        except IOError:
            font = ImageFont.load_default()
        
        draw.text((50, 50), f"Sample Image {index}", font=font, fill=(255, 255, 255))
        
        # Save the image
        filename = os.path.join(self.output_path, f'sample_image_{index}.jpg')
        image.save(filename)
        return filename
    
    def generate_sample_images(self, count=10):
        """
        Generate multiple sample images
        
        :param count: Number of images to generate
        :return: List of generated image paths
        """
        generated_images = []
        for i in range(count):
            image_path = self.generate_color_gradient_image(i)
            generated_images.append(image_path)
        
        return generated_images

# Optionally, if you want to use this as a standalone script
if __name__ == '__main__':
    generator = SampleImagesGenerator()
    generated_images = generator.generate_sample_images()
    
    print("Generated Sample Images:")
    for img in generated_images:
        print(img)
EOL

# HTML-Templates
echo -e "${YELLOW}Erstelle HTML-Templates...${NC}"

# templates/index.html
cat > "$TEMP_DIR/templates/index.html" << 'EOL'
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Drehteller Steuerung</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/index.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h2 class="mb-0">360° Drehteller Steuerung</h2>
                <a href="/settings" class="btn btn-light btn-sm">
                    <i class="bi bi-gear"></i> Einstellungen
                </a>
            </div>
            <div class="card-body">
                <!-- Captured Image Display -->
                <div class="text-center mb-4">
                    <img id="captured-image" src="/static/placeholder.jpg" alt="Aktuelles Foto" class="img-fluid">
                </div>

                <!-- Rotation Settings -->
                <div id="rotation-settings" class="row g-3">
                    <div class="col-md-4">
                        <label for="rotation-interval" class="form-label">Foto-Intervall (Sekunden)</label>
                        <input type="number" class="form-control" id="rotation-interval" value="5" min="1" max="60">
                    </div>
                    <div class="col-md-4">
                        <label for="rotation-degrees" class="form-label">Drehwinkel pro Schritt</label>
                        <input type="number" class="form-control" id="rotation-degrees" value="15" min="1" max="90">
                    </div>
                    <div class="col-md-4 d-flex align-items-end gap-2">
                        <button id="start-360-rotation" class="btn btn-success btn-play flex-grow-1">
                            <i class="bi bi-play-fill"></i> Start 360°
                        </button>
                        <button id="stop-rotation" class="btn btn-danger btn-stop d-none">
                            <i class="bi bi-stop-fill"></i> Stop
                        </button>
                    </div>
                </div>

                <!-- Progress Display -->
                <div id="progress-container" class="mt-3" style="display: none;">
                    <div class="progress">
                        <div id="rotation-progress" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                    <div id="rotation-status" class="text-center mt-2"></div>
                </div>

                <!-- 360° Viewer generieren -->
                <div id="generate-360-container" class="mt-4">
                    <h3>360° Viewer generieren</h3>
                    <div class="row g-3">
                        <div class="col-md-8">
                            <input type="text" class="form-control" id="project-name" placeholder="Projektname (optional)">
                        </div>
                        <div class="col-md-4">
                            <button id="generate-360-btn" class="btn btn-primary w-100">
                                <i class="bi bi-camera-video"></i> 360° Viewer erstellen
                            </button>
                        </div>
                    </div>
                    <div id="generation-status" class="mt-2"></div>
                </div>

                <!-- Manual Rotation -->
                <div class="mt-4">
                    <h3>Manuelle Rotation</h3>
                    <form id="manual-rotation-form">
                        <div class="input-group">
                            <input type="number" class="form-control" id="manual-degrees" placeholder="Drehwinkel" min="0" max="360" required>
                            <button type="submit" class="btn btn-primary">
                                <i class="bi bi-arrow-clockwise"></i> Drehen
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/index.js"></script>
    <script>
        // 360° Viewer Generierung
        document.getElementById('generate-360-btn').addEventListener('click', async () => {
            const statusElement = document.getElementById('generation-status');
            statusElement.innerHTML = '<div class="alert alert-info">Generiere 360° Viewer...</div>';
            
            const projectName = document.getElementById('project-name').value;
            
            try {
                const response = await fetch('/generate_360', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: projectName || ('Projekt ' + new Date().toLocaleDateString())
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    statusElement.innerHTML = `
                        <div class="alert alert-success">
                            360° Viewer erfolgreich erstellt! 
                            <a href="${result.url}" class="btn btn-sm btn-primary ms-2">Anzeigen</a>
                        </div>`;
                } else {
                    statusElement.innerHTML = `<div class="alert alert-danger">Fehler: ${result.error}</div>`;
                }
            } catch (error) {
                statusElement.innerHTML = `<div class="alert alert-danger">Fehler: ${error.message}</div>`;
            }
        });
    </script>
</body>
</html>
EOL

# templates/settings.html
cat > "$TEMP_DIR/templates/settings.html" << 'EOL'
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drehteller Einstellungen</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/settings.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white">
                <h2 class="text-center mb-0">
                    <i class="bi bi-gear me-2"></i>Drehteller Einstellungen
                </h2>
            </div>
            <div class="card-body">
                <form id="settings-form">
                    <!-- Camera Settings -->
                    <div class="mb-3">
                        <h4>Kamera Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-8">
                                <label for="camera-device-path" class="form-label">Geräte-Pfad</label>
                                <input type="text" class="form-control" id="camera-device-path" 
                                       placeholder="/dev/video0" required>
                                <div class="form-text">Pfad zum Kameragerät (z.B. /dev/video0)</div>
                            </div>
                            <div class="col-md-4">
                                <label for="camera-type" class="form-label">Kameratyp</label>
                                <select class="form-select" id="camera-type">
                                    <option value="webcam">Webcam</option>
                                    <option value="gphoto2">DSLR (gphoto2)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Arduino Settings -->
                    <div class="mb-3">
                        <h4>Arduino Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-8">
                                <label for="arduino-port" class="form-label">Serieller Port</label>
                                <input type="text" class="form-control" id="arduino-port" 
                                       placeholder="/dev/ttyACM0" required>
                                <div class="form-text">Pfad zum Arduino-Port (z.B. /dev/ttyACM0)</div>
                            </div>
                            <div class="col-md-4">
                                <label for="arduino-baudrate" class="form-label">Baudrate</label>
                                <select class="form-select" id="arduino-baudrate">
                                    <option value="9600">9600</option>
                                    <option value="115200">115200</option>
                                    <option value="57600">57600</option>
                                    <option value="38400">38400</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Rotation Settings -->
                    <div class="mb-3">
                        <h4>Rotations-Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-6">
                                <label for="rotation-degrees" class="form-label">Standard Drehwinkel</label>
                                <input type="number" class="form-control" id="rotation-degrees" 
                                       min="1" max="90" value="15">
                                <div class="form-text">Standardwinkel pro Rotationsschritt</div>
                            </div>
                            <div class="col-md-6">
                                <label for="rotation-interval" class="form-label">Foto-Intervall</label>
                                <input type="number" class="form-control" id="rotation-interval" 
                                       min="1" max="60" value="5">
                                <div class="form-text">Sekunden zwischen Fotos</div>
                            </div>
                        </div>
                    </div>


                    <!-- Camera Resolution Settings -->
                    <div class="mb-3">
                        <h4>Kamera-Auflösung</h4>
                        <div class="row g-3">
                            <div class="col-md-4">
                                <label for="camera-width" class="form-label">Breite (Pixel)</label>
                                <input type="number" class="form-control" id="camera-width" 
                                       placeholder="z.B. 1280" min="160" max="3840">
                            </div>
                            <div class="col-md-4">
                                <label for="camera-height" class="form-label">Höhe (Pixel)</label>
                                <input type="number" class="form-control" id="camera-height" 
                                       placeholder="z.B. 720" min="120" max="2160">
                            </div>
                            <div class="col-md-4">
                                <label for="camera-resolution-preset" class="form-label">Voreinstellungen</label>
                                <select class="form-select" id="camera-resolution-preset">
                                    <option value="custom">Benutzerdefiniert</option>
                                    <option value="640x480">640x480 (VGA)</option>
                                    <option value="1280x720">1280x720 (HD)</option>
                                    <option value="1920x1080">1920x1080 (Full HD)</option>
                                    <option value="2560x1440">2560x1440 (QHD)</option>
                                    <option value="3840x2160">3840x2160 (4K)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Simulator Controls -->
                    <div class="mt-4">
                        <h4>Simulator Einstellungen</h4>
                        <div class="row g-3">
                            <div class="col-md-4">
                                <label class="form-label">Simulator-Modus</label>
                                <div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="simulator-mode" id="simulator-on" value="true">
                                        <label class="form-check-label" for="simulator-on">
                                            Ein
                                        </label>
                                    </div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="simulator-mode" id="simulator-off" value="false">
                                        <label class="form-check-label" for="simulator-off">
                                            Aus
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-8">
                                <label class="form-label">Simulator-Tools</label>
                                <div>
                                    <button type="button" id="generate-sample-images" class="btn btn-secondary me-2">
                                        <i class="bi bi-image me-2"></i>Beispielbilder generieren
                                    </button>
                                    <button type="button" id="test-webcam-simulator" class="btn btn-info">
                                        <i class="bi bi-camera me-2"></i>Webcam-Simulator testen
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="d-grid gap-2 d-md-flex justify-content-md-end mt-4">
                        <a href="/" class="btn btn-secondary">
                            <i class="bi bi-x-circle me-2"></i>Abbrechen
                        </a>
                        <button type="submit" class="btn btn-primary">
                            <i class="bi bi-save me-2"></i>Speichern
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/settings.js"></script>
</body>
</html>
EOL

# templates/viewer.html
cat > "$TEMP_DIR/templates/viewer.html" << 'EOL'
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Viewer - Drehteller Steuerung</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/viewer.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h2 class="mb-0">360° Produktansicht</h2>
                <div>
                    <a href="/" class="btn btn-light btn-sm me-2">
                        <i class="bi bi-house"></i> Zurück zur Steuerung
                    </a>
                    <button id="fullscreen-btn" class="btn btn-light btn-sm">
                        <i class="bi bi-fullscreen"></i>
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div id="viewer-container" class="position-relative">
                    <!-- Viewer wird hier per JavaScript eingefügt -->
                    <div id="spinner" class="position-absolute top-50 start-50 translate-middle">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Laden...</span>
                        </div>
                    </div>
                    <div id="product-viewer" class="viewer-360"></div>
                </div>
                
                <div class="mt-4 d-flex justify-content-between">
                    <div class="viewer-controls">
                        <button id="play-btn" class="btn btn-primary">
                            <i class="bi bi-play-fill"></i> Auto-Rotation
                        </button>
                        <button id="reset-btn" class="btn btn-secondary ms-2">
                            <i class="bi bi-arrow-counterclockwise"></i> Zurücksetzen
                        </button>
                    </div>
                    
                    <div class="zoom-controls">
                        <button id="zoom-in-btn" class="btn btn-outline-secondary">
                            <i class="bi bi-zoom-in"></i>
                        </button>
                        <button id="zoom-out-btn" class="btn btn-outline-secondary ms-2">
                            <i class="bi bi-zoom-out"></i>
                        </button>
                    </div>
                </div>
                
                <div class="mt-4">
                    <div class="project-info">
                        <h4 id="project-name">Projekt: <span></span></h4>
                        <p id="image-count">Bilder: <span></span></p>
                    </div>
                </div>
            </div>
            
            <div class="card-footer text-center">
                <p>Bewegen Sie die Maus oder wischen Sie auf dem Touchscreen, um das Objekt zu drehen.</p>
                <small class="text-muted">Erstellt mit Drehteller 360° Steuerung</small>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/viewer.js"></script>
</body>
</html>
EOL

# CSS-Dateien
echo -e "${YELLOW}Erstelle CSS-Dateien...${NC}"

# static/css/index.css
cat > "$TEMP_DIR/static/css/index.css" << 'EOL'
body {
    background-color: #f4f4f4;
    padding-top: 50px;
}

.container {
    max-width: 800px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#captured-image {
    max-width: 100%;
    max-height: 400px;
    object-fit: contain;
    margin-bottom: 20px;
}

.btn-play, .btn-stop {
    font-size: 2rem;
    padding: 10px 20px;
}

#progress-container {
    margin-top: 20px;
}

#rotation-settings {
    margin-top: 20px;
}

@media (max-width: 768px) {
    body {
        padding-top: 20px;
    }
    .container {
        padding: 0 15px;
    }
}
EOL

# static/css/settings.css
cat > "$TEMP_DIR/static/css/settings.css" << 'EOL'
body {
    background-color: #f4f4f4;
    padding-top: 50px;
}

.container {
    max-width: 600px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

@media (max-width: 768px) {
    body {
        padding-top: 20px;
    }
    .container {
        padding: 0 15px;
    }
}

/* Optional: Add some subtle styling to form elements */
.form-control, .form-select {
    transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.form-control:focus, .form-select:focus {
    border-color: #0d6efd;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

/* Simulator mode radio buttons */
.form-check-input:checked {
    background-color: #0d6efd;
    border-color: #0d6efd;
}

/* Clickable device items */
.clickable-device {
    cursor: pointer;
    transition: color 0.2s;
}
.clickable-device:hover {
    color: #0056b3 !important;
    text-decoration: underline;
}
EOL

# static/css/viewer.css
cat > "$TEMP_DIR/static/css/viewer.css" << 'EOL'
body {
    background-color: #f4f4f4;
    padding-top: 20px;
    padding-bottom: 20px;
}

.container {
    max-width: 1200px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#viewer-container {
    position: relative;
    width: 100%;
    height: 500px;
    background-color: #fff;
    overflow: hidden;
    touch-action: none; /* Verhindert Browser-Scrolling bei Touch-Gesten */
}

.viewer-360 {
    width: 100%;
    height: 100%;
    position: relative;
    cursor: grab;
}

.viewer-360:active {
    cursor: grabbing;
}

.viewer-360 img {
    position: absolute;
    max-width: 100%;
    max-height: 100%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    object-fit: contain;
    display: none;
}

.viewer-360 img.active {
    display: block;
}

/* Zoom-Effekt */
.viewer-360.zoomed {
    overflow: hidden;
}

/* Fullscreen-Modus */
.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 9999;
    background-color: #fff;
    padding: 20px;
}

.fullscreen #viewer-container {
    height: calc(100vh - 150px);
}

/* Spinner */
#spinner {
    z-index: 10;
}

/* Responsive Anpassungen */
@media (max-width: 768px) {
    #viewer-container {
        height: 350px;
    }
    
    .container {
        padding: 0 10px;
    }
    
    .viewer-controls, .zoom-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }
}

@media (max-width: 576px) {
    #viewer-container {
        height: 300px;
    }
    
    .card-header {
        flex-direction: column;
        gap: 10px;
    }
    
    .btn-sm {
        padding: 5px 8px;
        font-size: 0.8rem;
    }
}
EOL

# JavaScript-Dateien
echo -e "${YELLOW}Erstelle JavaScript-Dateien...${NC}"

# static/js/index.js
cat > "$TEMP_DIR/static/js/index.js" << 'EOL'
// DOM Elements
const startButton = document.getElementById('start-360-rotation');
const stopButton = document.getElementById('stop-rotation');
const rotationIntervalInput = document.getElementById('rotation-interval');
const rotationDegreesInput = document.getElementById('rotation-degrees');
const progressContainer = document.getElementById('progress-container');
const progressBar = document.getElementById('rotation-progress');
const rotationStatus = document.getElementById('rotation-status');
const capturedImage = document.getElementById('captured-image');
const manualRotationForm = document.getElementById('manual-rotation-form');

// Rotation state
let isRotating = false;
let rotationAborted = false;

// 360° Rotation Function
async function start360Rotation() {
    const interval = parseInt(rotationIntervalInput.value);
    const stepDegrees = parseInt(rotationDegreesInput.value);
    const totalRotations = Math.floor(360 / stepDegrees);

    // Disable start button, show stop button
    startButton.disabled = true;
    stopButton.classList.remove('d-none');
    progressContainer.style.display = 'block';
    rotationStatus.textContent = 'Rotation gestartet...';
    isRotating = true;
    rotationAborted = false;

    // Reset progress
    progressBar.style.width = '0%';
    progressBar.classList.add('progress-bar-animated');

    try {
        for (let i = 0; i < totalRotations; i++) {
            // Check if rotation was aborted
            if (rotationAborted) {
                break;
            }

            // Update progress
            const progress = ((i + 1) / totalRotations) * 100;
            progressBar.style.width = `${progress}%`;
            rotationStatus.textContent = `Foto ${i + 1} von ${totalRotations}`;

            // Send rotation and photo capture request
            const response = await fetch('/rotate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `degrees=${stepDegrees}&interval=${interval}`
            });

            // Check if request was successful
            if (!response.ok) {
                throw new Error('Rotation fehlgeschlagen');
            }

            // Update image source with the latest photo
            const result = await response.text();
            capturedImage.src = result; // Assuming the response contains the photo path

            // Wait for the specified interval
            await new Promise(resolve => setTimeout(resolve, interval * 1000));
        }

        // Rotation complete
        if (!rotationAborted) {
            rotationStatus.textContent = 'Rotation abgeschlossen!';
            progressBar.classList.remove('progress-bar-animated');
        } else {
            rotationStatus.textContent = 'Rotation abgebrochen!';
            progressBar.classList.add('bg-warning');
        }
    } catch (error) {
        // Handle errors
        rotationStatus.textContent = `Fehler: ${error.message}`;
        progressBar.classList.add('bg-danger');
    } finally {
        // Re-enable start button, hide stop button
        startButton.disabled = false;
        stopButton.classList.add('d-none');
        isRotating = false;
    }
}

// Stop Rotation Function
function stopRotation() {
    if (isRotating) {
        rotationAborted = true;
        rotationStatus.textContent = 'Rotation wird gestoppt...';
    }
}

// Manual Rotation
manualRotationForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const degrees = document.getElementById('manual-degrees').value;

    try {
        const response = await fetch('/rotate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `degrees=${degrees}`
        });

        const result = await response.text();
        capturedImage.src = result; // Update image with latest photo
    } catch (error) {
        console.error('Rotation error:', error);
    }
});

// Event Listeners
startButton.addEventListener('click', start360Rotation);
stopButton.addEventListener('click', stopRotation);
EOL

# static/js/settings.js
cat > "$TEMP_DIR/static/js/settings.js" << 'EOL'
// Camera Resolution Preset Handling
const cameraWidthInput = document.getElementById('camera-width');
const cameraHeightInput = document.getElementById('camera-height');
const cameraResolutionPreset = document.getElementById('camera-resolution-preset');
const simulatorOnBtn = document.getElementById('simulator-on');
const simulatorOffBtn = document.getElementById('simulator-off');

// Resolution preset change handler
cameraResolutionPreset.addEventListener('change', (e) => {
    const preset = e.target.value;
    
    switch(preset) {
        case '640x480':
            cameraWidthInput.value = 640;
            cameraHeightInput.value = 480;
            break;
        case '1280x720':
            cameraWidthInput.value = 1280;
            cameraHeightInput.value = 720;
            break;
        case '1920x1080':
            cameraWidthInput.value = 1920;
            cameraHeightInput.value = 1080;
            break;
        case '2560x1440':
            cameraWidthInput.value = 2560;
            cameraHeightInput.value = 1440;
            break;
        case '3840x2160':
            cameraWidthInput.value = 3840;
            cameraHeightInput.value = 2160;
            break;
        case 'custom':
            // Clear inputs or keep current values
            break;
    }
});

// Geräteliste laden
async function loadDevices() {
    try {
        const response = await fetch('/api/devices');
        const devices = await response.json();
        
        updateDeviceUI(devices);
    } catch (error) {
        console.error('Fehler beim Laden der Geräte:', error);
    }
}

// Geräte-UI aktualisieren
function updateDeviceUI(devices) {
    // Bestehende Listen entfernen (um Duplikate zu vermeiden)
    document.querySelectorAll('.device-list').forEach(el => el.remove());
    
    // Webcams anzeigen
    const webcamList = document.createElement('div');
    webcamList.className = 'mt-2 small device-list';
    
    if (devices.cameras.webcams.length > 0) {
        devices.cameras.webcams.forEach(webcam => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary clickable-device';
            option.innerHTML = `<i class="bi bi-camera-video"></i> ${webcam}`;
            option.addEventListener('click', () => {
                document.getElementById('camera-device-path').value = webcam;
            });
            webcamList.appendChild(option);
        });
    } else {
        webcamList.innerHTML = '<div class="form-text text-muted">Keine Webcams gefunden</div>';
    }
    
    // Nach dem Kamera-Device-Pfad einfügen
    const cameraInput = document.getElementById('camera-device-path');
    cameraInput.parentNode.appendChild(webcamList);
    
    // gPhoto2-Kameras anzeigen
    const gphotoList = document.createElement('div');
    gphotoList.className = 'mt-2 small device-list';
    
    if (devices.cameras.gphoto2.length > 0) {
        devices.cameras.gphoto2.forEach(camera => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary';
            option.innerHTML = `<i class="bi bi-camera"></i> ${camera}`;
            gphotoList.appendChild(option);
        });
    } else {
        gphotoList.innerHTML = '<div class="form-text text-muted">Keine gphoto2-Kameras gefunden</div>';
    }
    
    // Nach dem Kameratyp einfügen
    const cameraType = document.getElementById('camera-type');
    cameraType.parentNode.appendChild(gphotoList);
    
    // Arduino-Geräte anzeigen
    const arduinoList = document.createElement('div');
    arduinoList.className = 'mt-2 small device-list';
    
    if (devices.arduinos.length > 0) {
        devices.arduinos.forEach(arduino => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary clickable-device';
            option.innerHTML = `<i class="bi bi-cpu"></i> ${arduino.port} - ${arduino.description}`;
            option.addEventListener('click', () => {
                document.getElementById('arduino-port').value = arduino.port;
            });
            arduinoList.appendChild(option);
        });
    } else {
        arduinoList.innerHTML = '<div class="form-text text-muted">Keine Arduino-Geräte gefunden</div>';
    }
    
    // Nach dem Arduino-Port einfügen
    const arduinoInput = document.getElementById('arduino-port');
    arduinoInput.parentNode.appendChild(arduinoList);
}

// Add existing code from previous settings.js here...
document.addEventListener('DOMContentLoaded', () => {
    // Geräteliste laden
    loadDevices();
    
    // Konfiguration vom Server laden
    fetch('/get_config')
        .then(response => response.json())
        .then(config => {
            console.log('Geladene Konfiguration:', config);
            
            // Kamera-Einstellungen
            if (config.camera) {
                document.getElementById('camera-device-path').value = config.camera.device_path || '';
                document.getElementById('camera-type').value = config.camera.type || 'webcam';
                
                // Kamera-Auflösung setzen
                const cameraWidth = config.camera.resolution?.width;
                const cameraHeight = config.camera.resolution?.height;
                
                if (cameraWidth && cameraHeight) {
                    cameraWidthInput.value = cameraWidth;
                    cameraHeightInput.value = cameraHeight;
                    
                    // Set preset dropdown
                    const presetValue = `${cameraWidth}x${cameraHeight}`;
                    const presetOption = Array.from(cameraResolutionPreset.options)
                        .find(option => option.value === presetValue);
                    
                    if (presetOption) {
                        cameraResolutionPreset.value = presetValue;
                    } else {
                        cameraResolutionPreset.value = 'custom';
                    }
                }
            }
            
            // Arduino-Einstellungen
            if (config.arduino) {
                document.getElementById('arduino-port').value = config.arduino.port || '';
                document.getElementById('arduino-baudrate').value = config.arduino.baudrate || 9600;
            }
            
            // Rotations-Einstellungen
            if (config.rotation) {
                document.getElementById('rotation-degrees').value = config.rotation.default_degrees || 15;
                document.getElementById('rotation-interval').value = config.rotation.default_interval || 5;
            }
            
            // Simulator-Einstellungen
            if (config.simulator !== undefined) {
                // Hier ist der Fehler - wir müssen den richtigen Radio-Button auswählen
                if (config.simulator.enabled) {
                    simulatorOnBtn.checked = true;
                } else {
                    simulatorOffBtn.checked = true;
                }
            }
        })
        .catch(error => {
            console.error('Fehler beim Laden der Konfiguration:', error);
        });
});

// Aktualisierungsknopf für Geräteliste
const deviceRefreshButton = document.createElement('button');
deviceRefreshButton.type = 'button';
deviceRefreshButton.className = 'btn btn-outline-secondary mt-3';
deviceRefreshButton.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Geräte aktualisieren';
deviceRefreshButton.addEventListener('click', loadDevices);

// CSS für klickbare Geräte
const style = document.createElement('style');
style.textContent = `
    .clickable-device {
        cursor: pointer;
        transition: color 0.2s;
    }
    .clickable-device:hover {
        color: #0056b3 !important;
        text-decoration: underline;
    }
`;
document.head.appendChild(style);

// Knopf zum Formular hinzufügen (nach dem Laden der Seite)
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('settings-form').insertBefore(
        deviceRefreshButton,
        document.querySelector('.d-grid.gap-2.d-md-flex')
    );
});

// Formular-Abschicken
document.getElementById('settings-form').addEventListener('submit', (e) => {
    e.preventDefault();

    // Prepare configuration object
    const config = {
        camera: {
            device_path: document.getElementById('camera-device-path').value,
            type: document.getElementById('camera-type').value,
            resolution: {
                width: parseInt(cameraWidthInput.value || 0),
                height: parseInt(cameraHeightInput.value || 0)
            }
        },
        arduino: {
            port: document.getElementById('arduino-port').value,
            baudrate: parseInt(document.getElementById('arduino-baudrate').value)
        },
        rotation: {
            default_degrees: parseInt(document.getElementById('rotation-degrees').value),
            default_interval: parseInt(document.getElementById('rotation-interval').value)
        },
        simulator: {
            enabled: document.getElementById('simulator-on').checked
        }
    };

    console.log("Einstellungen zum Speichern:", config);

    // Send configuration to server
    fetch('/save_config', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(config)
    })
    .then(response => {
        if (response.ok) {
            return response.json();
        } else {
            throw new Error('Netzwerkfehler beim Speichern');
        }
    })
    .then(data => {
        if (data.status === 'success') {
            // Show success message
            alert('Einstellungen erfolgreich gespeichert!');
            // Redirect to main page
            window.location.href = '/';
        } else {
            alert('Fehler beim Speichern der Einstellungen: ' + (data.message || 'Unbekannter Fehler'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Fehler beim Speichern der Einstellungen: ' + error.message);
    });
});
EOL

# static/js/viewer.js
cat > "$TEMP_DIR/static/js/viewer.js" << 'EOL'
/**
 * 360° Produktansicht Viewer
 * Interaktiver Viewer für 360-Grad-Produktansichten
 */

// DOM-Elemente
const viewerContainer = document.getElementById('product-viewer');
const spinner = document.getElementById('spinner');
const playButton = document.getElementById('play-btn');
const resetButton = document.getElementById('reset-btn');
const zoomInButton = document.getElementById('zoom-in-btn');
const zoomOutButton = document.getElementById('zoom-out-btn');
const fullscreenButton = document.getElementById('fullscreen-btn');
const projectNameElement = document.querySelector('#project-name span');
const imageCountElement = document.querySelector('#image-count span');

// Viewer-Konfiguration
let config = {
    images: [],            // Bildpfade
    currentImageIndex: 0,  // Aktueller Bildindex
    autoRotate: false,     // Automatische Rotation
    autoRotateSpeed: 100,  // Rotationsgeschwindigkeit in ms
    zoom: 1.0,             // Zoomstufe
    maxZoom: 2.5,          // Maximale Zoomstufe
    minZoom: 1.0,          // Minimale Zoomstufe
    zoomStep: 0.1,         // Zoom-Schritt pro Klick
    dragging: false,       // Maus/Touch-Status
    lastX: 0,              // Letzte X-Position
    autoRotateTimer: null  // Timer für Auto-Rotation
};

// Projekt-ID aus URL-Parametern holen
const urlParams = new URLSearchParams(window.location.search);
const projectId = urlParams.get('project');

/**
 * Lädt die Projektdaten vom Server
 */
async function loadProject() {
    if (!projectId) {
        showError('Keine Projekt-ID angegeben');
        return;
    }
    
    try {
        const response = await fetch(`/api/project/${projectId}`);
        
        if (!response.ok) {
            throw new Error('Projekt konnte nicht geladen werden');
        }
        
        const projectData = await response.json();
        
        // Projektdaten anzeigen
        projectNameElement.textContent = projectData.name;
        imageCountElement.textContent = projectData.image_count;
        
        // Bilder laden
        config.images = projectData.images.map(img => `/static/projects/${projectId}/${img}`);
        
        if (config.images.length > 0) {
            initViewer();
        } else {
            showError('Keine Bilder im Projekt gefunden');
        }
    } catch (error) {
        console.error('Fehler beim Laden des Projekts:', error);
        showError('Fehler beim Laden des Projekts');
    }
}

/**
 * Initialisiert den 360° Viewer
 */
function initViewer() {
    // Bilder vorladen
    preloadImages().then(() => {
        // Spinner ausblenden
        spinner.style.display = 'none';
        
        // Erstes Bild anzeigen
        showImage(0);
        
        // Event-Listener hinzufügen
        setupEventListeners();
        
        // Automatische Rotation starten
        startAutoRotate();
    });
}

/**
 * Lädt alle Bilder vor
 */
async function preloadImages() {
    const preloadPromises = config.images.map(src => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve();
            img.onerror = () => reject();
            img.src = src;
            img.className = 'product-image';
            img.style.display = 'none';
            img.draggable = false;
            viewerContainer.appendChild(img);
        });
    });
    
    return Promise.all(preloadPromises);
}

/**
 * Zeigt das Bild mit dem angegebenen Index an
 */
function showImage(index) {
    // Aktuelles Bild ausblenden
    const currentImage = viewerContainer.querySelector('.active');
    if (currentImage) {
        currentImage.classList.remove('active');
    }
    
    // Neues Bild anzeigen
    const newImage = viewerContainer.querySelectorAll('img')[index];
    if (newImage) {
        newImage.classList.add('active');
        config.currentImageIndex = index;
    }
}

/**
 * Richtet Event-Listener für Maus/Touch-Interaktionen ein
 */
function setupEventListeners() {
    // Maus-Events
    viewerContainer.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);
    
    // Touch-Events
    viewerContainer.addEventListener('touchstart', startDrag);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', endDrag);
    
    // Zoom-Events
    zoomInButton.addEventListener('click', zoomIn);
    zoomOutButton.addEventListener('click', zoomOut);
    viewerContainer.addEventListener('wheel', handleWheel);
    
    // Steuerungs-Buttons
    playButton.addEventListener('click', toggleAutoRotate);
    resetButton.addEventListener('click', resetViewer);
    fullscreenButton.addEventListener('click


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/README.md ---
360° Drehteller Fotografie-System

## Projektbeschreibung
Dieses Projekt ist ein komplettes System zur Erstellung interaktiver 360°-Produktansichten mit einem Laptop / Raspberry Pi 4, Arduino und einer Kamera. Der Arduino steuert einen Drehteller über ein Relais, während die Kamera automatisch Fotos aufnimmt. Die Web-Oberfläche ermöglicht die Steuerung, Konfiguration und Anzeige der 360°-Ansichten.

![Drehteller System](static/placeholder.jpg)

## Voraussetzungen

### Hardware
- Raspberry Pi 4 (mit Raspbian) / besser PC
- Arduino Uno
- Relais-Modul (für 220V/30W Drehmotor)
- Webcam oder DSLR-Kamera mit USB-Anschluss
- Schneckengetriebe-Drehteller (0,8° CW Drehgeschwindigkeit)

### Software
- Python 3.8+
- pip
- Arduino IDE (für die Programmierung des Arduino)
- Git (optional, für Versionskontrolle)

## Installation

### 1. Repository klonen
```bash
git clone https://github.com/[USERNAME]/360-drehteller.git
cd 360-drehteller
2. Abhängigkeiten installieren
Führe das Installationsskript mit Administratorrechten aus:
bashCopysudo ./install_pip_modules.sh
Dieses Skript:

Aktualisiert pip
Erstellt eine virtuelle Python-Umgebung
Installiert alle benötigten Python-Pakete
Erstellt die Verzeichnisstruktur
Generiert ein Platzhalter-Bild

3. Arduino-Code übertragen
Verbinde deinen Arduino Uno mit dem Raspberry Pi und übertrage den Steuerungscode:
bashCopy./upload_arduino_sketch.sh
Schnellstart

Aktiviere die virtuelle Umgebung:

bashCopysource myenv/bin/activate

Starte die Web-Anwendung:

bashCopypython web.py

Öffne einen Browser und navigiere zu:

Copyhttp://localhost:5000
Oder von einem anderen Gerät im Netzwerk:
Copyhttp://[Raspberry-Pi-IP]:5000
Funktionen
Hauptfunktionen

Responsive Webanwendung: Funktioniert auf PC, Tablet und Smartphone
Kamerasimulator: Ermöglicht Tests ohne angeschlossene Hardware
Projektverwaltung: Organisiert verschiedene 360°-Aufnahmen
Interaktiver 360°-Viewer: Ähnlich professionellen Produktansichten im E-Commerce
Arduino-Steuerung: Präzise Steuerung des Drehtellers mit einstellbaren Winkeln

Einstellungsmöglichkeiten

Kameraauswahl und -konfiguration
Arduino-Port und Baudrate
Drehwinkel und Intervall
Bildauflösung

Verzeichnisstruktur
Copy360-drehteller/
├── web.py                      # Hauptanwendung (Flask)
├── project_manager.py          # Projektverwaltung
├── config_manager.py           # Konfigurationsmanagement
├── git_uploader.py             # Git-Upload-Werkzeug
├── arduino_drehteller_steuerung.ino  # Arduino-Sketch
├── upload_arduino_sketch.sh    # Arduino-Upload-Skript
├── install_pip_modules.sh      # Installationsskript
├── templates/                  # HTML-Templates
│   ├── index.html              # Hauptseite
│   ├── settings.html           # Einstellungen
│   ├── projects.html           # Projektverwaltung
│   ├── project_edit.html       # Projektbearbeitung
│   └── viewer.html             # 360°-Viewer
├── static/                     # Statische Dateien
│   ├── css/                    # Stylesheet-Dateien
│   ├── js/                     # JavaScript-Dateien
│   ├── photos/                 # Aufgenommene Fotos
│   └── sample_images/          # Beispielbilder für Simulator
└── projects/                   # Projektdaten
Konfiguration
Kameraeinstellungen

Unterstützt Webcams und DSLR-Kameras (via gphoto2)
Konfigurierbare Auflösung
Automatische Kameraerkennung

Arduino-Verbindung

Standard-Port: /dev/ttyACM0
Baudrate: 9600
Einfache Steuerung über serielle Befehle (0/1)

Fehlerbehandlung
Häufige Probleme

Arduino nicht erkannt

Überprüfe den Port unter Einstellungen
Stelle sicher, dass die richtige Firmware hochgeladen ist


Kamera funktioniert nicht

Überprüfe mit v4l2-ctl --list-devices
Stelle sicher, dass die Kamera erkannt wird


Relais schaltet nicht

Überprüfe die Verkabelung
Teste den Arduino mit dem Test-Skript



Entwicklung
Beiträge
Beiträge zum Projekt sind willkommen! Bitte folge diesen Schritten:

Fork des Repositories
Feature-Branch erstellen
Änderungen committen
Pull Request einreichen


Kontakt
Bei Fragen oder Anregungen stehe ich gerne zur Verfügung.

E-Mail: info €at) alexanderbehrensPungDcom
GitHub: https://github.com/alexanderbehrens1978/drehteller


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/funktioniert-03-03-2025 ---


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/.gitignore ---
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
myenv/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Flask
instance/
.webassets-cache

# Captured Images and Generated Files
static/photos/*
static/sample_images/*
!static/photos/.gitkeep
!static/sample_images/.gitkeep

# Environment
.env
.venv
env/
venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS specific
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/relais_test.ino ---
// relais_test.ino
void setup() {
  Serial.begin(9600);
  pinMode(8, OUTPUT);

  Serial.println("Relais-Test startet");
  digitalWrite(8, HIGH);  // Dauerhaft einschalten
  Serial.println("Relais sollte jetzt eingeschaltet sein");
}

void loop() {
  // Nichts hier, Relais bleibt eingeschaltet
}

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/install_pip_modules.sh ---
#!/bin/bash
# install_pip_modules.sh

# Farbcodes für Terminal-Ausgaben
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Drehteller 360° - Python Abhängigkeiten Installation${NC}"
echo "=============================================="

# Überprüfen, ob das Skript mit sudo ausgeführt wird
if [ "$EUID" -ne 0 ]
  then echo -e "${RED}Bitte führen Sie das Skript mit sudo aus.${NC}"
  echo "Beispiel: sudo bash install_pip_modules.sh"
  exit 1
fi

# Überprüfen, ob Python 3 installiert ist
if ! command -v python3 &> /dev/null
then
    echo -e "${RED}Python 3 ist nicht installiert. Bitte installieren Sie Python 3.${NC}"
    exit 1
fi

# Überprüfen, ob pip3 installiert ist
if ! command -v pip3 &> /dev/null
then
    echo -e "${YELLOW}pip3 ist nicht installiert. Versuche pip3 zu installieren...${NC}"
    apt-get update
    apt-get install -y python3-pip

    if ! command -v pip3 &> /dev/null
    then
        echo -e "${RED}Konnte pip3 nicht installieren. Bitte installieren Sie pip3 manuell.${NC}"
        exit 1
    fi
fi

echo -e "${GREEN}pip3 ist installiert. Aktualisiere pip...${NC}"
python3 -m pip install --upgrade pip

# Erstelle eine virtuelle Umgebung, wenn sie nicht existiert
if [ ! -d "myenv" ]; then
    echo -e "${YELLOW}Erstelle virtuelle Python-Umgebung 'myenv'...${NC}"
    python3 -m venv myenv
fi

# Aktiviere die virtuelle Umgebung
echo -e "${YELLOW}Aktiviere virtuelle Umgebung...${NC}"
source myenv/bin/activate

# Aktualisiere pip in der virtuellen Umgebung
echo -e "${YELLOW}Aktualisiere pip in der virtuellen Umgebung...${NC}"
pip install --upgrade pip setuptools wheel

# Installiere die benötigten Module
echo -e "${YELLOW}Installiere Python-Module...${NC}"

pip install flask==2.3.2
pip install werkzeug==2.3.6
pip install opencv-python-headless==4.7.0.72
pip install numpy==1.24.3
pip install pillow==9.5.0
pip install pyserial==3.5
pip install scipy==1.10.1
pip install pandas==2.0.1
pip install requests==2.30.0
pip install imageio==2.31.1

# Installiere zusätzliche Module
echo -e "${YELLOW}Installiere zusätzliche Python-Module...${NC}"
pip install python-dotenv
pip install gunicorn

# Erstelle die benötigten Verzeichnisse
echo -e "${YELLOW}Erstelle Verzeichnisstruktur...${NC}"
mkdir -p static/photos
mkdir -p static/sample_images
mkdir -p projects

# Generiere ein Platzhalter-Bild
echo -e "${YELLOW}Generiere Platzhalter-Bild...${NC}"
cat > generate_placeholder.py << 'EOL'
from PIL import Image, ImageDraw, ImageFont
import os

def generate_placeholder(output_path='static/placeholder.jpg', width=640, height=480):
    """
    Generiert ein Platzhalter-Bild mit Text

    :param output_path: Pfad zum Speichern des Bildes
    :param width: Bildbreite in Pixeln
    :param height: Bildhöhe in Pixeln
    """
    # Stelle sicher, dass der Zielordner existiert
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # Erstelle ein neues Bild mit grauem Hintergrund
    image = Image.new('RGB', (width, height), color=(240, 240, 240))
    draw = ImageDraw.Draw(image)

    # Zeichne Rahmen
    draw.rectangle((0, 0, width-1, height-1), outline=(200, 200, 200), width=2)

    # Füge Text hinzu
    try:
        # Versuche, einen Standardschriftsatz zu laden
        font = ImageFont.load_default()
    except IOError:
        # Fallback auf Standardschriftart
        font = ImageFont.load_default()

    text = "Kein Bild verfügbar"
    text_width = 200  # Ungefähre Textbreite
    text_position = ((width - text_width) // 2, height // 2 - 15)
    draw.text(text_position, text, fill=(100, 100, 100), font=font)

    # Speichere das Bild
    image.save(output_path)
    print(f"Platzhalter-Bild erstellt: {output_path}")

    return output_path

if __name__ == "__main__":
    generate_placeholder()
EOL

python generate_placeholder.py

# Benutzerrechte für Video-Geräte
echo -e "${YELLOW}Füge aktuellen Benutzer zur Video-Gruppe hinzu...${NC}"
usermod -a -G video $USER

# Bestätigungsnachricht
echo -e "${GREEN}Installation abgeschlossen!${NC}"
echo "Aktivieren Sie die virtuelle Umgebung mit: source myenv/bin/activate"
echo "Starten Sie die Anwendung mit: python web.py"

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/create_readme.sh ---
bashCopy#!/bin/bash
# create_readme.sh

cat > README.md << 'EOL'
# 360° Drehteller Fotografie-System

## Projektbeschreibung
Dieses Projekt ist ein vollständiges System zur Erstellung interaktiver 360°-Produktansichten mit einem Raspberry Pi, Arduino und einer Kamera. Es bietet eine responsive Weboberfläche zur Steuerung eines motorisierten Drehtellers, der eine Plattform über ein Schneckengetriebe dreht, während automatisch Fotos aufgenommen werden.

Die Anwendung ermöglicht es, professionelle 360°-Produktansichten zu erstellen, ähnlich denen, die in modernen E-Commerce-Plattformen verwendet werden.

## Funktionen

- **Motorgesteuerte Plattform**: Steuerung eines 220V/30W Drehtellers (0,8° pro Sekunde) über Arduino und Relais
- **Automatische Fotoaufnahme**: Unterstützung für Webcams und DSLR-Kameras (via gphoto2)
- **Responsive Benutzeroberfläche**: Funktioniert auf Desktop, Tablet und Smartphone
- **Projektverwaltung**: Organisiert verschiedene 360°-Produkt-Aufnahmen
- **Interaktiver 360°-Viewer**: Mit Auto-Rotation und Mouse/Touch Drag-Funktion
- **Konfigurierbare Einstellungen**: Einstellbare Schrittwinkel, Foto-Intervalle und Kamera-Auflösung

## Voraussetzungen

### Hardware
- Raspberry Pi 4 (mit Raspbian OS)
- Arduino Uno (R3 oder R4)
- Relais-Modul (für 220V/30W Drehmotor)
- Webcam oder DSLR-Kamera mit USB-Anschluss
- Schneckengetriebe-Drehteller (0,8° CW Drehgeschwindigkeit)

### Software
- Python 3.8+
- Flask
- OpenCV
- Arduino IDE oder Arduino CLI

## Installation

### Automatische Installation

Das Projekt enthält Skripte zur automatischen Installation und Einrichtung:

1. Klone das Repository:
```bash
git clone https://github.com/[USERNAME]/360-drehteller.git
cd 360-drehteller

Führe das Setup-Skript aus (dies richtet alles ein, inklusive Autostart):

bashCopysudo ./setup_and_autostart.sh
Das Skript erledigt:

Installation aller Abhängigkeiten
Einrichtung einer virtuellen Python-Umgebung
Erstellung des Autostart-Services
Konfiguration von Nginx (optional)
Erstellung der Verzeichnisstruktur


Übertrage den Arduino-Code:

bashCopy./upload_arduino_sketch.sh
Manuelle Installation
Alternativ kannst du die einzelnen Komponenten manuell installieren:

System-Abhängigkeiten:

bashCopysudo apt-get update
sudo apt-get install -y python3-venv python3-dev python3-pip python3-opencv fswebcam v4l-utils libatlas-base-dev git

Python-Umgebung:

bashCopypython3 -m venv myenv
source myenv/bin/activate
pip install -r requirements.txt

Arduino-Sketch übertragen (verwende die Arduino IDE oder unser Skript)

Verwendung
Weboberfläche starten
Die Anwendung ist über deinen Webbrowser erreichbar:

Wenn du Nginx eingerichtet hast: http://raspberry-pi-ip/
Ohne Nginx: http://raspberry-pi-ip:5000/

Dienst verwalten
Verwende das Hilfsskript zur Verwaltung des Dienstes:
bashCopy./drehteller.sh start    # Dienst starten
./drehteller.sh stop     # Dienst stoppen
./drehteller.sh restart  # Dienst neustarten
./drehteller.sh status   # Status anzeigen
./drehteller.sh logs     # Logs anzeigen
360° Aufnahme erstellen

Wähle auf der Startseite "360° Projekte verwalten"
Erstelle ein neues Projekt
Konfiguriere die Aufnahmeparameter (Drehwinkel, Intervall)
Starte die 360°-Aufnahme mit "Volle 360° Aufnahme"
Warte, bis die Aufnahme abgeschlossen ist
Öffne die 360°-Ansicht über "360° Ansicht"

Verzeichnisstruktur
Copy360-drehteller/
├── web.py                    # Flask-Hauptanwendung
├── project_manager.py        # Projektverwaltung
├── config_manager.py         # Konfigurationsverwaltung
├── git_uploader.py           # Git-Upload-Tool
├── upload_arduino_sketch.sh  # Arduino-Upload
├── setup_and_autostart.sh    # Automatische Einrichtung
├── drehteller.sh             # Dienstverwaltung
├── templates/                # HTML-Templates
├── static/                   # Statische Assets (CSS, JS, Bilder)
└── projects/                 # Projektdaten
Konfiguration
Die Anwendung kann über die Einstellungsseite im Webinterface konfiguriert werden:

Kameraeinstellungen: Pfad, Auflösung, Typ (Webcam/DSLR)
Arduino-Einstellungen: Port, Baudrate
Rotationseinstellungen: Standardwinkel, Intervall
Simulator-Modus: Für Tests ohne Hardware

Fehlerbehebung
Kamera wird nicht erkannt

Überprüfe die Verbindung zur Kamera
Führe v4l2-ctl --list-devices aus, um verfügbare Kameras zu sehen
Stelle sicher, dass der Benutzer in der video-Gruppe ist: sudo usermod -a -G video $USER

Arduino-Verbindung funktioniert nicht

Überprüfe den seriellen Port in den Einstellungen
Führe ls /dev/tty* aus, um verfügbare Ports zu sehen
Stelle sicher, dass der Benutzer in der dialout-Gruppe ist: sudo usermod -a -G dialout $USER

Drehteller bewegt sich nicht

Überprüfe die Verkabelung zum Relais
Teste das Relais mit dem Skript serial-test.py
Überprüfe die Arduino-Firmware mit dem Arduino IDE Serial Monitor

Weiterentwicklung
Code-Struktur
Die Anwendung verwendet einen modularen Ansatz mit separaten Komponenten für:

Web-Interface (Flask)
Projektverwaltung
Kamerafunktionen
Arduino-Steuerung
360°-Viewer

Jedes Modul ist auf maximal 60 Zeilen Code begrenzt, um Clean Code-Prinzipien zu folgen.
Mögliche Erweiterungen

Integration von Bildbearbeitung für bessere Produktdarstellung
Zusätzliche Beleuchtungssteuerung
Automatische Hintergrundentfernung
Export in verschiedene 360°-Viewer-Formate

Mitwirkende und Lizenz
Dieses Projekt steht unter MIT-Lizenz. Beiträge und Verbesserungen sind willkommen.
Entwickelt von [DEIN NAME]

Bei Fragen oder Problemen öffne ein Issue im GitHub-Repository oder kontaktiere den Entwickler direkt.
EOL
echo "README.md erfolgreich erstellt!"


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/webcam_simulator.py ---
import cv2
import os
import time
import random
import subprocess
import warnings
from datetime import datetime

from webcam_detection_helper import find_working_webcam, test_webcam_capture


class WebcamCaptureSimulator:
    def __init__(self, base_path='static/photos', sample_images_path='static/sample_images'):
        """
        Initialize webcam capture simulator

        :param base_path: Directory to save captured photos
        :param sample_images_path: Directory containing sample images to use
        """
        self.base_path = base_path
        self.sample_images_path = sample_images_path

        # Ensure base and sample image directories exist
        os.makedirs(base_path, exist_ok=True)
        os.makedirs(sample_images_path, exist_ok=True)

        # Find the best webcam device
        self.camera_device = self._find_best_camera_device()

    def _find_best_camera_device(self, preferred_devices=None):
        """
        Find the best camera device to use

        :param preferred_devices: Optional list of preferred device paths
        :return: Best working device path
        """
        # If specific devices are known, try those first
        if preferred_devices is None:
            preferred_devices = ['/dev/video0', '/dev/video1']

        # Find a working webcam
        return find_working_webcam(preferred_devices)

    def capture_photo(self, filename=None):
        """
        Capture a photo - either from a real webcam or simulate with a sample image

        :param filename: Optional custom filename
        :return: Path to the saved image
        """
        # Ensure the base path exists
        os.makedirs(self.base_path, exist_ok=True)

        # If no filename provided, generate a unique one
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'webcam_photo_{timestamp}.jpg'

        # Ensure filename is just the basename
        filename = os.path.basename(filename)

        # Full path for the new image
        full_path = os.path.join(self.base_path, filename)

        # Try to capture from the detected camera device
        if self.camera_device:
            try:
                success, captured_path = test_webcam_capture(self.camera_device)
                if success:
                    # Copy the captured image to the desired filename
                    import shutil
                    shutil.copy(captured_path, full_path)
                    return full_path
            except Exception as e:
                print(f"Camera capture error: {e}")

        # Fallback to sample image simulation
        sample_images = [
            f for f in os.listdir(self.sample_images_path)
            if f.lower().endswith(('.png', '.jpg', '.jpeg'))
        ]

        if sample_images:
            # Randomly select a sample image
            selected_sample = random.choice(sample_images)
            sample_path = os.path.join(self.sample_images_path, selected_sample)

            # Copy the sample image to the photos directory
            import shutil
            shutil.copy(sample_path, full_path)
            return full_path

        # Last resort - create a blank image
        import numpy as np
        blank_image = np.zeros((480, 640, 3), dtype=np.uint8)
        cv2.putText(blank_image, "No Image Available", (50, 250),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
        cv2.imwrite(full_path, blank_image)
        return full_path

    def list_photos(self):
        """
        List all photos in the base path

        :return: List of photo filenames
        """
        return [f for f in os.listdir(self.base_path)
                if f.lower().endswith(('.png', '.jpg', '.jpeg'))]


# Standalone usage example
if __name__ == '__main__':
    # Initialize the webcam capture simulator
    webcam_simulator = WebcamCaptureSimulator()

    # Capture 5 photos
    for i in range(5):
        captured_image = webcam_simulator.capture_photo()
        print(f"Captured image: {captured_image}")

    # List captured images
    print("\nCaptured Images:")
    for photo in webcam_simulator.list_photos():
        print(photo)


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/device_detector.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modul zur Erkennung von Kameras und Arduino-Geräten.
Erkennt automatisch verfügbare Geräte und aktualisiert regelmäßig die Liste.
"""

import os
import time
import logging
import subprocess
import glob
import threading
from serial.tools import list_ports

from webcam_detection_helper import find_working_webcam

# Logger konfigurieren
logger = logging.getLogger("drehteller360.device_detector")


class DeviceDetector:
    """Erkennt und verfolgt verfügbare Kameras und Arduino-Geräte."""

    def __init__(self, scan_interval=10):
        """
        Initialisiert den Gerätedetektor.

        Args:
            scan_interval: Zeit in Sekunden zwischen Geräte-Scans
        """
        self.scan_interval = scan_interval
        self.devices = {
            'cameras': {
                'webcams': [],
                'gphoto2': []
            },
            'arduinos': []
        }
        self.running = False
        self.lock = threading.Lock()

    def detect_webcams(self):
        """Erkennt angeschlossene Webcams."""
        webcam_devices = []

        try:
            # Videoeingabegeräte finden
            video_devices = glob.glob('/dev/video*')
            working_webcam = find_working_webcam(video_devices)

            if working_webcam:
                webcam_devices.append(working_webcam)

            for device in video_devices:
                if device != working_webcam and os.path.exists(device):
                    webcam_devices.append(device)
        except Exception as e:
            logger.error(f"Fehler bei der Webcam-Erkennung: {e}")

        return webcam_devices

    def detect_gphoto2_cameras(self):
        """Erkennt Kameras, die mit gphoto2 kompatibel sind."""
        gphoto2_cameras = []

        try:
            # Prüfen, ob gphoto2 installiert ist
            result = subprocess.run(['which', 'gphoto2'],
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)

            if result.returncode == 0:
                # Kameras auflisten
                result = subprocess.run(['gphoto2', '--auto-detect'],
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE,
                                        text=True)

                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[2:]:  # Überschriften überspringen
                        if line.strip():
                            gphoto2_cameras.append(line.strip())
        except Exception as e:
            logger.error(f"Fehler bei der gphoto2-Kamera-Erkennung: {e}")

        return gphoto2_cameras

    def detect_arduinos(self):
        """Erkennt angeschlossene Arduino-Geräte."""
        arduino_devices = []

        try:
            # Serielle Ports auflisten
            ports = list(list_ports.comports())
            for port in ports:
                if "Arduino" in port.description or "ACM" in port.device:
                    arduino_devices.append({
                        'port': port.device,
                        'description': port.description
                    })
        except Exception as e:
            logger.error(f"Fehler bei der Arduino-Erkennung: {e}")

        return arduino_devices

    def scan_devices(self):
        """Scannt nach allen verfügbaren Geräten."""
        with self.lock:
            self.devices['cameras']['webcams'] = self.detect_webcams()
            self.devices['cameras']['gphoto2'] = self.detect_gphoto2_cameras()
            self.devices['arduinos'] = self.detect_arduinos()

        logger.info(f"Geräte erkannt: {len(self.devices['cameras']['webcams'])} Webcams, "
                    f"{len(self.devices['cameras']['gphoto2'])} gphoto2-Kameras, "
                    f"{len(self.devices['arduinos'])} Arduino-Geräte")

    def get_devices(self):
        """Gibt die aktuell erkannten Geräte zurück."""
        with self.lock:
            return self.devices.copy()

    def start_detection(self):
        """Startet den Erkennungsprozess in einer Schleife."""
        self.running = True

        while self.running:
            self.scan_devices()
            time.sleep(self.scan_interval)

    def stop_detection(self):
        """Stoppt den Erkennungsprozess."""
        self.running = False


# Globale Instanz für die Anwendung
device_detector = DeviceDetector()

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/alles.txt ---

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/arduino_drehteller_steuerung.ino ---
// arduino_drehteller_steuerung.ino

// Definiere den Pin für das Relais
#define RELAIS_PIN 8

void setup() {
  // Initialisiere die serielle Kommunikation mit 9600 Baud
  Serial.begin(9600);

  // Konfiguriere den Relais-Pin als Ausgang
  pinMode(RELAIS_PIN, OUTPUT);

  // Stelle sicher, dass das Relais zu Beginn ausgeschaltet ist
  digitalWrite(RELAIS_PIN, LOW);

  Serial.println("Arduino Drehteller Steuerung bereit");
}

void loop() {
  // Prüfe, ob Daten verfügbar sind
  if (Serial.available() > 0) {
    // Lese eingehende Daten
    char command = Serial.read();

    // Interpretiere Befehl
    if (command == '1') {
      // Relais einschalten
      digitalWrite(RELAIS_PIN, HIGH);
      Serial.println("Relais eingeschaltet - Drehteller läuft");
    }
    else if (command == '0') {
      // Relais ausschalten
      digitalWrite(RELAIS_PIN, LOW);
      Serial.println("Relais ausgeschaltet - Drehteller gestoppt");
    }
    else {
      // Unbekannter Befehl
      Serial.println("Unbekannter Befehl empfangen. Verwende '1' zum Einschalten und '0' zum Ausschalten.");
    }
  }

  // Kurze Pause, um CPU-Last zu reduzieren
  delay(10);
}


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/create_project_zip.sh ---
#!/bin/bash
# Skript zum Erstellen einer ZIP-Datei des drehteller-360 Projekts

# Farbige Ausgabe
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Drehteller 360° ZIP-Erstellungstool${NC}"
echo "======================================"

# Prüfen, ob zip installiert ist
if ! command -v zip &> /dev/null; then
    echo -e "${RED}Das 'zip'-Programm ist nicht installiert. Bitte installiere es zuerst.${NC}"
    echo "Auf Ubuntu/Debian: sudo apt-get install zip"
    echo "Auf Fedora: sudo dnf install zip"
    echo "Auf macOS: sollte bereits installiert sein"
    exit 1
fi

# Erstellen der Projektstruktur
echo -e "${YELLOW}Erstelle temporäre Projektstruktur...${NC}"

# Temporäres Verzeichnis
TEMP_DIR="drehteller-360-temp"
ZIP_NAME="drehteller-360-projekt.zip"

# Bereinigen des temporären Verzeichnisses, falls es existiert
rm -rf "$TEMP_DIR"
mkdir -p "$TEMP_DIR"

# Erstellen der Verzeichnisstruktur
mkdir -p "$TEMP_DIR/templates"
mkdir -p "$TEMP_DIR/static/css"
mkdir -p "$TEMP_DIR/static/js"
mkdir -p "$TEMP_DIR/static/photos"
mkdir -p "$TEMP_DIR/static/projects"
mkdir -p "$TEMP_DIR/static/sample_images"

# Python-Hauptdateien
echo -e "${YELLOW}Erstelle Python-Hauptdateien...${NC}"

# main.py
cat > "$TEMP_DIR/main.py" << 'EOL'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Hauptanwendungseinstiegspunkt für die 360° Drehteller-Steuerung.
Startet den Webserver und initialisiert alle benötigten Komponenten.
"""

import os
import sys
import logging
from threading import Thread

# Stelle sicher, dass wir im richtigen Verzeichnis sind
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

# Initialisiere Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("drehteller360.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("drehteller360")

# Stelle sicher, dass die benötigten Verzeichnisse existieren
os.makedirs('static/photos', exist_ok=True)
os.makedirs('static/sample_images', exist_ok=True)
os.makedirs('static/projects', exist_ok=True)

# Importiere erst nach Verzeichnissetup
from web import app
from device_detector import DeviceDetector
from config_manager import config_manager

def check_dependencies():
    """Überprüft, ob alle erforderlichen Abhängigkeiten installiert sind."""
    try:
        import flask
        import cv2
        import serial
        import numpy
        logger.info("Alle erforderlichen Python-Pakete sind installiert.")
        return True
    except ImportError as e:
        logger.error(f"Fehlende Abhängigkeit: {e}")
        print(f"Fehler: {e}. Bitte führen Sie 'pip install -r requirements.txt' aus.")
        return False

if __name__ == "__main__":
    logger.info("Starte 360° Drehteller-Steuerung...")
    
    if not check_dependencies():
        sys.exit(1)
    
    # Initialisiere Gerätedetektor im Hintergrund
    device_detector = DeviceDetector()
    detection_thread = Thread(target=device_detector.start_detection, daemon=True)
    detection_thread.start()
    
    # Starte den Flask-Server
    host = config_manager.get('web.host', '0.0.0.0')
    port = config_manager.get('web.port', 5000)
    debug = config_manager.get('web.debug', True)
    
    logger.info(f"Webserver wird gestartet auf {host}:{port}")
    app.run(host=host, port=port, debug=debug)
EOL

# web.py
cat > "$TEMP_DIR/web.py" << 'EOL'
from flask import Flask, render_template, request, send_from_directory, jsonify
import os
import json
import time
import serial
import subprocess

# Import config manager
from config_manager import config_manager

# Import the webcam capture simulator
from webcam_simulator import WebcamCaptureSimulator
from sample_images_generator import SampleImagesGenerator
from webcam_detection_helper import find_working_webcam, get_camera_capabilities, test_webcam_capture
from device_detector import device_detector
from viewer_generator import viewer_generator

app = Flask(__name__)

# Configuration retrieval
USE_SIMULATOR = config_manager.get('simulator.enabled', True)

# Initialize webcam capture simulator
webcam_simulator = WebcamCaptureSimulator()

# Initialize sample images generator (optional, run once to generate images)
if not os.path.exists('static/sample_images') or len(os.listdir('static/sample_images')) < 5:
    image_generator = SampleImagesGenerator()
    image_generator.generate_sample_images(10)

# Arduino connection
def get_arduino_connection():
    """
    Establish Arduino connection based on configuration
    """
    try:
        if USE_SIMULATOR:
            return None
        
        port = config_manager.get('arduino.port', '/dev/ttyACM0')
        baudrate = config_manager.get('arduino.baudrate', 9600)
        
        arduino = serial.Serial(port, baudrate, timeout=1)
        time.sleep(2)  # Wait for initialization
        return arduino
    except Exception as e:
        print(f"Arduino connection error: {e}")
        return None

# Global Arduino connection
arduino = get_arduino_connection()

def rotate_teller(degrees):
    """
    Rotate the platform
    
    :param degrees: Rotation angle
    """
    if USE_SIMULATOR:
        print(f"Simulated rotation: {degrees} degrees")
        return
    
    if arduino is None:
        print("Arduino not connected!")
        return
    
    # Berechnung der Drehzeit basierend auf der Gradzahl (0,8 Grad pro Sekunde)
    rotation_time = degrees / 0.8
    
    # Relais einschalten (Drehteller starten)
    arduino.write(b'1')  # '1' senden, um das Relais einzuschalten
    time.sleep(rotation_time)  # Warte für die berechnete Zeit
    arduino.write(b'0')  # '0' senden, um das Relais auszuschalten
    print(f"Drehteller um {degrees} Grad gedreht.")

def take_photo(filename=None):
    """
    Capture a photo
    
    :param filename: Optional custom filename
    :return: Path to the saved photo
    """
    if USE_SIMULATOR:
        # Use the webcam simulator to generate a photo
        # Ensure filename is just the basename
        if filename:
            filename = os.path.basename(filename)
        return webcam_simulator.capture_photo(filename)
    
    try:
        # Camera device path and resolution from configuration
        camera_device = config_manager.get('camera.device_path', '/dev/video0')
        camera_type = config_manager.get('camera.type', 'webcam')
        
        # Get camera resolution
        camera_width = config_manager.get('camera.resolution.width')
        camera_height = config_manager.get('camera.resolution.height')
        
        # Use actual webcam capture for real hardware
        if not filename:
            filename = f'photo_{int(time.time())}.jpg'
        
        # Ensure filename is just the basename
        filename = os.path.basename(filename)
        full_path = os.path.join('static/photos', filename)
        
        # Choose capture method based on camera type
        if camera_type == 'gphoto2':
            # Use gphoto2 for DSLR cameras
            subprocess.call(['gphoto2', '--capture-image-and-download', '--filename', full_path])
        else:
            # Default to OpenCV for webcams
            import cv2
            cap = cv2.VideoCapture(camera_device)
            
            # Set resolution if specified
            if camera_width and camera_height:
                cap.set(cv2.CAP_PROP_FRAME_WIDTH, camera_width)
                cap.set(cv2.CAP_PROP_FRAME_HEIGHT, camera_height)
            
            ret, frame = cap.read()
            if ret:
                cv2.imwrite(full_path, frame)
                cap.release()
            else:
                # Fallback to fswebcam if OpenCV fails
                subprocess.call(['fswebcam', '--no-banner', 
                                 '-d', camera_device, 
                                 full_path])
        
        print(f"Foto aufgenommen und als {filename} gespeichert.")
        return filename
    except Exception as e:
        print(f"Fehler beim Aufnehmen des Fotos: {e}")
        return None

@app.route('/generate_sample_images', methods=['POST'])
def generate_sample_images():
    """
    Generate sample images for the simulator
    """
    try:
        # Ensure sample images directory exists
        os.makedirs('static/sample_images', exist_ok=True)
        
        # Generate sample images
        image_generator = SampleImagesGenerator()
        generated_images = image_generator.generate_sample_images(10)
        
        return jsonify({
            "status": "success", 
            "message": f"{len(generated_images)} sample images generated",
            "images": generated_images
        })
    except Exception as e:
        print(f"Error generating sample images: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

@app.route('/test_webcam_simulator', methods=['POST'])
def test_webcam_simulator():
    """
    Test the webcam simulator by capturing a sample image
    """
    try:
        # Ensure photos directory exists
        os.makedirs('static/photos', exist_ok=True)
        
        # Capture a test photo using the simulator
        photo_path = webcam_simulator.capture_photo('test_simulator.jpg')
        
        # Return the photo path relative to static folder
        return photo_path.replace('static/', '/static/')
    except Exception as e:
        print(f"Error testing webcam simulator: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

@app.route('/camera_capabilities', methods=['GET'])
def camera_capabilities():
    """
    Get camera device capabilities
    """
    try:
        # Get camera device from configuration
        camera_device = config_manager.get('camera.device_path', '/dev/video0')
        
        # Get camera capabilities
        capabilities = get_camera_capabilities(camera_device)
        
        return jsonify({
            "status": "success",
            "capabilities": capabilities
        })
    except Exception as e:
        print(f"Error getting camera capabilities: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

# Routes
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/settings')
def settings():
    return render_template('settings.html')

@app.route('/viewer')
def view_360():
    """Zeigt den 360°-Viewer an."""
    return render_template('viewer.html')

@app.route('/get_config')
def get_config():
    """
    Retrieve current configuration
    """
    return jsonify(config_manager.config)

@app.route('/save_config', methods=['POST'])
def save_config():
    """
    Save new configuration
    """
    try:
        new_config = request.json
        if not new_config:
            return jsonify({"status": "error", "message": "Keine Konfigurationsdaten empfangen"}), 400
            
        # Konfiguration speichern
        success = config_manager.save_config(new_config)
        
        if success:
            return jsonify({"status": "success"})
        else:
            return jsonify({"status": "error", "message": "Fehler beim Speichern der Konfiguration"}), 500
    except Exception as e:
        print(f"Error saving configuration: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/project/<project_id>')
def get_project(project_id):
    """Liefert Projektdaten für den 360°-Viewer."""
    try:
        project_dir = os.path.join('static/projects', project_id)
        metadata_path = os.path.join(project_dir, 'metadata.json')
        
        if not os.path.exists(metadata_path):
            return jsonify({"error": "Projekt nicht gefunden"}), 404
        
        with open(metadata_path, 'r') as f:
            metadata = json.load(f)
        
        return jsonify(metadata)
    except Exception as e:
        print(f"Fehler beim Laden der Projektdaten: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/devices')
def get_devices():
    """Liefert eine Liste aller erkannten Geräte."""
    return jsonify(device_detector.get_devices())

@app.route('/generate_360', methods=['POST'])
def generate_360():
    """Generiert einen 360°-Viewer aus den aufgenommenen Bildern."""
    try:
        # Liste der Fotos nach Zeitstempel sortieren
        photo_dir = 'static/photos'
        photos = sorted([f for f in os.listdir(photo_dir) 
                        if f.lower().endswith(('.jpg', '.jpeg', '.png'))])
        
        if not photos:
            return jsonify({"error": "Keine Fotos gefunden"}), 400
        
        # Optionale Metadaten aus der Anfrage
        metadata = request.get_json() if request.is_json else {}
        
        # 360°-Viewer generieren
        viewer_url = viewer_generator.generate_viewer(photos, metadata)
        
        if viewer_url:
            return jsonify({"status": "success", "url": viewer_url})
        else:
            return jsonify({"error": "Fehler beim Generieren des Viewers"}), 500
    except Exception as e:
        print(f"Fehler beim Generieren des 360°-Viewers: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/rotate', methods=['POST'])
def rotate():
    degrees = int(request.form['degrees'])
    interval = float(request.form.get('interval', 5))  # Default 5 seconds if not specified
    
    # Rotate platform
    rotate_teller(degrees)
    
    # Capture photo with timestamp to prevent caching
    filename = f'photo_{int(time.time())}_{degrees}.jpg'
    photo_path = take_photo(filename)
    
    # Return photo name relative to static folder
    if photo_path:
        return f'/static/photos/{os.path.basename(photo_path)}'
    else:
        return 'Error capturing photo', 500

@app.route('/static/photos/<filename>')
def serve_photo(filename):
    return send_from_directory('static/photos', filename)

if __name__ == '__main__':
    # Ensure static directories exist
    os.makedirs('static/photos', exist_ok=True)
    os.makedirs('static/sample_images', exist_ok=True)
    
    # Run the Flask app
    app.run(host='0.0.0.0', port=5000, debug=True)
EOL

# device_detector.py
cat > "$TEMP_DIR/device_detector.py" << 'EOL'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modul zur Erkennung von Kameras und Arduino-Geräten.
Erkennt automatisch verfügbare Geräte und aktualisiert regelmäßig die Liste.
"""

import os
import time
import logging
import subprocess
import glob
import threading
from serial.tools import list_ports

from webcam_detection_helper import find_working_webcam

# Logger konfigurieren
logger = logging.getLogger("drehteller360.device_detector")

class DeviceDetector:
    """Erkennt und verfolgt verfügbare Kameras und Arduino-Geräte."""
    
    def __init__(self, scan_interval=10):
        """
        Initialisiert den Gerätedetektor.
        
        Args:
            scan_interval: Zeit in Sekunden zwischen Geräte-Scans
        """
        self.scan_interval = scan_interval
        self.devices = {
            'cameras': {
                'webcams': [],
                'gphoto2': []
            },
            'arduinos': []
        }
        self.running = False
        self.lock = threading.Lock()
    
    def detect_webcams(self):
        """Erkennt angeschlossene Webcams."""
        webcam_devices = []
        
        try:
            # Videoeingabegeräte finden
            video_devices = glob.glob('/dev/video*')
            working_webcam = find_working_webcam(video_devices)
            
            if working_webcam:
                webcam_devices.append(working_webcam)
                
            for device in video_devices:
                if device != working_webcam and os.path.exists(device):
                    webcam_devices.append(device)
        except Exception as e:
            logger.error(f"Fehler bei der Webcam-Erkennung: {e}")
        
        return webcam_devices
    
    def detect_gphoto2_cameras(self):
        """Erkennt Kameras, die mit gphoto2 kompatibel sind."""
        gphoto2_cameras = []
        
        try:
            # Prüfen, ob gphoto2 installiert ist
            result = subprocess.run(['which', 'gphoto2'], 
                                     stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE)
            
            if result.returncode == 0:
                # Kameras auflisten
                result = subprocess.run(['gphoto2', '--auto-detect'], 
                                        stdout=subprocess.PIPE, 
                                        stderr=subprocess.PIPE, 
                                        text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[2:]:  # Überschriften überspringen
                        if line.strip():
                            gphoto2_cameras.append(line.strip())
        except Exception as e:
            logger.error(f"Fehler bei der gphoto2-Kamera-Erkennung: {e}")
        
        return gphoto2_cameras
    
    def detect_arduinos(self):
        """Erkennt angeschlossene Arduino-Geräte."""
        arduino_devices = []
        
        try:
            # Serielle Ports auflisten
            ports = list(list_ports.comports())
            for port in ports:
                if "Arduino" in port.description or "ACM" in port.device:
                    arduino_devices.append({
                        'port': port.device,
                        'description': port.description
                    })
        except Exception as e:
            logger.error(f"Fehler bei der Arduino-Erkennung: {e}")
        
        return arduino_devices
    
    def scan_devices(self):
        """Scannt nach allen verfügbaren Geräten."""
        with self.lock:
            self.devices['cameras']['webcams'] = self.detect_webcams()
            self.devices['cameras']['gphoto2'] = self.detect_gphoto2_cameras()
            self.devices['arduinos'] = self.detect_arduinos()
            
        logger.info(f"Geräte erkannt: {len(self.devices['cameras']['webcams'])} Webcams, "
                   f"{len(self.devices['cameras']['gphoto2'])} gphoto2-Kameras, "
                   f"{len(self.devices['arduinos'])} Arduino-Geräte")
    
    def get_devices(self):
        """Gibt die aktuell erkannten Geräte zurück."""
        with self.lock:
            return self.devices.copy()
    
    def start_detection(self):
        """Startet den Erkennungsprozess in einer Schleife."""
        self.running = True
        
        while self.running:
            self.scan_devices()
            time.sleep(self.scan_interval)
    
    def stop_detection(self):
        """Stoppt den Erkennungsprozess."""
        self.running = False

# Globale Instanz für die Anwendung
device_detector = DeviceDetector()
EOL

# viewer_generator.py
cat > "$TEMP_DIR/viewer_generator.py" << 'EOL'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modul zur Generierung des 360°-Viewers aus einer Serie von Bildern.
Bereitet Bilder auf und erstellt HTML/JavaScript für den interaktiven Viewer.
"""

import os
import json
import shutil
import logging
import time
from datetime import datetime
from PIL import Image

# Logger konfigurieren
logger = logging.getLogger("drehteller360.viewer_generator")

class ViewerGenerator:
    """Generiert einen interaktiven 360°-Viewer aus einer Serie von Bildern."""
    
    def __init__(self, photo_dir='static/photos', output_dir='static/projects'):
        """
        Initialisiert den Viewer-Generator.
        
        Args:
            photo_dir: Verzeichnis mit den Quellfotos
            output_dir: Ausgabeverzeichnis für generierte Projekte
        """
        self.photo_dir = photo_dir
        self.output_dir = output_dir
        
        # Stelle sicher, dass das Ausgabeverzeichnis existiert
        os.makedirs(output_dir, exist_ok=True)
    
    def prepare_images(self, images, project_name):
        """
        Bereitet Bilder für den 360°-Viewer vor (Größenanpassung, Optimierung).
        
        Args:
            images: Liste der Bildpfade
            project_name: Name des Projekts
            
        Returns:
            Pfad zum Projektverzeichnis
        """
        project_dir = os.path.join(self.output_dir, project_name)
        os.makedirs(project_dir, exist_ok=True)
        
        processed_images = []
        
        for i, img_path in enumerate(images):
            try:
                # Lade Bild
                img = Image.open(os.path.join(self.photo_dir, img_path))
                
                # Passe Größe an (max. 1200px Breite für optimale Performance)
                max_width = 1200
                if img.width > max_width:
                    ratio = max_width / img.width
                    new_height = int(img.height * ratio)
                    img = img.resize((max_width, new_height), Image.LANCZOS)
                
                # Speichere optimiertes Bild
                img_filename = f"image_{i:03d}.jpg"
                output_path = os.path.join(project_dir, img_filename)
                img.save(output_path, "JPEG", quality=85, optimize=True)
                
                processed_images.append(img_filename)
            except Exception as e:
                logger.error(f"Fehler bei der Bildverarbeitung für {img_path}: {e}")
        
        return project_dir, processed_images
    
    def generate_viewer(self, images, metadata=None):
        """
        Generiert einen 360°-Viewer aus den gegebenen Bildern.
        
        Args:
            images: Liste der Bildpfade
            metadata: Zusätzliche Metadaten für das Projekt
            
        Returns:
            URL zum erstellten Viewer
        """
        if not images:
            logger.error("Keine Bilder zum Generieren des Viewers gefunden")
            return None
            
        # Projektname erstellen (Zeitstempel)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        project_name = f"project_{timestamp}"
        
        # Bilder vorbereiten
        project_dir, processed_images = self.prepare_images(images, project_name)
        
        # Erstelle Projektmetadaten
        project_metadata = {
            "name": project_name,
            "created": time.time(),
            "image_count": len(processed_images),
            "images": processed_images,
            "user_metadata": metadata or {}
        }
        
        # Speichere Metadaten
        metadata_path = os.path.join(project_dir, "metadata.json")
        with open(metadata_path, "w") as f:
            json.dump(project_metadata, f)
            
        return f"/viewer?project={project_name}"

# Globale Instanz für die Anwendung
viewer_generator = ViewerGenerator()
EOL

# config_manager.py
cat > "$TEMP_DIR/config_manager.py" << 'EOL'
import os
import json
import logging

# Logger konfigurieren
logger = logging.getLogger("drehteller360.config_manager")

class ConfigManager:
    DEFAULT_CONFIG = {
        'camera': {
            'device_path': '/dev/video0',
            'type': 'webcam',  # or 'gphoto2'
            'resolution': {
                'width': 1280,
                'height': 720
            }
        },
        'arduino': {
            'port': '/dev/ttyACM0',
            'baudrate': 9600
        },
        'rotation': {
            'default_degrees': 15,
            'default_interval': 5
        },
        'simulator': {
            'enabled': True
        },
        'web': {
            'host': '0.0.0.0',
            'port': 5000,
            'debug': True
        }
    }

    def __init__(self, config_path=None):
        """
        Initialize configuration manager
        
        :param config_path: Path to the configuration file
        """
        # Determine the project directory
        self.project_dir = os.path.dirname(os.path.abspath(__file__))
        
        # If no config path provided, use a default in the project directory
        if config_path is None:
            config_path = os.path.join(self.project_dir, 'config.json')
        
        self.config_path = config_path
        self.config = self.load_config()
    
    def load_config(self):
        """
        Load configuration from file or create default
        
        :return: Configuration dictionary
        """
        try:
            # Ensure config directory exists
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            
            # Try to load existing config
            if os.path.exists(self.config_path):
                with open(self.config_path, 'r') as f:
                    loaded_config = json.load(f)
                    
                    # Rekursives Zusammenführen von Konfigurationen
                    return self._merge_configs(self.DEFAULT_CONFIG, loaded_config)
            else:
                # Create default config file
                config = self.DEFAULT_CONFIG.copy()
                self.save_config(config)
                return config
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            # If loading fails, use default config and try to save it
            try:
                self.save_config(self.DEFAULT_CONFIG)
            except Exception as save_error:
                logger.error(f"Error saving default config: {save_error}")
            return self.DEFAULT_CONFIG.copy()
    
    def _merge_configs(self, default_config, user_config):
        """
        Rekursives Zusammenführen von Konfigurationen
        
        :param default_config: Default-Konfiguration
        :param user_config: Benutzerkonfiguration
        :return: Zusammengeführte Konfiguration
        """
        result = default_config.copy()
        
        for key, value in user_config.items():
            # Wenn der Wert ein Dictionary ist und im Default-Config existiert
            if isinstance(value, dict) and key in result and isinstance(result[key], dict):
                # Rekursiv zusammenführen
                result[key] = self._merge_configs(result[key], value)
            else:
                # Sonst den Wert überschreiben
                result[key] = value
                
        return result
    
    def save_config(self, new_config=None):
        """
        Save configuration to file
        
        :param new_config: Optional new configuration to save
        """
        try:
            # Use provided config or current config
            if new_config is not None:
                # Merge with current config to ensure all keys exist
                config_to_save = self._merge_configs(self.config, new_config)
            else:
                config_to_save = self.config
            
            # Ensure full path exists
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            
            # Save configuration
            with open(self.config_path, 'w') as f:
                json.dump(config_to_save, f, indent=4)
            
            # Update current config
            self.config = config_to_save
            logger.info(f"Konfiguration erfolgreich gespeichert in {self.config_path}")
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def get(self, key, default=None):
        """
        Get a configuration value
        
        :param key: Dot-separated key (e.g. 'camera.device_path')
        :param default: Default value if key not found
        :return: Configuration value
        """
        try:
            # Split the key into parts
            parts = key.split('.')
            
            # Navigate through nested dictionary
            value = self.config
            for part in parts:
                if part in value:
                    value = value[part]
                else:
                    return default
            
            return value
        except Exception as e:
            logger.error(f"Error getting config value: {e}")
            return default

# Create a global config manager
config_manager = ConfigManager()

# Standalone usage example
if __name__ == '__main__':
    # Example usage
    print("Camera Device Path:", config_manager.get('camera.device_path'))
    print("Arduino Port:", config_manager.get('arduino.port'))
    
    # Example of updating config
    test_config = {
        'camera': {
            'device_path': '/dev/video1',
            'type': 'gphoto2'
        }
    }
    config_manager.save_config(test_config)
    
    # Verify changes
    print("\nAfter Update:")
    print("Camera Device Path:", config_manager.get('camera.device_path'))
    print("Arduino Port:", config_manager.get('arduino.port'))
EOL

# webcam_detection_helper.py
cat > "$TEMP_DIR/webcam_detection_helper.py" << 'EOL'
import cv2
import os
import time
import subprocess
import warnings

def find_working_webcam(preferred_devices=None):
    """
    Find a working webcam device
    
    :param preferred_devices: List of device paths to try first
    :return: Working device path or None
    """
    # Prioritize video0 for Microsoft LifeCam HD-5000
    if preferred_devices is None:
        preferred_devices = ['/dev/video0', '/dev/video1']
    
    # First, try fswebcam to check device functionality
    for device in preferred_devices:
        try:
            # Use subprocess to run fswebcam test
            result = subprocess.run([
                'fswebcam', 
                '-d', device, 
                '--no-banner', 
                '--device-timeout', '2',  # Short timeout
                '/dev/null'  # Discard output
            ], capture_output=True, text=True, timeout=3)
            
            # If fswebcam succeeds, return this device
            if result.returncode == 0:
                return device
        except subprocess.TimeoutExpired:
            continue
        except Exception:
            continue
    
    # Fallback to OpenCV detection
    for device in preferred_devices:
        try:
            # Try OpenCV capture
            cap = cv2.VideoCapture(device)
            ret, frame = cap.read()
            if ret and frame is not None and frame.size > 0:
                cap.release()
                return device
            cap.release()
        except Exception:
            pass
    
    # Comprehensive search if all else fails
    try:
        # Use v4l2-ctl to list all video devices
        result = subprocess.run(['v4l2-ctl', '--list-devices'], 
                                capture_output=True, 
                                text=True)
        
        # Extract all /dev/video* devices
        devices = [
            line.strip() 
            for line in result.stdout.split('\n') 
            if line.startswith('/dev/video')
        ]
        
        # Try each discovered device
        for device in devices:
            try:
                # Try fswebcam first
                result = subprocess.run([
                    'fswebcam', 
                    '-d', device, 
                    '--no-banner', 
                    '--device-timeout', '2',
                    '/dev/null'
                ], capture_output=True, text=True, timeout=3)
                
                if result.returncode == 0:
                    return device
                
                # Fallback to OpenCV
                cap = cv2.VideoCapture(device)
                ret, frame = cap.read()
                if ret and frame is not None and frame.size > 0:
                    cap.release()
                    return device
                cap.release()
            except Exception:
                continue
    except Exception:
        pass
    
    return None

def get_camera_capabilities(device_path):
    """
    Retrieve camera capabilities
    
    :param device_path: Path to the video device
    :return: Dictionary of camera capabilities
    """
    capabilities = {
        'supported_resolutions': [],
        'max_width': 0,
        'max_height': 0
    }
    
    try:
        # Use v4l2-ctl to get detailed device information
        result = subprocess.run([
            'v4l2-ctl', 
            '-d', device_path, 
            '--list-formats-ext'
        ], capture_output=True, text=True, timeout=3)
        
        # Parse output to extract resolutions
        resolutions = []
        for line in result.stdout.split('\n'):
            if 'Size' in line:
                try:
                    # Extract resolution like '640x480'
                    resolution = line.split(':')[-1].strip()
                    width, height = map(int, resolution.split('x'))
                    resolutions.append((width, height))
                    
                    # Track max resolution
                    capabilities['max_width'] = max(capabilities['max_width'], width)
                    capabilities['max_height'] = max(capabilities['max_height'], height)
                except Exception:
                    pass
        
        capabilities['supported_resolutions'] = sorted(set(resolutions))
    except Exception as e:
        print(f"Error getting camera capabilities: {e}")
    
    return capabilities

def test_webcam_capture(device_path, width=None, height=None):
    """
    Attempt to capture an image from the specified device with optional resolution
    
    :param device_path: Path to the video device
    :param width: Optional desired width
    :param height: Optional desired height
    :return: Tuple (success, captured_image_path)
    """
    try:
        # Ensure output directory exists
        os.makedirs('static/photos', exist_ok=True)
        
        # Generate unique filename
        filename = f'webcam_test_{int(time.time())}.jpg'
        full_path = os.path.join('static/photos', filename)
        
        # Prepare fswebcam command
        cmd = ['fswebcam', 
               '-d', device_path, 
               '--no-banner', 
               '--device-timeout', '2']
        
        # Add resolution if specified
        if width and height:
            cmd.extend(['-r', f'{width}x{height}'])
        
        cmd.append(full_path)
        
        # Try fswebcam first
        subprocess.run(cmd, check=True, timeout=5)
        
        # Verify file was created
        if os.path.exists(full_path) and os.path.getsize(full_path) > 0:
            return True, full_path
        
        # Fallback to OpenCV with resolution
        cap = cv2.VideoCapture(device_path)
        
        # Set resolution if specified
        if width and height:
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)
        
        ret, frame = cap.read()
        if ret:
            cv2.imwrite(full_path, frame)
            cap.release()
            return True, full_path
        cap.release()
        
        return False, None
    
    except subprocess.TimeoutExpired:
        print(f"Timeout capturing from {device_path}")
        return False, None
    except Exception as e:
        print(f"Webcam capture error: {e}")
        return False, None

# Standalone usage example
if __name__ == '__main__':
    # Find a working webcam
    working_device = find_working_webcam()
    
    if working_device:
        print(f"Found working webcam at: {working_device}")
        
        # Get camera capabilities
        capabilities = get_camera_capabilities(working_device)
        print("\nCamera Capabilities:")
        print(f"Supported Resolutions: {capabilities['supported_resolutions']}")
        print(f"Max Resolution: {capabilities['max_width']}x{capabilities['max_height']}")
        
        # Try capturing at a specific resolution
        success, image_path = test_webcam_capture(working_device, 1280, 720)
        
        if success:
            print(f"\nTest image captured: {image_path}")
        else:
            print("\nFailed to capture test image")
    else:
        print("No working webcam found")
EOL

# webcam_simulator.py
cat > "$TEMP_DIR/webcam_simulator.py" << 'EOL'
import cv2
import os
import time
import random
import subprocess
import warnings
from datetime import datetime

from webcam_detection_helper import find_working_webcam, test_webcam_capture

class WebcamCaptureSimulator:
    def __init__(self, base_path='static/photos', sample_images_path='static/sample_images'):
        """
        Initialize webcam capture simulator
        
        :param base_path: Directory to save captured photos
        :param sample_images_path: Directory containing sample images to use
        """
        self.base_path = base_path
        self.sample_images_path = sample_images_path
        
        # Ensure base and sample image directories exist
        os.makedirs(base_path, exist_ok=True)
        os.makedirs(sample_images_path, exist_ok=True)
        
        # Find the best webcam device
        self.camera_device = self._find_best_camera_device()
    
    def _find_best_camera_device(self, preferred_devices=None):
        """
        Find the best camera device to use
        
        :param preferred_devices: Optional list of preferred device paths
        :return: Best working device path
        """
        # If specific devices are known, try those first
        if preferred_devices is None:
            preferred_devices = ['/dev/video0', '/dev/video1']
        
        # Find a working webcam
        return find_working_webcam(preferred_devices)
    
    def capture_photo(self, filename=None):
        """
        Capture a photo - either from a real webcam or simulate with a sample image
        
        :param filename: Optional custom filename
        :return: Path to the saved image
        """
        # Ensure the base path exists
        os.makedirs(self.base_path, exist_ok=True)
        
        # If no filename provided, generate a unique one
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'webcam_photo_{timestamp}.jpg'
        
        # Ensure filename is just the basename
        filename = os.path.basename(filename)
        
        # Full path for the new image
        full_path = os.path.join(self.base_path, filename)
        
        # Try to capture from the detected camera device
        if self.camera_device:
            try:
                success, captured_path = test_webcam_capture(self.camera_device)
                if success:
                    # Copy the captured image to the desired filename
                    import shutil
                    shutil.copy(captured_path, full_path)
                    return full_path
            except Exception as e:
                print(f"Camera capture error: {e}")
        
        # Fallback to sample image simulation
        sample_images = [
            f for f in os.listdir(self.sample_images_path) 
            if f.lower().endswith(('.png', '.jpg', '.jpeg'))
        ]
        
        if sample_images:
            # Randomly select a sample image
            selected_sample = random.choice(sample_images)
            sample_path = os.path.join(self.sample_images_path, selected_sample)
            
            # Copy the sample image to the photos directory
            import shutil
            shutil.copy(sample_path, full_path)
            return full_path
        
        # Last resort - create a blank image
        import numpy as np
        blank_image = np.zeros((480,640,3), dtype=np.uint8)
        cv2.putText(blank_image, "No Image Available", (50,250), 
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,255), 2)
        cv2.imwrite(full_path, blank_image)
        return full_path
    
    def list_photos(self):
        """
        List all photos in the base path
        
        :return: List of photo filenames
        """
        return [f for f in os.listdir(self.base_path) 
                if f.lower().endswith(('.png', '.jpg', '.jpeg'))]

# Standalone usage example
if __name__ == '__main__':
    # Initialize the webcam capture simulator
    webcam_simulator = WebcamCaptureSimulator()
    
    # Capture 5 photos
    for i in range(5):
        captured_image = webcam_simulator.capture_photo()
        print(f"Captured image: {captured_image}")
    
    # List captured images
    print("\nCaptured Images:")
    for photo in webcam_simulator.list_photos():
        print(photo)
EOL

# sample_images_generator.py
cat > "$TEMP_DIR/sample_images_generator.py" << 'EOL'
import os
import random
import math
from PIL import Image, ImageDraw, ImageFont

class SampleImagesGenerator:
    def __init__(self, output_path='static/sample_images', width=800, height=600):
        """
        Generate sample images for webcam simulator
        
        :param output_path: Directory to save generated images
        :param width: Image width
        :param height: Image height
        """
        self.output_path = output_path
        self.width = width
        self.height = height
        
        # Ensure output directory exists
        os.makedirs(output_path, exist_ok=True)
    
    def generate_color_gradient_image(self, index):
        """
        Generate an image with a color gradient
        
        :param index: Unique identifier for the image
        :return: Path to the generated image
        """
        # Create a new image with a gradient
        image = Image.new('RGB', (self.width, self.height))
        draw = ImageDraw.Draw(image)
        
        # Generate gradient colors
        for y in range(self.height):
            r = int(255 * y / self.height)
            g = int(255 * (1 - y / self.height))
            b = int(128 + 127 * math.sin(y / 50))
            
            draw.line([(0, y), (self.width, y)], fill=(r, g, b))
        
        # Add text to identify the image
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 36)
        except IOError:
            font = ImageFont.load_default()
        
        draw.text((50, 50), f"Sample Image {index}", font=font, fill=(255, 255, 255))
        
        # Save the image
        filename = os.path.join(self.output_path, f'sample_image_{index}.jpg')
        image.save(filename)
        return filename
    
    def generate_sample_images(self, count=10):
        """
        Generate multiple sample images
        
        :param count: Number of images to generate
        :return: List of generated image paths
        """
        generated_images = []
        for i in range(count):
            image_path = self.generate_color_gradient_image(i)
            generated_images.append(image_path)
        
        return generated_images

# Optionally, if you want to use this as a standalone script
if __name__ == '__main__':
    generator = SampleImagesGenerator()
    generated_images = generator.generate_sample_images()
    
    print("Generated Sample Images:")
    for img in generated_images:
        print(img)
EOL

# HTML-Templates
echo -e "${YELLOW}Erstelle HTML-Templates...${NC}"

# templates/index.html
cat > "$TEMP_DIR/templates/index.html" << 'EOL'
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Drehteller Steuerung</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/index.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h2 class="mb-0">360° Drehteller Steuerung</h2>
                <a href="/settings" class="btn btn-light btn-sm">
                    <i class="bi bi-gear"></i> Einstellungen
                </a>
            </div>
            <div class="card-body">
                <!-- Captured Image Display -->
                <div class="text-center mb-4">
                    <img id="captured-image" src="/static/placeholder.jpg" alt="Aktuelles Foto" class="img-fluid">
                </div>

                <!-- Rotation Settings -->
                <div id="rotation-settings" class="row g-3">
                    <div class="col-md-4">
                        <label for="rotation-interval" class="form-label">Foto-Intervall (Sekunden)</label>
                        <input type="number" class="form-control" id="rotation-interval" value="5" min="1" max="60">
                    </div>
                    <div class="col-md-4">
                        <label for="rotation-degrees" class="form-label">Drehwinkel pro Schritt</label>
                        <input type="number" class="form-control" id="rotation-degrees" value="15" min="1" max="90">
                    </div>
                    <div class="col-md-4 d-flex align-items-end gap-2">
                        <button id="start-360-rotation" class="btn btn-success btn-play flex-grow-1">
                            <i class="bi bi-play-fill"></i> Start 360°
                        </button>
                        <button id="stop-rotation" class="btn btn-danger btn-stop d-none">
                            <i class="bi bi-stop-fill"></i> Stop
                        </button>
                    </div>
                </div>

                <!-- Progress Display -->
                <div id="progress-container" class="mt-3" style="display: none;">
                    <div class="progress">
                        <div id="rotation-progress" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                    <div id="rotation-status" class="text-center mt-2"></div>
                </div>

                <!-- 360° Viewer generieren -->
                <div id="generate-360-container" class="mt-4">
                    <h3>360° Viewer generieren</h3>
                    <div class="row g-3">
                        <div class="col-md-8">
                            <input type="text" class="form-control" id="project-name" placeholder="Projektname (optional)">
                        </div>
                        <div class="col-md-4">
                            <button id="generate-360-btn" class="btn btn-primary w-100">
                                <i class="bi bi-camera-video"></i> 360° Viewer erstellen
                            </button>
                        </div>
                    </div>
                    <div id="generation-status" class="mt-2"></div>
                </div>

                <!-- Manual Rotation -->
                <div class="mt-4">
                    <h3>Manuelle Rotation</h3>
                    <form id="manual-rotation-form">
                        <div class="input-group">
                            <input type="number" class="form-control" id="manual-degrees" placeholder="Drehwinkel" min="0" max="360" required>
                            <button type="submit" class="btn btn-primary">
                                <i class="bi bi-arrow-clockwise"></i> Drehen
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/index.js"></script>
    <script>
        // 360° Viewer Generierung
        document.getElementById('generate-360-btn').addEventListener('click', async () => {
            const statusElement = document.getElementById('generation-status');
            statusElement.innerHTML = '<div class="alert alert-info">Generiere 360° Viewer...</div>';
            
            const projectName = document.getElementById('project-name').value;
            
            try {
                const response = await fetch('/generate_360', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: projectName || ('Projekt ' + new Date().toLocaleDateString())
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    statusElement.innerHTML = `
                        <div class="alert alert-success">
                            360° Viewer erfolgreich erstellt! 
                            <a href="${result.url}" class="btn btn-sm btn-primary ms-2">Anzeigen</a>
                        </div>`;
                } else {
                    statusElement.innerHTML = `<div class="alert alert-danger">Fehler: ${result.error}</div>`;
                }
            } catch (error) {
                statusElement.innerHTML = `<div class="alert alert-danger">Fehler: ${error.message}</div>`;
            }
        });
    </script>
</body>
</html>
EOL

# templates/settings.html
cat > "$TEMP_DIR/templates/settings.html" << 'EOL'
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drehteller Einstellungen</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/settings.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white">
                <h2 class="text-center mb-0">
                    <i class="bi bi-gear me-2"></i>Drehteller Einstellungen
                </h2>
            </div>
            <div class="card-body">
                <form id="settings-form">
                    <!-- Camera Settings -->
                    <div class="mb-3">
                        <h4>Kamera Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-8">
                                <label for="camera-device-path" class="form-label">Geräte-Pfad</label>
                                <input type="text" class="form-control" id="camera-device-path" 
                                       placeholder="/dev/video0" required>
                                <div class="form-text">Pfad zum Kameragerät (z.B. /dev/video0)</div>
                            </div>
                            <div class="col-md-4">
                                <label for="camera-type" class="form-label">Kameratyp</label>
                                <select class="form-select" id="camera-type">
                                    <option value="webcam">Webcam</option>
                                    <option value="gphoto2">DSLR (gphoto2)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Arduino Settings -->
                    <div class="mb-3">
                        <h4>Arduino Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-8">
                                <label for="arduino-port" class="form-label">Serieller Port</label>
                                <input type="text" class="form-control" id="arduino-port" 
                                       placeholder="/dev/ttyACM0" required>
                                <div class="form-text">Pfad zum Arduino-Port (z.B. /dev/ttyACM0)</div>
                            </div>
                            <div class="col-md-4">
                                <label for="arduino-baudrate" class="form-label">Baudrate</label>
                                <select class="form-select" id="arduino-baudrate">
                                    <option value="9600">9600</option>
                                    <option value="115200">115200</option>
                                    <option value="57600">57600</option>
                                    <option value="38400">38400</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Rotation Settings -->
                    <div class="mb-3">
                        <h4>Rotations-Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-6">
                                <label for="rotation-degrees" class="form-label">Standard Drehwinkel</label>
                                <input type="number" class="form-control" id="rotation-degrees" 
                                       min="1" max="90" value="15">
                                <div class="form-text">Standardwinkel pro Rotationsschritt</div>
                            </div>
                            <div class="col-md-6">
                                <label for="rotation-interval" class="form-label">Foto-Intervall</label>
                                <input type="number" class="form-control" id="rotation-interval" 
                                       min="1" max="60" value="5">
                                <div class="form-text">Sekunden zwischen Fotos</div>
                            </div>
                        </div>
                    </div>


                    <!-- Camera Resolution Settings -->
                    <div class="mb-3">
                        <h4>Kamera-Auflösung</h4>
                        <div class="row g-3">
                            <div class="col-md-4">
                                <label for="camera-width" class="form-label">Breite (Pixel)</label>
                                <input type="number" class="form-control" id="camera-width" 
                                       placeholder="z.B. 1280" min="160" max="3840">
                            </div>
                            <div class="col-md-4">
                                <label for="camera-height" class="form-label">Höhe (Pixel)</label>
                                <input type="number" class="form-control" id="camera-height" 
                                       placeholder="z.B. 720" min="120" max="2160">
                            </div>
                            <div class="col-md-4">
                                <label for="camera-resolution-preset" class="form-label">Voreinstellungen</label>
                                <select class="form-select" id="camera-resolution-preset">
                                    <option value="custom">Benutzerdefiniert</option>
                                    <option value="640x480">640x480 (VGA)</option>
                                    <option value="1280x720">1280x720 (HD)</option>
                                    <option value="1920x1080">1920x1080 (Full HD)</option>
                                    <option value="2560x1440">2560x1440 (QHD)</option>
                                    <option value="3840x2160">3840x2160 (4K)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Simulator Controls -->
                    <div class="mt-4">
                        <h4>Simulator Einstellungen</h4>
                        <div class="row g-3">
                            <div class="col-md-4">
                                <label class="form-label">Simulator-Modus</label>
                                <div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="simulator-mode" id="simulator-on" value="true">
                                        <label class="form-check-label" for="simulator-on">
                                            Ein
                                        </label>
                                    </div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="simulator-mode" id="simulator-off" value="false">
                                        <label class="form-check-label" for="simulator-off">
                                            Aus
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-8">
                                <label class="form-label">Simulator-Tools</label>
                                <div>
                                    <button type="button" id="generate-sample-images" class="btn btn-secondary me-2">
                                        <i class="bi bi-image me-2"></i>Beispielbilder generieren
                                    </button>
                                    <button type="button" id="test-webcam-simulator" class="btn btn-info">
                                        <i class="bi bi-camera me-2"></i>Webcam-Simulator testen
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="d-grid gap-2 d-md-flex justify-content-md-end mt-4">
                        <a href="/" class="btn btn-secondary">
                            <i class="bi bi-x-circle me-2"></i>Abbrechen
                        </a>
                        <button type="submit" class="btn btn-primary">
                            <i class="bi bi-save me-2"></i>Speichern
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/settings.js"></script>
</body>
</html>
EOL

# templates/viewer.html
cat > "$TEMP_DIR/templates/viewer.html" << 'EOL'
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Viewer - Drehteller Steuerung</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/viewer.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h2 class="mb-0">360° Produktansicht</h2>
                <div>
                    <a href="/" class="btn btn-light btn-sm me-2">
                        <i class="bi bi-house"></i> Zurück zur Steuerung
                    </a>
                    <button id="fullscreen-btn" class="btn btn-light btn-sm">
                        <i class="bi bi-fullscreen"></i>
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div id="viewer-container" class="position-relative">
                    <!-- Viewer wird hier per JavaScript eingefügt -->
                    <div id="spinner" class="position-absolute top-50 start-50 translate-middle">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Laden...</span>
                        </div>
                    </div>
                    <div id="product-viewer" class="viewer-360"></div>
                </div>
                
                <div class="mt-4 d-flex justify-content-between">
                    <div class="viewer-controls">
                        <button id="play-btn" class="btn btn-primary">
                            <i class="bi bi-play-fill"></i> Auto-Rotation
                        </button>
                        <button id="reset-btn" class="btn btn-secondary ms-2">
                            <i class="bi bi-arrow-counterclockwise"></i> Zurücksetzen
                        </button>
                    </div>
                    
                    <div class="zoom-controls">
                        <button id="zoom-in-btn" class="btn btn-outline-secondary">
                            <i class="bi bi-zoom-in"></i>
                        </button>
                        <button id="zoom-out-btn" class="btn btn-outline-secondary ms-2">
                            <i class="bi bi-zoom-out"></i>
                        </button>
                    </div>
                </div>
                
                <div class="mt-4">
                    <div class="project-info">
                        <h4 id="project-name">Projekt: <span></span></h4>
                        <p id="image-count">Bilder: <span></span></p>
                    </div>
                </div>
            </div>
            
            <div class="card-footer text-center">
                <p>Bewegen Sie die Maus oder wischen Sie auf dem Touchscreen, um das Objekt zu drehen.</p>
                <small class="text-muted">Erstellt mit Drehteller 360° Steuerung</small>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/viewer.js"></script>
</body>
</html>
EOL

# CSS-Dateien
echo -e "${YELLOW}Erstelle CSS-Dateien...${NC}"

# static/css/index.css
cat > "$TEMP_DIR/static/css/index.css" << 'EOL'
body {
    background-color: #f4f4f4;
    padding-top: 50px;
}

.container {
    max-width: 800px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#captured-image {
    max-width: 100%;
    max-height: 400px;
    object-fit: contain;
    margin-bottom: 20px;
}

.btn-play, .btn-stop {
    font-size: 2rem;
    padding: 10px 20px;
}

#progress-container {
    margin-top: 20px;
}

#rotation-settings {
    margin-top: 20px;
}

@media (max-width: 768px) {
    body {
        padding-top: 20px;
    }
    .container {
        padding: 0 15px;
    }
}
EOL

# static/css/settings.css
cat > "$TEMP_DIR/static/css/settings.css" << 'EOL'
body {
    background-color: #f4f4f4;
    padding-top: 50px;
}

.container {
    max-width: 600px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

@media (max-width: 768px) {
    body {
        padding-top: 20px;
    }
    .container {
        padding: 0 15px;
    }
}

/* Optional: Add some subtle styling to form elements */
.form-control, .form-select {
    transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.form-control:focus, .form-select:focus {
    border-color: #0d6efd;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

/* Simulator mode radio buttons */
.form-check-input:checked {
    background-color: #0d6efd;
    border-color: #0d6efd;
}

/* Clickable device items */
.clickable-device {
    cursor: pointer;
    transition: color 0.2s;
}
.clickable-device:hover {
    color: #0056b3 !important;
    text-decoration: underline;
}
EOL

# static/css/viewer.css
cat > "$TEMP_DIR/static/css/viewer.css" << 'EOL'
body {
    background-color: #f4f4f4;
    padding-top: 20px;
    padding-bottom: 20px;
}

.container {
    max-width: 1200px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#viewer-container {
    position: relative;
    width: 100%;
    height: 500px;
    background-color: #fff;
    overflow: hidden;
    touch-action: none; /* Verhindert Browser-Scrolling bei Touch-Gesten */
}

.viewer-360 {
    width: 100%;
    height: 100%;
    position: relative;
    cursor: grab;
}

.viewer-360:active {
    cursor: grabbing;
}

.viewer-360 img {
    position: absolute;
    max-width: 100%;
    max-height: 100%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    object-fit: contain;
    display: none;
}

.viewer-360 img.active {
    display: block;
}

/* Zoom-Effekt */
.viewer-360.zoomed {
    overflow: hidden;
}

/* Fullscreen-Modus */
.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 9999;
    background-color: #fff;
    padding: 20px;
}

.fullscreen #viewer-container {
    height: calc(100vh - 150px);
}

/* Spinner */
#spinner {
    z-index: 10;
}

/* Responsive Anpassungen */
@media (max-width: 768px) {
    #viewer-container {
        height: 350px;
    }
    
    .container {
        padding: 0 10px;
    }
    
    .viewer-controls, .zoom-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }
}

@media (max-width: 576px) {
    #viewer-container {
        height: 300px;
    }
    
    .card-header {
        flex-direction: column;
        gap: 10px;
    }
    
    .btn-sm {
        padding: 5px 8px;
        font-size: 0.8rem;
    }
}
EOL

# JavaScript-Dateien
echo -e "${YELLOW}Erstelle JavaScript-Dateien...${NC}"

# static/js/index.js
cat > "$TEMP_DIR/static/js/index.js" << 'EOL'
// DOM Elements
const startButton = document.getElementById('start-360-rotation');
const stopButton = document.getElementById('stop-rotation');
const rotationIntervalInput = document.getElementById('rotation-interval');
const rotationDegreesInput = document.getElementById('rotation-degrees');
const progressContainer = document.getElementById('progress-container');
const progressBar = document.getElementById('rotation-progress');
const rotationStatus = document.getElementById('rotation-status');
const capturedImage = document.getElementById('captured-image');
const manualRotationForm = document.getElementById('manual-rotation-form');

// Rotation state
let isRotating = false;
let rotationAborted = false;

// 360° Rotation Function
async function start360Rotation() {
    const interval = parseInt(rotationIntervalInput.value);
    const stepDegrees = parseInt(rotationDegreesInput.value);
    const totalRotations = Math.floor(360 / stepDegrees);

    // Disable start button, show stop button
    startButton.disabled = true;
    stopButton.classList.remove('d-none');
    progressContainer.style.display = 'block';
    rotationStatus.textContent = 'Rotation gestartet...';
    isRotating = true;
    rotationAborted = false;

    // Reset progress
    progressBar.style.width = '0%';
    progressBar.classList.add('progress-bar-animated');

    try {
        for (let i = 0; i < totalRotations; i++) {
            // Check if rotation was aborted
            if (rotationAborted) {
                break;
            }

            // Update progress
            const progress = ((i + 1) / totalRotations) * 100;
            progressBar.style.width = `${progress}%`;
            rotationStatus.textContent = `Foto ${i + 1} von ${totalRotations}`;

            // Send rotation and photo capture request
            const response = await fetch('/rotate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `degrees=${stepDegrees}&interval=${interval}`
            });

            // Check if request was successful
            if (!response.ok) {
                throw new Error('Rotation fehlgeschlagen');
            }

            // Update image source with the latest photo
            const result = await response.text();
            capturedImage.src = result; // Assuming the response contains the photo path

            // Wait for the specified interval
            await new Promise(resolve => setTimeout(resolve, interval * 1000));
        }

        // Rotation complete
        if (!rotationAborted) {
            rotationStatus.textContent = 'Rotation abgeschlossen!';
            progressBar.classList.remove('progress-bar-animated');
        } else {
            rotationStatus.textContent = 'Rotation abgebrochen!';
            progressBar.classList.add('bg-warning');
        }
    } catch (error) {
        // Handle errors
        rotationStatus.textContent = `Fehler: ${error.message}`;
        progressBar.classList.add('bg-danger');
    } finally {
        // Re-enable start button, hide stop button
        startButton.disabled = false;
        stopButton.classList.add('d-none');
        isRotating = false;
    }
}

// Stop Rotation Function
function stopRotation() {
    if (isRotating) {
        rotationAborted = true;
        rotationStatus.textContent = 'Rotation wird gestoppt...';
    }
}

// Manual Rotation
manualRotationForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const degrees = document.getElementById('manual-degrees').value;

    try {
        const response = await fetch('/rotate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `degrees=${degrees}`
        });

        const result = await response.text();
        capturedImage.src = result; // Update image with latest photo
    } catch (error) {
        console.error('Rotation error:', error);
    }
});

// Event Listeners
startButton.addEventListener('click', start360Rotation);
stopButton.addEventListener('click', stopRotation);
EOL

# static/js/settings.js
cat > "$TEMP_DIR/static/js/settings.js" << 'EOL'
// Camera Resolution Preset Handling
const cameraWidthInput = document.getElementById('camera-width');
const cameraHeightInput = document.getElementById('camera-height');
const cameraResolutionPreset = document.getElementById('camera-resolution-preset');
const simulatorOnBtn = document.getElementById('simulator-on');
const simulatorOffBtn = document.getElementById('simulator-off');

// Resolution preset change handler
cameraResolutionPreset.addEventListener('change', (e) => {
    const preset = e.target.value;
    
    switch(preset) {
        case '640x480':
            cameraWidthInput.value = 640;
            cameraHeightInput.value = 480;
            break;
        case '1280x720':
            cameraWidthInput.value = 1280;
            cameraHeightInput.value = 720;
            break;
        case '1920x1080':
            cameraWidthInput.value = 1920;
            cameraHeightInput.value = 1080;
            break;
        case '2560x1440':
            cameraWidthInput.value = 2560;
            cameraHeightInput.value = 1440;
            break;
        case '3840x2160':
            cameraWidthInput.value = 3840;
            cameraHeightInput.value = 2160;
            break;
        case 'custom':
            // Clear inputs or keep current values
            break;
    }
});

// Geräteliste laden
async function loadDevices() {
    try {
        const response = await fetch('/api/devices');
        const devices = await response.json();
        
        updateDeviceUI(devices);
    } catch (error) {
        console.error('Fehler beim Laden der Geräte:', error);
    }
}

// Geräte-UI aktualisieren
function updateDeviceUI(devices) {
    // Bestehende Listen entfernen (um Duplikate zu vermeiden)
    document.querySelectorAll('.device-list').forEach(el => el.remove());
    
    // Webcams anzeigen
    const webcamList = document.createElement('div');
    webcamList.className = 'mt-2 small device-list';
    
    if (devices.cameras.webcams.length > 0) {
        devices.cameras.webcams.forEach(webcam => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary clickable-device';
            option.innerHTML = `<i class="bi bi-camera-video"></i> ${webcam}`;
            option.addEventListener('click', () => {
                document.getElementById('camera-device-path').value = webcam;
            });
            webcamList.appendChild(option);
        });
    } else {
        webcamList.innerHTML = '<div class="form-text text-muted">Keine Webcams gefunden</div>';
    }
    
    // Nach dem Kamera-Device-Pfad einfügen
    const cameraInput = document.getElementById('camera-device-path');
    cameraInput.parentNode.appendChild(webcamList);
    
    // gPhoto2-Kameras anzeigen
    const gphotoList = document.createElement('div');
    gphotoList.className = 'mt-2 small device-list';
    
    if (devices.cameras.gphoto2.length > 0) {
        devices.cameras.gphoto2.forEach(camera => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary';
            option.innerHTML = `<i class="bi bi-camera"></i> ${camera}`;
            gphotoList.appendChild(option);
        });
    } else {
        gphotoList.innerHTML = '<div class="form-text text-muted">Keine gphoto2-Kameras gefunden</div>';
    }
    
    // Nach dem Kameratyp einfügen
    const cameraType = document.getElementById('camera-type');
    cameraType.parentNode.appendChild(gphotoList);
    
    // Arduino-Geräte anzeigen
    const arduinoList = document.createElement('div');
    arduinoList.className = 'mt-2 small device-list';
    
    if (devices.arduinos.length > 0) {
        devices.arduinos.forEach(arduino => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary clickable-device';
            option.innerHTML = `<i class="bi bi-cpu"></i> ${arduino.port} - ${arduino.description}`;
            option.addEventListener('click', () => {
                document.getElementById('arduino-port').value = arduino.port;
            });
            arduinoList.appendChild(option);
        });
    } else {
        arduinoList.innerHTML = '<div class="form-text text-muted">Keine Arduino-Geräte gefunden</div>';
    }
    
    // Nach dem Arduino-Port einfügen
    const arduinoInput = document.getElementById('arduino-port');
    arduinoInput.parentNode.appendChild(arduinoList);
}

// Add existing code from previous settings.js here...
document.addEventListener('DOMContentLoaded', () => {
    // Geräteliste laden
    loadDevices();
    
    // Konfiguration vom Server laden
    fetch('/get_config')
        .then(response => response.json())
        .then(config => {
            console.log('Geladene Konfiguration:', config);
            
            // Kamera-Einstellungen
            if (config.camera) {
                document.getElementById('camera-device-path').value = config.camera.device_path || '';
                document.getElementById('camera-type').value = config.camera.type || 'webcam';
                
                // Kamera-Auflösung setzen
                const cameraWidth = config.camera.resolution?.width;
                const cameraHeight = config.camera.resolution?.height;
                
                if (cameraWidth && cameraHeight) {
                    cameraWidthInput.value = cameraWidth;
                    cameraHeightInput.value = cameraHeight;
                    
                    // Set preset dropdown
                    const presetValue = `${cameraWidth}x${cameraHeight}`;
                    const presetOption = Array.from(cameraResolutionPreset.options)
                        .find(option => option.value === presetValue);
                    
                    if (presetOption) {
                        cameraResolutionPreset.value = presetValue;
                    } else {
                        cameraResolutionPreset.value = 'custom';
                    }
                }
            }
            
            // Arduino-Einstellungen
            if (config.arduino) {
                document.getElementById('arduino-port').value = config.arduino.port || '';
                document.getElementById('arduino-baudrate').value = config.arduino.baudrate || 9600;
            }
            
            // Rotations-Einstellungen
            if (config.rotation) {
                document.getElementById('rotation-degrees').value = config.rotation.default_degrees || 15;
                document.getElementById('rotation-interval').value = config.rotation.default_interval || 5;
            }
            
            // Simulator-Einstellungen
            if (config.simulator !== undefined) {
                // Hier ist der Fehler - wir müssen den richtigen Radio-Button auswählen
                if (config.simulator.enabled) {
                    simulatorOnBtn.checked = true;
                } else {
                    simulatorOffBtn.checked = true;
                }
            }
        })
        .catch(error => {
            console.error('Fehler beim Laden der Konfiguration:', error);
        });
});

// Aktualisierungsknopf für Geräteliste
const deviceRefreshButton = document.createElement('button');
deviceRefreshButton.type = 'button';
deviceRefreshButton.className = 'btn btn-outline-secondary mt-3';
deviceRefreshButton.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Geräte aktualisieren';
deviceRefreshButton.addEventListener('click', loadDevices);

// CSS für klickbare Geräte
const style = document.createElement('style');
style.textContent = `
    .clickable-device {
        cursor: pointer;
        transition: color 0.2s;
    }
    .clickable-device:hover {
        color: #0056b3 !important;
        text-decoration: underline;
    }
`;
document.head.appendChild(style);

// Knopf zum Formular hinzufügen (nach dem Laden der Seite)
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('settings-form').insertBefore(
        deviceRefreshButton,
        document.querySelector('.d-grid.gap-2.d-md-flex')
    );
});

// Formular-Abschicken
document.getElementById('settings-form').addEventListener('submit', (e) => {
    e.preventDefault();

    // Prepare configuration object
    const config = {
        camera: {
            device_path: document.getElementById('camera-device-path').value,
            type: document.getElementById('camera-type').value,
            resolution: {
                width: parseInt(cameraWidthInput.value || 0),
                height: parseInt(cameraHeightInput.value || 0)
            }
        },
        arduino: {
            port: document.getElementById('arduino-port').value,
            baudrate: parseInt(document.getElementById('arduino-baudrate').value)
        },
        rotation: {
            default_degrees: parseInt(document.getElementById('rotation-degrees').value),
            default_interval: parseInt(document.getElementById('rotation-interval').value)
        },
        simulator: {
            enabled: document.getElementById('simulator-on').checked
        }
    };

    console.log("Einstellungen zum Speichern:", config);

    // Send configuration to server
    fetch('/save_config', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(config)
    })
    .then(response => {
        if (response.ok) {
            return response.json();
        } else {
            throw new Error('Netzwerkfehler beim Speichern');
        }
    })
    .then(data => {
        if (data.status === 'success') {
            // Show success message
            alert('Einstellungen erfolgreich gespeichert!');
            // Redirect to main page
            window.location.href = '/';
        } else {
            alert('Fehler beim Speichern der Einstellungen: ' + (data.message || 'Unbekannter Fehler'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Fehler beim Speichern der Einstellungen: ' + error.message);
    });
});
EOL

# static/js/viewer.js
cat > "$TEMP_DIR/static/js/viewer.js" << 'EOL'
/**
 * 360° Produktansicht Viewer
 * Interaktiver Viewer für 360-Grad-Produktansichten
 */

// DOM-Elemente
const viewerContainer = document.getElementById('product-viewer');
const spinner = document.getElementById('spinner');
const playButton = document.getElementById('play-btn');
const resetButton = document.getElementById('reset-btn');
const zoomInButton = document.getElementById('zoom-in-btn');
const zoomOutButton = document.getElementById('zoom-out-btn');
const fullscreenButton = document.getElementById('fullscreen-btn');
const projectNameElement = document.querySelector('#project-name span');
const imageCountElement = document.querySelector('#image-count span');

// Viewer-Konfiguration
let config = {
    images: [],            // Bildpfade
    currentImageIndex: 0,  // Aktueller Bildindex
    autoRotate: false,     // Automatische Rotation
    autoRotateSpeed: 100,  // Rotationsgeschwindigkeit in ms
    zoom: 1.0,             // Zoomstufe
    maxZoom: 2.5,          // Maximale Zoomstufe
    minZoom: 1.0,          // Minimale Zoomstufe
    zoomStep: 0.1,         // Zoom-Schritt pro Klick
    dragging: false,       // Maus/Touch-Status
    lastX: 0,              // Letzte X-Position
    autoRotateTimer: null  // Timer für Auto-Rotation
};

// Projekt-ID aus URL-Parametern holen
const urlParams = new URLSearchParams(window.location.search);
const projectId = urlParams.get('project');

/**
 * Lädt die Projektdaten vom Server
 */
async function loadProject() {
    if (!projectId) {
        showError('Keine Projekt-ID angegeben');
        return;
    }
    
    try {
        const response = await fetch(`/api/project/${projectId}`);
        
        if (!response.ok) {
            throw new Error('Projekt konnte nicht geladen werden');
        }
        
        const projectData = await response.json();
        
        // Projektdaten anzeigen
        projectNameElement.textContent = projectData.name;
        imageCountElement.textContent = projectData.image_count;
        
        // Bilder laden
        config.images = projectData.images.map(img => `/static/projects/${projectId}/${img}`);
        
        if (config.images.length > 0) {
            initViewer();
        } else {
            showError('Keine Bilder im Projekt gefunden');
        }
    } catch (error) {
        console.error('Fehler beim Laden des Projekts:', error);
        showError('Fehler beim Laden des Projekts');
    }
}

/**
 * Initialisiert den 360° Viewer
 */
function initViewer() {
    // Bilder vorladen
    preloadImages().then(() => {
        // Spinner ausblenden
        spinner.style.display = 'none';
        
        // Erstes Bild anzeigen
        showImage(0);
        
        // Event-Listener hinzufügen
        setupEventListeners();
        
        // Automatische Rotation starten
        startAutoRotate();
    });
}

/**
 * Lädt alle Bilder vor
 */
async function preloadImages() {
    const preloadPromises = config.images.map(src => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve();
            img.onerror = () => reject();
            img.src = src;
            img.className = 'product-image';
            img.style.display = 'none';
            img.draggable = false;
            viewerContainer.appendChild(img);
        });
    });
    
    return Promise.all(preloadPromises);
}

/**
 * Zeigt das Bild mit dem angegebenen Index an
 */
function showImage(index) {
    // Aktuelles Bild ausblenden
    const currentImage = viewerContainer.querySelector('.active');
    if (currentImage) {
        currentImage.classList.remove('active');
    }
    
    // Neues Bild anzeigen
    const newImage = viewerContainer.querySelectorAll('img')[index];
    if (newImage) {
        newImage.classList.add('active');
        config.currentImageIndex = index;
    }
}

/**
 * Richtet Event-Listener für Maus/Touch-Interaktionen ein
 */
function setupEventListeners() {
    // Maus-Events
    viewerContainer.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);
    
    // Touch-Events
    viewerContainer.addEventListener('touchstart', startDrag);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', endDrag);
    
    // Zoom-Events
    zoomInButton.addEventListener('click', zoomIn);
    zoomOutButton.addEventListener('click', zoomOut);
    viewerContainer.addEventListener('wheel', handleWheel);
    
    // Steuerungs-Buttons
    playButton.addEventListener('click', toggleAutoRotate);
    resetButton.addEventListener('click', resetViewer);
    fullscreenButton.addEventListener('click


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/README.md ---
360° Drehteller Fotografie-System

## Projektbeschreibung
Dieses Projekt ist ein komplettes System zur Erstellung interaktiver 360°-Produktansichten mit einem Laptop / Raspberry Pi 4, Arduino und einer Kamera. Der Arduino steuert einen Drehteller über ein Relais, während die Kamera automatisch Fotos aufnimmt. Die Web-Oberfläche ermöglicht die Steuerung, Konfiguration und Anzeige der 360°-Ansichten.

![Drehteller System](static/placeholder.jpg)

## Voraussetzungen

### Hardware
- Raspberry Pi 4 (mit Raspbian) / besser PC
- Arduino Uno
- Relais-Modul (für 220V/30W Drehmotor)
- Webcam oder DSLR-Kamera mit USB-Anschluss
- Schneckengetriebe-Drehteller (0,8° CW Drehgeschwindigkeit)

### Software
- Python 3.8+
- pip
- Arduino IDE (für die Programmierung des Arduino)
- Git (optional, für Versionskontrolle)

## Installation

### 1. Repository klonen
```bash
git clone https://github.com/[USERNAME]/360-drehteller.git
cd 360-drehteller
2. Abhängigkeiten installieren
Führe das Installationsskript mit Administratorrechten aus:
bashCopysudo ./install_pip_modules.sh
Dieses Skript:

Aktualisiert pip
Erstellt eine virtuelle Python-Umgebung
Installiert alle benötigten Python-Pakete
Erstellt die Verzeichnisstruktur
Generiert ein Platzhalter-Bild

3. Arduino-Code übertragen
Verbinde deinen Arduino Uno mit dem Raspberry Pi und übertrage den Steuerungscode:
bashCopy./upload_arduino_sketch.sh
Schnellstart

Aktiviere die virtuelle Umgebung:

bashCopysource myenv/bin/activate

Starte die Web-Anwendung:

bashCopypython web.py

Öffne einen Browser und navigiere zu:

Copyhttp://localhost:5000
Oder von einem anderen Gerät im Netzwerk:
Copyhttp://[Raspberry-Pi-IP]:5000
Funktionen
Hauptfunktionen

Responsive Webanwendung: Funktioniert auf PC, Tablet und Smartphone
Kamerasimulator: Ermöglicht Tests ohne angeschlossene Hardware
Projektverwaltung: Organisiert verschiedene 360°-Aufnahmen
Interaktiver 360°-Viewer: Ähnlich professionellen Produktansichten im E-Commerce
Arduino-Steuerung: Präzise Steuerung des Drehtellers mit einstellbaren Winkeln

Einstellungsmöglichkeiten

Kameraauswahl und -konfiguration
Arduino-Port und Baudrate
Drehwinkel und Intervall
Bildauflösung

Verzeichnisstruktur
Copy360-drehteller/
├── web.py                      # Hauptanwendung (Flask)
├── project_manager.py          # Projektverwaltung
├── config_manager.py           # Konfigurationsmanagement
├── git_uploader.py             # Git-Upload-Werkzeug
├── arduino_drehteller_steuerung.ino  # Arduino-Sketch
├── upload_arduino_sketch.sh    # Arduino-Upload-Skript
├── install_pip_modules.sh      # Installationsskript
├── templates/                  # HTML-Templates
│   ├── index.html              # Hauptseite
│   ├── settings.html           # Einstellungen
│   ├── projects.html           # Projektverwaltung
│   ├── project_edit.html       # Projektbearbeitung
│   └── viewer.html             # 360°-Viewer
├── static/                     # Statische Dateien
│   ├── css/                    # Stylesheet-Dateien
│   ├── js/                     # JavaScript-Dateien
│   ├── photos/                 # Aufgenommene Fotos
│   └── sample_images/          # Beispielbilder für Simulator
└── projects/                   # Projektdaten
Konfiguration
Kameraeinstellungen

Unterstützt Webcams und DSLR-Kameras (via gphoto2)
Konfigurierbare Auflösung
Automatische Kameraerkennung

Arduino-Verbindung

Standard-Port: /dev/ttyACM0
Baudrate: 9600
Einfache Steuerung über serielle Befehle (0/1)

Fehlerbehandlung
Häufige Probleme

Arduino nicht erkannt

Überprüfe den Port unter Einstellungen
Stelle sicher, dass die richtige Firmware hochgeladen ist


Kamera funktioniert nicht

Überprüfe mit v4l2-ctl --list-devices
Stelle sicher, dass die Kamera erkannt wird


Relais schaltet nicht

Überprüfe die Verkabelung
Teste den Arduino mit dem Test-Skript



Entwicklung
Beiträge
Beiträge zum Projekt sind willkommen! Bitte folge diesen Schritten:

Fork des Repositories
Feature-Branch erstellen
Änderungen committen
Pull Request einreichen


Kontakt
Bei Fragen oder Anregungen stehe ich gerne zur Verfügung.

E-Mail: info €at) alexanderbehrensPungDcom
GitHub: https://github.com/alexanderbehrens1978/drehteller


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/funktioniert-03-03-2025 ---


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/.gitignore ---
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
myenv/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Flask
instance/
.webassets-cache

# Captured Images and Generated Files
static/photos/*
static/sample_images/*
!static/photos/.gitkeep
!static/sample_images/.gitkeep

# Environment
.env
.venv
env/
venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS specific
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/relais_test.ino ---
// relais_test.ino
void setup() {
  Serial.begin(9600);
  pinMode(8, OUTPUT);

  Serial.println("Relais-Test startet");
  digitalWrite(8, HIGH);  // Dauerhaft einschalten
  Serial.println("Relais sollte jetzt eingeschaltet sein");
}

void loop() {
  // Nichts hier, Relais bleibt eingeschaltet
}

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/install_pip_modules.sh ---
#!/bin/bash
# install_pip_modules.sh

# Farbcodes für Terminal-Ausgaben
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Drehteller 360° - Python Abhängigkeiten Installation${NC}"
echo "=============================================="

# Überprüfen, ob das Skript mit sudo ausgeführt wird
if [ "$EUID" -ne 0 ]
  then echo -e "${RED}Bitte führen Sie das Skript mit sudo aus.${NC}"
  echo "Beispiel: sudo bash install_pip_modules.sh"
  exit 1
fi

# Überprüfen, ob Python 3 installiert ist
if ! command -v python3 &> /dev/null
then
    echo -e "${RED}Python 3 ist nicht installiert. Bitte installieren Sie Python 3.${NC}"
    exit 1
fi

# Überprüfen, ob pip3 installiert ist
if ! command -v pip3 &> /dev/null
then
    echo -e "${YELLOW}pip3 ist nicht installiert. Versuche pip3 zu installieren...${NC}"
    apt-get update
    apt-get install -y python3-pip

    if ! command -v pip3 &> /dev/null
    then
        echo -e "${RED}Konnte pip3 nicht installieren. Bitte installieren Sie pip3 manuell.${NC}"
        exit 1
    fi
fi

echo -e "${GREEN}pip3 ist installiert. Aktualisiere pip...${NC}"
python3 -m pip install --upgrade pip

# Erstelle eine virtuelle Umgebung, wenn sie nicht existiert
if [ ! -d "myenv" ]; then
    echo -e "${YELLOW}Erstelle virtuelle Python-Umgebung 'myenv'...${NC}"
    python3 -m venv myenv
fi

# Aktiviere die virtuelle Umgebung
echo -e "${YELLOW}Aktiviere virtuelle Umgebung...${NC}"
source myenv/bin/activate

# Aktualisiere pip in der virtuellen Umgebung
echo -e "${YELLOW}Aktualisiere pip in der virtuellen Umgebung...${NC}"
pip install --upgrade pip setuptools wheel

# Installiere die benötigten Module
echo -e "${YELLOW}Installiere Python-Module...${NC}"

pip install flask==2.3.2
pip install werkzeug==2.3.6
pip install opencv-python-headless==4.7.0.72
pip install numpy==1.24.3
pip install pillow==9.5.0
pip install pyserial==3.5
pip install scipy==1.10.1
pip install pandas==2.0.1
pip install requests==2.30.0
pip install imageio==2.31.1

# Installiere zusätzliche Module
echo -e "${YELLOW}Installiere zusätzliche Python-Module...${NC}"
pip install python-dotenv
pip install gunicorn

# Erstelle die benötigten Verzeichnisse
echo -e "${YELLOW}Erstelle Verzeichnisstruktur...${NC}"
mkdir -p static/photos
mkdir -p static/sample_images
mkdir -p projects

# Generiere ein Platzhalter-Bild
echo -e "${YELLOW}Generiere Platzhalter-Bild...${NC}"
cat > generate_placeholder.py << 'EOL'
from PIL import Image, ImageDraw, ImageFont
import os

def generate_placeholder(output_path='static/placeholder.jpg', width=640, height=480):
    """
    Generiert ein Platzhalter-Bild mit Text

    :param output_path: Pfad zum Speichern des Bildes
    :param width: Bildbreite in Pixeln
    :param height: Bildhöhe in Pixeln
    """
    # Stelle sicher, dass der Zielordner existiert
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # Erstelle ein neues Bild mit grauem Hintergrund
    image = Image.new('RGB', (width, height), color=(240, 240, 240))
    draw = ImageDraw.Draw(image)

    # Zeichne Rahmen
    draw.rectangle((0, 0, width-1, height-1), outline=(200, 200, 200), width=2)

    # Füge Text hinzu
    try:
        # Versuche, einen Standardschriftsatz zu laden
        font = ImageFont.load_default()
    except IOError:
        # Fallback auf Standardschriftart
        font = ImageFont.load_default()

    text = "Kein Bild verfügbar"
    text_width = 200  # Ungefähre Textbreite
    text_position = ((width - text_width) // 2, height // 2 - 15)
    draw.text(text_position, text, fill=(100, 100, 100), font=font)

    # Speichere das Bild
    image.save(output_path)
    print(f"Platzhalter-Bild erstellt: {output_path}")

    return output_path

if __name__ == "__main__":
    generate_placeholder()
EOL

python generate_placeholder.py

# Benutzerrechte für Video-Geräte
echo -e "${YELLOW}Füge aktuellen Benutzer zur Video-Gruppe hinzu...${NC}"
usermod -a -G video $USER

# Bestätigungsnachricht
echo -e "${GREEN}Installation abgeschlossen!${NC}"
echo "Aktivieren Sie die virtuelle Umgebung mit: source myenv/bin/activate"
echo "Starten Sie die Anwendung mit: python web.py"

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/create_readme.sh ---
bashCopy#!/bin/bash
# create_readme.sh

cat > README.md << 'EOL'
# 360° Drehteller Fotografie-System

## Projektbeschreibung
Dieses Projekt ist ein vollständiges System zur Erstellung interaktiver 360°-Produktansichten mit einem Raspberry Pi, Arduino und einer Kamera. Es bietet eine responsive Weboberfläche zur Steuerung eines motorisierten Drehtellers, der eine Plattform über ein Schneckengetriebe dreht, während automatisch Fotos aufgenommen werden.

Die Anwendung ermöglicht es, professionelle 360°-Produktansichten zu erstellen, ähnlich denen, die in modernen E-Commerce-Plattformen verwendet werden.

## Funktionen

- **Motorgesteuerte Plattform**: Steuerung eines 220V/30W Drehtellers (0,8° pro Sekunde) über Arduino und Relais
- **Automatische Fotoaufnahme**: Unterstützung für Webcams und DSLR-Kameras (via gphoto2)
- **Responsive Benutzeroberfläche**: Funktioniert auf Desktop, Tablet und Smartphone
- **Projektverwaltung**: Organisiert verschiedene 360°-Produkt-Aufnahmen
- **Interaktiver 360°-Viewer**: Mit Auto-Rotation und Mouse/Touch Drag-Funktion
- **Konfigurierbare Einstellungen**: Einstellbare Schrittwinkel, Foto-Intervalle und Kamera-Auflösung

## Voraussetzungen

### Hardware
- Raspberry Pi 4 (mit Raspbian OS)
- Arduino Uno (R3 oder R4)
- Relais-Modul (für 220V/30W Drehmotor)
- Webcam oder DSLR-Kamera mit USB-Anschluss
- Schneckengetriebe-Drehteller (0,8° CW Drehgeschwindigkeit)

### Software
- Python 3.8+
- Flask
- OpenCV
- Arduino IDE oder Arduino CLI

## Installation

### Automatische Installation

Das Projekt enthält Skripte zur automatischen Installation und Einrichtung:

1. Klone das Repository:
```bash
git clone https://github.com/[USERNAME]/360-drehteller.git
cd 360-drehteller

Führe das Setup-Skript aus (dies richtet alles ein, inklusive Autostart):

bashCopysudo ./setup_and_autostart.sh
Das Skript erledigt:

Installation aller Abhängigkeiten
Einrichtung einer virtuellen Python-Umgebung
Erstellung des Autostart-Services
Konfiguration von Nginx (optional)
Erstellung der Verzeichnisstruktur


Übertrage den Arduino-Code:

bashCopy./upload_arduino_sketch.sh
Manuelle Installation
Alternativ kannst du die einzelnen Komponenten manuell installieren:

System-Abhängigkeiten:

bashCopysudo apt-get update
sudo apt-get install -y python3-venv python3-dev python3-pip python3-opencv fswebcam v4l-utils libatlas-base-dev git

Python-Umgebung:

bashCopypython3 -m venv myenv
source myenv/bin/activate
pip install -r requirements.txt

Arduino-Sketch übertragen (verwende die Arduino IDE oder unser Skript)

Verwendung
Weboberfläche starten
Die Anwendung ist über deinen Webbrowser erreichbar:

Wenn du Nginx eingerichtet hast: http://raspberry-pi-ip/
Ohne Nginx: http://raspberry-pi-ip:5000/

Dienst verwalten
Verwende das Hilfsskript zur Verwaltung des Dienstes:
bashCopy./drehteller.sh start    # Dienst starten
./drehteller.sh stop     # Dienst stoppen
./drehteller.sh restart  # Dienst neustarten
./drehteller.sh status   # Status anzeigen
./drehteller.sh logs     # Logs anzeigen
360° Aufnahme erstellen

Wähle auf der Startseite "360° Projekte verwalten"
Erstelle ein neues Projekt
Konfiguriere die Aufnahmeparameter (Drehwinkel, Intervall)
Starte die 360°-Aufnahme mit "Volle 360° Aufnahme"
Warte, bis die Aufnahme abgeschlossen ist
Öffne die 360°-Ansicht über "360° Ansicht"

Verzeichnisstruktur
Copy360-drehteller/
├── web.py                    # Flask-Hauptanwendung
├── project_manager.py        # Projektverwaltung
├── config_manager.py         # Konfigurationsverwaltung
├── git_uploader.py           # Git-Upload-Tool
├── upload_arduino_sketch.sh  # Arduino-Upload
├── setup_and_autostart.sh    # Automatische Einrichtung
├── drehteller.sh             # Dienstverwaltung
├── templates/                # HTML-Templates
├── static/                   # Statische Assets (CSS, JS, Bilder)
└── projects/                 # Projektdaten
Konfiguration
Die Anwendung kann über die Einstellungsseite im Webinterface konfiguriert werden:

Kameraeinstellungen: Pfad, Auflösung, Typ (Webcam/DSLR)
Arduino-Einstellungen: Port, Baudrate
Rotationseinstellungen: Standardwinkel, Intervall
Simulator-Modus: Für Tests ohne Hardware

Fehlerbehebung
Kamera wird nicht erkannt

Überprüfe die Verbindung zur Kamera
Führe v4l2-ctl --list-devices aus, um verfügbare Kameras zu sehen
Stelle sicher, dass der Benutzer in der video-Gruppe ist: sudo usermod -a -G video $USER

Arduino-Verbindung funktioniert nicht

Überprüfe den seriellen Port in den Einstellungen
Führe ls /dev/tty* aus, um verfügbare Ports zu sehen
Stelle sicher, dass der Benutzer in der dialout-Gruppe ist: sudo usermod -a -G dialout $USER

Drehteller bewegt sich nicht

Überprüfe die Verkabelung zum Relais
Teste das Relais mit dem Skript serial-test.py
Überprüfe die Arduino-Firmware mit dem Arduino IDE Serial Monitor

Weiterentwicklung
Code-Struktur
Die Anwendung verwendet einen modularen Ansatz mit separaten Komponenten für:

Web-Interface (Flask)
Projektverwaltung
Kamerafunktionen
Arduino-Steuerung
360°-Viewer

Jedes Modul ist auf maximal 60 Zeilen Code begrenzt, um Clean Code-Prinzipien zu folgen.
Mögliche Erweiterungen

Integration von Bildbearbeitung für bessere Produktdarstellung
Zusätzliche Beleuchtungssteuerung
Automatische Hintergrundentfernung
Export in verschiedene 360°-Viewer-Formate

Mitwirkende und Lizenz
Dieses Projekt steht unter MIT-Lizenz. Beiträge und Verbesserungen sind willkommen.
Entwickelt von [DEIN NAME]

Bei Fragen oder Problemen öffne ein Issue im GitHub-Repository oder kontaktiere den Entwickler direkt.
EOL
echo "README.md erfolgreich erstellt!"


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/webcam_simulator.py ---
import cv2
import os
import time
import random
import subprocess
import warnings
from datetime import datetime

from webcam_detection_helper import find_working_webcam, test_webcam_capture


class WebcamCaptureSimulator:
    def __init__(self, base_path='static/photos', sample_images_path='static/sample_images'):
        """
        Initialize webcam capture simulator

        :param base_path: Directory to save captured photos
        :param sample_images_path: Directory containing sample images to use
        """
        self.base_path = base_path
        self.sample_images_path = sample_images_path

        # Ensure base and sample image directories exist
        os.makedirs(base_path, exist_ok=True)
        os.makedirs(sample_images_path, exist_ok=True)

        # Find the best webcam device
        self.camera_device = self._find_best_camera_device()

    def _find_best_camera_device(self, preferred_devices=None):
        """
        Find the best camera device to use

        :param preferred_devices: Optional list of preferred device paths
        :return: Best working device path
        """
        # If specific devices are known, try those first
        if preferred_devices is None:
            preferred_devices = ['/dev/video0', '/dev/video1']

        # Find a working webcam
        return find_working_webcam(preferred_devices)

    def capture_photo(self, filename=None):
        """
        Capture a photo - either from a real webcam or simulate with a sample image

        :param filename: Optional custom filename
        :return: Path to the saved image
        """
        # Ensure the base path exists
        os.makedirs(self.base_path, exist_ok=True)

        # If no filename provided, generate a unique one
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'webcam_photo_{timestamp}.jpg'

        # Ensure filename is just the basename
        filename = os.path.basename(filename)

        # Full path for the new image
        full_path = os.path.join(self.base_path, filename)

        # Try to capture from the detected camera device
        if self.camera_device:
            try:
                success, captured_path = test_webcam_capture(self.camera_device)
                if success:
                    # Copy the captured image to the desired filename
                    import shutil
                    shutil.copy(captured_path, full_path)
                    return full_path
            except Exception as e:
                print(f"Camera capture error: {e}")

        # Fallback to sample image simulation
        sample_images = [
            f for f in os.listdir(self.sample_images_path)
            if f.lower().endswith(('.png', '.jpg', '.jpeg'))
        ]

        if sample_images:
            # Randomly select a sample image
            selected_sample = random.choice(sample_images)
            sample_path = os.path.join(self.sample_images_path, selected_sample)

            # Copy the sample image to the photos directory
            import shutil
            shutil.copy(sample_path, full_path)
            return full_path

        # Last resort - create a blank image
        import numpy as np
        blank_image = np.zeros((480, 640, 3), dtype=np.uint8)
        cv2.putText(blank_image, "No Image Available", (50, 250),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
        cv2.imwrite(full_path, blank_image)
        return full_path

    def list_photos(self):
        """
        List all photos in the base path

        :return: List of photo filenames
        """
        return [f for f in os.listdir(self.base_path)
                if f.lower().endswith(('.png', '.jpg', '.jpeg'))]


# Standalone usage example
if __name__ == '__main__':
    # Initialize the webcam capture simulator
    webcam_simulator = WebcamCaptureSimulator()

    # Capture 5 photos
    for i in range(5):
        captured_image = webcam_simulator.capture_photo()
        print(f"Captured image: {captured_image}")

    # List captured images
    print("\nCaptured Images:")
    for photo in webcam_simulator.list_photos():
        print(photo)


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/device_detector.py ---


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/viewer_generator.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modul zur Generierung des 360°-Viewers aus einer Serie von Bildern.
Bereitet Bilder auf und erstellt HTML/JavaScript für den interaktiven Viewer.
"""

import os
import json
import shutil
import logging
import time
from datetime import datetime
from PIL import Image

# Logger konfigurieren
logger = logging.getLogger("drehteller360.viewer_generator")


class ViewerGenerator:
    """Generiert einen interaktiven 360°-Viewer aus einer Serie von Bildern."""

    def __init__(self, photo_dir='static/photos', output_dir='static/projects'):
        """
        Initialisiert den Viewer-Generator.

        Args:
            photo_dir: Verzeichnis mit den Quellfotos
            output_dir: Ausgabeverzeichnis für generierte Projekte
        """
        self.photo_dir = photo_dir
        self.output_dir = output_dir

        # Stelle sicher, dass das Ausgabeverzeichnis existiert
        os.makedirs(output_dir, exist_ok=True)

    def prepare_images(self, images, project_name):
        """
        Bereitet Bilder für den 360°-Viewer vor (Größenanpassung, Optimierung).

        Args:
            images: Liste der Bildpfade
            project_name: Name des Projekts

        Returns:
            Pfad zum Projektverzeichnis
        """
        project_dir = os.path.join(self.output_dir, project_name)
        os.makedirs(project_dir, exist_ok=True)

        processed_images = []

        for i, img_path in enumerate(images):
            try:
                # Lade Bild
                img = Image.open(os.path.join(self.photo_dir, img_path))

                # Passe Größe an (max. 1200px Breite für optimale Performance)
                max_width = 1200
                if img.width > max_width:
                    ratio = max_width / img.width
                    new_height = int(img.height * ratio)
                    img = img.resize((max_width, new_height), Image.LANCZOS)

                # Speichere optimiertes Bild
                img_filename = f"image_{i:03d}.jpg"
                output_path = os.path.join(project_dir, img_filename)
                img.save(output_path, "JPEG", quality=85, optimize=True)

                processed_images.append(img_filename)
            except Exception as e:
                logger.error(f"Fehler bei der Bildverarbeitung für {img_path}: {e}")

        return project_dir, processed_images

    def generate_viewer(self, images, metadata=None):
        """
        Generiert einen 360°-Viewer aus den gegebenen Bildern.

        Args:
            images: Liste der Bildpfade
            metadata: Zusätzliche Metadaten für das Projekt

        Returns:
            URL zum erstellten Viewer
        """
        if not images:
            logger.error("Keine Bilder zum Generieren des Viewers gefunden")
            return None

        # Projektname erstellen (Zeitstempel)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        project_name = f"project_{timestamp}"

        # Bilder vorbereiten
        project_dir, processed_images = self.prepare_images(images, project_name)

        # Erstelle Projektmetadaten
        project_metadata = {
            "name": project_name,
            "created": time.time(),
            "image_count": len(processed_images),
            "images": processed_images,
            "user_metadata": metadata or {}
        }

        # Speichere Metadaten
        metadata_path = os.path.join(project_dir, "metadata.json")
        with open(metadata_path, "w") as f:
            json.dump(project_metadata, f)

        return f"/viewer?project={project_name}"


# Globale Instanz für die Anwendung
viewer_generator = ViewerGenerator()

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/test_relais.py ---
import serial
import time

try:
    arduino = serial.Serial('/dev/ttyACM0', 9600, timeout=1)
    time.sleep(5)  # Wartezeit für die Initialisierung
    print("Arduino verbunden!")
    arduino.write(b'1')  # Relais einschalten
    time.sleep(5)
    arduino.write(b'0')  # Relais ausschalten
except Exception as e:
    print(f"Fehler: {e}")


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/git_uploader.py ---
# git_uploader.py
import os
import subprocess
import argparse
from datetime import datetime


def check_git_installed():
    """Überprüft, ob Git installiert ist"""
    try:
        subprocess.run(['git', '--version'], check=True, stdout=subprocess.PIPE)
        return True
    except (subprocess.SubprocessError, FileNotFoundError):
        return False


def init_git_repo(repo_path='.'):
    """Initialisiert ein Git-Repository, falls noch nicht vorhanden"""
    if not os.path.exists(os.path.join(repo_path, '.git')):
        subprocess.run(['git', 'init'], cwd=repo_path, check=True)
        print(f"Git-Repository in {os.path.abspath(repo_path)} initialisiert")
    else:
        print("Git-Repository bereits vorhanden")


def add_remote(repo_path='.', remote_url=None):
    """Fügt eine Remote-URL hinzu, falls noch nicht vorhanden"""
    if not remote_url:
        remote_url = input("Bitte gib die Git-Repository-URL ein: ")

    try:
        # Prüfe, ob origin bereits existiert
        result = subprocess.run(
            ['git', 'remote', 'get-url', 'origin'],
            cwd=repo_path,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        if result.returncode == 0:
            print(f"Remote 'origin' bereits konfiguriert: {result.stdout.decode().strip()}")
            change = input("Möchtest du die Remote-URL ändern? (j/n): ")
            if change.lower() == 'j':
                subprocess.run(['git', 'remote', 'set-url', 'origin', remote_url], cwd=repo_path, check=True)
                print(f"Remote-URL geändert zu: {remote_url}")
        else:
            subprocess.run(['git', 'remote', 'add', 'origin', remote_url], cwd=repo_path, check=True)
            print(f"Remote 'origin' hinzugefügt: {remote_url}")
    except subprocess.SubprocessError as e:
        print(f"Fehler beim Konfigurieren der Remote-URL: {e}")


def commit_changes(repo_path='.', message=None):
    """Fügt Änderungen hinzu und erstellt einen Commit"""
    if not message:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        message = f"Automatischer Commit vom {timestamp}"

    # Füge alle Änderungen hinzu
    subprocess.run(['git', 'add', '.'], cwd=repo_path, check=True)

    # Erstelle einen Commit
    subprocess.run(['git', 'commit', '-m', message], cwd=repo_path, check=True)
    print(f"Änderungen committed mit Nachricht: '{message}'")


def push_to_remote(repo_path='.', branch='main'):
    """Pusht Änderungen zum Remote-Repository"""
    try:
        subprocess.run(['git', 'push', '-u', 'origin', branch], cwd=repo_path, check=True)
        print(f"Änderungen erfolgreich zu 'origin/{branch}' gepusht")
    except subprocess.SubprocessError as e:
        print(f"Fehler beim Pushen: {e}")
        print("Versuche es mit 'master' statt 'main'...")
        try:
            subprocess.run(['git', 'push', '-u', 'origin', 'master'], cwd=repo_path, check=True)
            print("Änderungen erfolgreich zu 'origin/master' gepusht")
        except subprocess.SubprocessError as e2:
            print(f"Fehler beim Pushen zu 'master': {e2}")
            print("Bitte überprüfe deine Git-Konfiguration und Berechtigungen")


def create_gitignore(repo_path='.'):
    """Erstellt eine .gitignore Datei mit sinnvollen Einträgen"""
    gitignore_content = """
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
myenv/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Flask
instance/
.webassets-cache

# Captured Images and Generated Files
static/photos/*
static/sample_images/*
!static/photos/.gitkeep
!static/sample_images/.gitkeep

# Environment
.env
.venv
env/
venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS specific
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
"""

    gitignore_path = os.path.join(repo_path, '.gitignore')

    # Nur erstellen, wenn noch nicht vorhanden
    if not os.path.exists(gitignore_path):
        with open(gitignore_path, 'w') as f:
            f.write(gitignore_content.strip())
        print(".gitignore Datei erstellt")
    else:
        print(".gitignore Datei bereits vorhanden")


def main():
    parser = argparse.ArgumentParser(description='Git-Upload für Drehteller-Projekt')
    parser.add_argument('--path', help='Pfad zum Repository', default='.')
    parser.add_argument('--remote', help='Git-Remote-URL')
    parser.add_argument('--message', help='Commit-Nachricht')
    parser.add_argument('--branch', help='Branch zum Pushen', default='main')
    args = parser.parse_args()

    if not check_git_installed():
        print("Git ist nicht installiert. Bitte installiere Git zuerst.")
        return

    # Verzeichnisstruktur sicherstellen
    for directory in ['static/photos', 'static/sample_images']:
        os.makedirs(os.path.join(args.path, directory), exist_ok=True)
        # Leere .gitkeep Dateien erstellen, damit Git leere Verzeichnisse beibehält
        with open(os.path.join(args.path, directory, '.gitkeep'), 'w') as f:
            pass

    init_git_repo(args.path)
    create_gitignore(args.path)
    add_remote(args.path, args.remote)

    try:
        commit_changes(args.path, args.message)
        push_to_remote(args.path, args.branch)
        print("Git-Upload erfolgreich abgeschlossen!")
    except subprocess.SubprocessError as e:
        print(f"Fehler beim Git-Upload: {e}")


if __name__ == "__main__":
    main()

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/webcam_detection_helper.py ---
import cv2
import os
import time
import subprocess
import warnings


def find_working_webcam(preferred_devices=None):
    """
    Find a working webcam device

    :param preferred_devices: List of device paths to try first
    :return: Working device path or None
    """
    # Prioritize video0 for Microsoft LifeCam HD-5000
    if preferred_devices is None:
        preferred_devices = ['/dev/video0', '/dev/video1']

    # First, try fswebcam to check device functionality
    for device in preferred_devices:
        try:
            # Use subprocess to run fswebcam test
            result = subprocess.run([
                'fswebcam',
                '-d', device,
                '--no-banner',
                '/dev/null'  # Discard output
            ], capture_output=True, text=True, timeout=3)

            # If fswebcam succeeds, return this device
            if result.returncode == 0:
                return device
        except subprocess.TimeoutExpired:
            continue
        except Exception:
            continue

    # Fallback to OpenCV detection
    for device in preferred_devices:
        try:
            # Try OpenCV capture
            cap = cv2.VideoCapture(device)
            ret, frame = cap.read()
            if ret and frame is not None and frame.size > 0:
                cap.release()
                return device
            cap.release()
        except Exception:
            pass

    # Comprehensive search if all else fails
    try:
        # Use v4l2-ctl to list all video devices
        result = subprocess.run(['v4l2-ctl', '--list-devices'],
                                capture_output=True,
                                text=True)

        # Extract all /dev/video* devices
        devices = [
            line.strip()
            for line in result.stdout.split('\n')
            if line.startswith('/dev/video')
        ]

        # Try each discovered device
        for device in devices:
            try:
                # Try fswebcam first
                result = subprocess.run([
                    'fswebcam',
                    '-d', device,
                    '--no-banner',
                    '/dev/null'
                ], capture_output=True, text=True, timeout=3)

                if result.returncode == 0:
                    return device

                # Fallback to OpenCV
                cap = cv2.VideoCapture(device)
                ret, frame = cap.read()
                if ret and frame is not None and frame.size > 0:
                    cap.release()
                    return device
                cap.release()
            except Exception:
                continue
    except Exception:
        pass

    return None


def get_camera_capabilities(device_path):
    """
    Retrieve camera capabilities

    :param device_path: Path to the video device
    :return: Dictionary of camera capabilities
    """
    capabilities = {
        'supported_resolutions': [],
        'max_width': 0,
        'max_height': 0
    }

    try:
        # Use v4l2-ctl to get detailed device information
        result = subprocess.run([
            'v4l2-ctl',
            '-d', device_path,
            '--list-formats-ext'
        ], capture_output=True, text=True, timeout=3)

        # Parse output to extract resolutions
        resolutions = []
        for line in result.stdout.split('\n'):
            if 'Size' in line:
                try:
                    # Extract resolution like '640x480'
                    resolution = line.split(':')[-1].strip()
                    width, height = map(int, resolution.split('x'))
                    resolutions.append((width, height))

                    # Track max resolution
                    capabilities['max_width'] = max(capabilities['max_width'], width)
                    capabilities['max_height'] = max(capabilities['max_height'], height)
                except Exception:
                    pass

        capabilities['supported_resolutions'] = sorted(set(resolutions))
    except Exception as e:
        print(f"Error getting camera capabilities: {e}")

    return capabilities


def test_webcam_capture(device_path, width=None, height=None):
    """
    Attempt to capture an image from the specified device with optional resolution

    :param device_path: Path to the video device
    :param width: Optional desired width
    :param height: Optional desired height
    :return: Tuple (success, captured_image_path)
    """
    try:
        # Ensure output directory exists
        os.makedirs('static/photos', exist_ok=True)

        # Generate unique filename
        filename = f'webcam_test_{int(time.time())}.jpg'
        full_path = os.path.join('static/photos', filename)

        # Prepare fswebcam command
        cmd = ['fswebcam',
               '-d', device_path,
               '--no-banner']

        # Add resolution if specified
        if width and height:
            cmd.extend(['-r', f'{width}x{height}'])

        cmd.append(full_path)

        # Try fswebcam first
        subprocess.run(cmd, check=True, timeout=5)

        # Verify file was created
        if os.path.exists(full_path) and os.path.getsize(full_path) > 0:
            return True, full_path

        # Fallback to OpenCV with resolution
        cap = cv2.VideoCapture(device_path)

        # Set resolution if specified
        if width and height:
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)

        ret, frame = cap.read()
        if ret:
            cv2.imwrite(full_path, frame)
            cap.release()
            return True, full_path
        cap.release()

        return False, None

    except subprocess.TimeoutExpired:
        print(f"Timeout capturing from {device_path}")
        return False, None
    except Exception as e:
        print(f"Webcam capture error: {e}")
        return False, None


# Standalone usage example
if __name__ == '__main__':
    # Find a working webcam
    working_device = find_working_webcam()

    if working_device:
        print(f"Found working webcam at: {working_device}")

        # Get camera capabilities
        capabilities = get_camera_capabilities(working_device)
        print("\nCamera Capabilities:")
        print(f"Supported Resolutions: {capabilities['supported_resolutions']}")
        print(f"Max Resolution: {capabilities['max_width']}x{capabilities['max_height']}")

        # Try capturing at a specific resolution
        success, image_path = test_webcam_capture(working_device, 1280, 720)

        if success:
            print(f"\nTest image captured: {image_path}")
        else:
            print("\nFailed to capture test image")
    else:
        print("No working webcam found")


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/main.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Hauptanwendungseinstiegspunkt für die 360° Drehteller-Steuerung.
Startet den Webserver und initialisiert alle benötigten Komponenten.
"""

import os
import sys
import logging
from threading import Thread

# Stelle sicher, dass wir im richtigen Verzeichnis sind
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

# Initialisiere Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("drehteller360.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("drehteller360")

# Stelle sicher, dass die benötigten Verzeichnisse existieren
os.makedirs('static/photos', exist_ok=True)
os.makedirs('static/sample_images', exist_ok=True)
os.makedirs('static/projects', exist_ok=True)

# Importiere erst nach Verzeichnissetup
from web import app
from device_detector import DeviceDetector
from config_manager import config_manager


def check_dependencies():
    """Überprüft, ob alle erforderlichen Abhängigkeiten installiert sind."""
    try:
        import flask
        import cv2
        import serial
        import numpy
        logger.info("Alle erforderlichen Python-Pakete sind installiert.")
        return True
    except ImportError as e:
        logger.error(f"Fehlende Abhängigkeit: {e}")
        print(f"Fehler: {e}. Bitte führen Sie 'pip install -r requirements.txt' aus.")
        return False


if __name__ == "__main__":
    logger.info("Starte 360° Drehteller-Steuerung...")

    if not check_dependencies():
        sys.exit(1)

    # Initialisiere Gerätedetektor im Hintergrund
    device_detector = DeviceDetector()
    detection_thread = Thread(target=device_detector.start_detection, daemon=True)
    detection_thread.start()

    # Starte den Flask-Server
    host = config_manager.get('web.host', '0.0.0.0')
    port = config_manager.get('web.port', 5000)
    debug = config_manager.get('web.debug', True)

    logger.info(f"Webserver wird gestartet auf {host}:{port}")
    app.run(host=host, port=port, debug=debug)

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/web.py ---
from flask import Flask, render_template, request, send_from_directory, jsonify
import os
import json
import time
import serial
import subprocess

# Import config manager
from config_manager import config_manager

# Import the webcam capture simulator
from webcam_simulator import WebcamCaptureSimulator
from sample_images_generator import SampleImagesGenerator
from webcam_detection_helper import find_working_webcam, get_camera_capabilities, test_webcam_capture
from device_detector import device_detector
from viewer_generator import viewer_generator

app = Flask(__name__)

# Configuration retrieval
USE_SIMULATOR = config_manager.get('simulator.enabled', True)

# Initialize webcam capture simulator
webcam_simulator = WebcamCaptureSimulator()

# Initialize sample images generator (optional, run once to generate images)
if not os.path.exists('static/sample_images') or len(os.listdir('static/sample_images')) < 5:
    image_generator = SampleImagesGenerator()
    image_generator.generate_sample_images(10)

# Arduino connection
def get_arduino_connection():
    """
    Establish Arduino connection based on configuration
    """
    try:
        if USE_SIMULATOR:
            return None
        
        port = config_manager.get('arduino.port', '/dev/ttyACM0')
        baudrate = config_manager.get('arduino.baudrate', 9600)
        
        arduino = serial.Serial(port, baudrate, timeout=1)
        time.sleep(2)  # Wait for initialization
        return arduino
    except Exception as e:
        print(f"Arduino connection error: {e}")
        return None

# Global Arduino connection
arduino = get_arduino_connection()

def rotate_teller(degrees):
    """
    Rotate the platform
    
    :param degrees: Rotation angle
    """
    if USE_SIMULATOR:
        print(f"Simulated rotation: {degrees} degrees")
        return
    
    if arduino is None:
        print("Arduino not connected!")
        return
    
    # Berechnung der Drehzeit basierend auf der Gradzahl (0,8 Grad pro Sekunde)
    rotation_time = degrees / 0.8
    
    # Relais einschalten (Drehteller starten)
    arduino.write(b'1')  # '1' senden, um das Relais einzuschalten
    time.sleep(rotation_time)  # Warte für die berechnete Zeit
    arduino.write(b'0')  # '0' senden, um das Relais auszuschalten
    print(f"Drehteller um {degrees} Grad gedreht.")

def take_photo(filename=None):
    """
    Capture a photo
    
    :param filename: Optional custom filename
    :return: Path to the saved photo
    """
    if USE_SIMULATOR:
        # Use the webcam simulator to generate a photo
        # Ensure filename is just the basename
        if filename:
            filename = os.path.basename(filename)
        return webcam_simulator.capture_photo(filename)
    
    try:
        # Camera device path and resolution from configuration
        camera_device = config_manager.get('camera.device_path', '/dev/video0')
        camera_type = config_manager.get('camera.type', 'webcam')
        
        # Get camera resolution
        camera_width = config_manager.get('camera.resolution.width')
        camera_height = config_manager.get('camera.resolution.height')
        
        # Use actual webcam capture for real hardware
        if not filename:
            filename = f'photo_{int(time.time())}.jpg'
        
        # Ensure filename is just the basename
        filename = os.path.basename(filename)
        full_path = os.path.join('static/photos', filename)
        
        # Choose capture method based on camera type
        if camera_type == 'gphoto2':
            # Use gphoto2 for DSLR cameras
            subprocess.call(['gphoto2', '--capture-image-and-download', '--filename', full_path])
        else:
            # Default to OpenCV for webcams
            import cv2
            cap = cv2.VideoCapture(camera_device)
            
            # Set resolution if specified
            if camera_width and camera_height:
                cap.set(cv2.CAP_PROP_FRAME_WIDTH, camera_width)
                cap.set(cv2.CAP_PROP_FRAME_HEIGHT, camera_height)
            
            ret, frame = cap.read()
            if ret:
                cv2.imwrite(full_path, frame)
                cap.release()
            else:
                # Fallback to fswebcam if OpenCV fails
                subprocess.call(['fswebcam', '--no-banner', 
                                 '-d', camera_device, 
                                 full_path])
        
        print(f"Foto aufgenommen und als {filename} gespeichert.")
        return filename
    except Exception as e:
        print(f"Fehler beim Aufnehmen des Fotos: {e}")
        return None

@app.route('/generate_sample_images', methods=['POST'])
def generate_sample_images():
    """
    Generate sample images for the simulator
    """
    try:
        # Ensure sample images directory exists
        os.makedirs('static/sample_images', exist_ok=True)
        
        # Generate sample images
        image_generator = SampleImagesGenerator()
        generated_images = image_generator.generate_sample_images(10)
        
        return jsonify({
            "status": "success", 
            "message": f"{len(generated_images)} sample images generated",
            "images": generated_images
        })
    except Exception as e:
        print(f"Error generating sample images: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

@app.route('/test_webcam_simulator', methods=['POST'])
def test_webcam_simulator():
    """
    Test the webcam simulator by capturing a sample image
    """
    try:
        # Ensure photos directory exists
        os.makedirs('static/photos', exist_ok=True)
        
        # Capture a test photo using the simulator
        photo_path = webcam_simulator.capture_photo('test_simulator.jpg')
        
        # Return the photo path relative to static folder
        return photo_path.replace('static/', '/static/')
    except Exception as e:
        print(f"Error testing webcam simulator: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

@app.route('/camera_capabilities', methods=['GET'])
def camera_capabilities():
    """
    Get camera device capabilities
    """
    try:
        # Get camera device from configuration
        camera_device = config_manager.get('camera.device_path', '/dev/video0')
        
        # Get camera capabilities
        capabilities = get_camera_capabilities(camera_device)
        
        return jsonify({
            "status": "success",
            "capabilities": capabilities
        })
    except Exception as e:
        print(f"Error getting camera capabilities: {e}")
        return jsonify({
            "status": "error", 
            "message": str(e)
        }), 500

# Routes
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/settings')
def settings():
    return render_template('settings.html')

@app.route('/viewer')
def view_360():
    """Zeigt den 360°-Viewer an."""
    return render_template('viewer.html')

@app.route('/projects')
def projects_page():
    """Zeigt die Projektverwaltungsseite an."""
    return render_template('projects.html')

@app.route('/get_config')
def get_config():
    """
    Retrieve current configuration
    """
    return jsonify(config_manager.config)

@app.route('/save_config', methods=['POST'])
def save_config():
    """
    Save new configuration
    """
    try:
        # Prüfen, ob JSON-Daten empfangen wurden
        if not request.is_json:
            return jsonify({
                "status": "error", 
                "message": "Keine JSON-Daten empfangen. Content-Type muss application/json sein."
            }), 400
        
        # JSON-Daten abrufen
        new_config = request.json
        
        if not new_config:
            return jsonify({
                "status": "error", 
                "message": "Leere Konfigurationsdaten empfangen"
            }), 400
        
        # Konfigurationsdaten ausgeben für Debugging
        print("Empfangene Konfiguration:", json.dumps(new_config, indent=2))
        
        # Versuchen, die Konfiguration zu speichern
        try:
            # Konfiguration mit bestehender Konfiguration zusammenführen
            # (Direkte Implementierung ohne die fehlende _merge_configs-Methode)
            merged_config = {}
            
            # Erst die bestehende Konfiguration kopieren
            for key, value in config_manager.config.items():
                merged_config[key] = value
                
            # Dann die neue Konfiguration einarbeiten (rekursiv)
            def recursive_update(target, source):
                for key, value in source.items():
                    if isinstance(value, dict) and key in target and isinstance(target[key], dict):
                        recursive_update(target[key], value)
                    else:
                        target[key] = value
            
            recursive_update(merged_config, new_config)
            
            # Aktualisierte Konfiguration speichern
            config_manager.config = merged_config
            
            # In Datei speichern
            with open(config_manager.config_path, 'w') as f:
                json.dump(merged_config, f, indent=4)
                
            print(f"Konfiguration gespeichert in: {config_manager.config_path}")
            return jsonify({"status": "success"})
        except Exception as config_error:
            print(f"Fehler beim Speichern der Konfiguration: {config_error}")
            return jsonify({
                "status": "error", 
                "message": f"Fehler beim Speichern: {str(config_error)}"
            }), 500
            
    except Exception as e:
        print(f"Allgemeiner Fehler beim Speichern der Konfiguration: {e}")
        return jsonify({
            "status": "error", 
            "message": f"Allgemeiner Fehler: {str(e)}"
        }), 500

@app.route('/api/project/<project_id>')
def get_project(project_id):
    """Liefert Projektdaten für den 360°-Viewer."""
    try:
        project_dir = os.path.join('static/projects', project_id)
        metadata_path = os.path.join(project_dir, 'metadata.json')
        
        if not os.path.exists(metadata_path):
            return jsonify({"error": "Projekt nicht gefunden"}), 404
        
        with open(metadata_path, 'r') as f:
            metadata = json.load(f)
        
        return jsonify(metadata)
    except Exception as e:
        print(f"Fehler beim Laden der Projektdaten: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/projects')
def get_projects():
    """Liefert eine Liste aller verfügbaren Projekte."""
    try:
        projects_dir = 'static/projects'
        projects = []
        
        # Verzeichnisse durchsuchen
        for project_id in os.listdir(projects_dir):
            project_path = os.path.join(projects_dir, project_id)
            
            # Nur Verzeichnisse berücksichtigen
            if os.path.isdir(project_path):
                metadata_path = os.path.join(project_path, 'metadata.json')
                
                # Prüfen, ob Metadaten existieren
                if os.path.exists(metadata_path):
                    with open(metadata_path, 'r') as f:
                        metadata = json.load(f)
                        
                    # Projekt-ID hinzufügen
                    metadata['id'] = project_id
                    projects.append(metadata)
                else:
                    # Fallback, wenn keine Metadaten existieren
                    images = [f for f in os.listdir(project_path) 
                             if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
                    projects.append({
                        'id': project_id,
                        'name': f"Projekt {project_id}",
                        'created': os.path.getctime(project_path),
                        'images': images,
                        'image_count': len(images)
                    })
        
        return jsonify(projects)
    except Exception as e:
        print(f"Fehler beim Laden der Projekte: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/project/<project_id>', methods=['DELETE'])
def delete_project(project_id):
    """Löscht ein Projekt."""
    try:
        project_dir = os.path.join('static/projects', project_id)
        
        if not os.path.exists(project_dir):
            return jsonify({"error": "Projekt nicht gefunden"}), 404
        
        import shutil
        shutil.rmtree(project_dir)
        
        return jsonify({"status": "success"})
    except Exception as e:
        print(f"Fehler beim Löschen des Projekts: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/devices')
def get_devices():
    """Liefert eine Liste aller erkannten Geräte."""
    return jsonify(device_detector.get_devices())

@app.route('/generate_360', methods=['POST'])
def generate_360():
    """Generiert einen 360°-Viewer aus den aufgenommenen Bildern."""
    try:
        # Liste der Fotos nach Zeitstempel sortieren
        photo_dir = 'static/photos'
        photos = sorted([f for f in os.listdir(photo_dir) 
                        if f.lower().endswith(('.jpg', '.jpeg', '.png'))])
        
        if not photos:
            return jsonify({"error": "Keine Fotos gefunden"}), 400
        
        # Optionale Metadaten aus der Anfrage
        metadata = request.get_json() if request.is_json else {}
        
        # 360°-Viewer generieren
        viewer_url = viewer_generator.generate_viewer(photos, metadata)
        
        if viewer_url:
            return jsonify({"status": "success", "url": viewer_url})
        else:
            return jsonify({"error": "Fehler beim Generieren des Viewers"}), 500
    except Exception as e:
        print(f"Fehler beim Generieren des 360°-Viewers: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/rotate', methods=['POST'])
def rotate():
    degrees = int(request.form['degrees'])
    interval = float(request.form.get('interval', 5))  # Default 5 seconds if not specified
    
    # Rotate platform
    rotate_teller(degrees)
    
    # Capture photo with timestamp to prevent caching
    filename = f'photo_{int(time.time())}_{degrees}.jpg'
    photo_path = take_photo(filename)
    
    # Return photo name relative to static folder
    if photo_path:
        return f'/static/photos/{os.path.basename(photo_path)}'
    else:
        return 'Error capturing photo', 500

@app.route('/static/photos/<filename>')
def serve_photo(filename):
    return send_from_directory('static/photos', filename)

if __name__ == '__main__':
    # Ensure static directories exist
    os.makedirs('static/photos', exist_ok=True)
    os.makedirs('static/sample_images', exist_ok=True)
    os.makedirs('static/projects', exist_ok=True)
    
    # Run the Flask app
    app.run(host='0.0.0.0', port=5000, debug=True)


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/drehteller360.log ---


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/install_dependencies.sh ---
#!/bin/bash

# Ensure script is run with bash
if [ -z "$BASH_VERSION" ]
then
    echo "Please run with bash"
    exit 1
fi

# Check for Python 3 and pip
if ! command -v python3 &> /dev/null
then
    echo "Python 3 is not installed. Please install Python 3."
    exit 1
fi

if ! command -v pip3 &> /dev/null
then
    echo "pip3 is not installed. Installing pip..."
    sudo apt-get update
    sudo apt-get install -y python3-pip
fi

# System dependencies
echo "Installing system dependencies..."
sudo apt-get update
sudo apt-get install -y \
    python3-dev \
    python3-opencv \
    fswebcam \
    v4l-utils \
    libatlas-base-dev \
    libhdf5-dev \
    libhdf5-serial-dev \
    libjpeg-dev \
    libpng-dev \
    libtiff-dev \
    libv4l-dev \
    libxvidcore-dev \
    libx264-dev \
    gfortran \
    openexr \
    libopenexr-dev \
    libgstreamer1.0-dev \
    libgstreamer-plugins-base1.0-dev

# Create virtual environment
echo "Creating virtual environment..."
python3 -m venv myenv

# Activate virtual environment
source myenv/bin/activate

# Upgrade pip
pip install --upgrade pip setuptools wheel

# Install Python dependencies
echo "Installing Python dependencies..."
pip install -r requirements.txt

# Additional webcam and camera utilities
pip install v4l2

# Permissions for video devices
echo "Adding user to video group..."
sudo usermod -a -G video $USER

# Finished
echo "Installation complete!"
echo "Activate the virtual environment with: source myenv/bin/activate"


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/requirements.txt ---
# Webframework
flask>=2.3.3
werkzeug>=2.3.8
jinja2>=3.1.3

# Serielle Kommunikation
pyserial>=3.5

# Bildverarbeitung
opencv-python-headless>=4.8.1
numpy>=1.26.0
pillow>=10.2.0

# Wissenschaftliche Berechnungen
scipy>=1.12.0

# Datenverarbeitung
pandas>=2.2.0

# Netzwerk und Requests
requests>=2.31.0

# Bildverarbeitung
imageio>=2.33.0

# Zusätzliche Utilities
python-dotenv>=1.0.0
gunicorn>=22.0.0

# Webcam und Kamera-Unterstützung
v4l2-python3>=0.3.2

# Optional: für erweiterte Bildverarbeitung
scikit-image>=0.22.0

# Optional: für Videoaufnahme
opencv-python>=4.8.1


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/project_manager.py ---
# project_manager.py
import os
import json
import time
import shutil
from datetime import datetime


class ProjectManager:
    def __init__(self, base_path='projects'):
        """
        Verwaltet 360°-Projekte

        :param base_path: Basisverzeichnis für Projekte
        """
        self.base_path = base_path

        # Stelle sicher, dass das Projektverzeichnis existiert
        os.makedirs(base_path, exist_ok=True)

    def create_project(self, name, description=None):
        """
        Erstellt ein neues Projekt

        :param name: Projektname
        :param description: Projektbeschreibung (optional)
        :return: Projektverzeichnis
        """
        # Erzeuge einen sicheren Verzeichnisnamen aus dem Projektnamen
        safe_name = "".join([c if c.isalnum() else "_" for c in name])
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        project_dir = f"{safe_name}_{timestamp}"

        # Erstelle Projektverzeichnis und Unterordner
        project_path = os.path.join(self.base_path, project_dir)
        os.makedirs(project_path, exist_ok=True)
        os.makedirs(os.path.join(project_path, 'images'), exist_ok=True)

        # Erstelle Projektmetadaten
        metadata = {
            'name': name,
            'description': description,
            'created': datetime.now().isoformat(),
            'last_modified': datetime.now().isoformat(),
            'image_count': 0,
            'rotation_settings': {
                'degrees_per_step': 15,
                'interval_seconds': 5
            }
        }

        # Speichere Metadaten
        with open(os.path.join(project_path, 'metadata.json'), 'w') as f:
            json.dump(metadata, f, indent=4)

        return project_path

    def get_projects(self):
        """
        Gibt alle verfügbaren Projekte zurück

        :return: Liste von Projekten mit Metadaten
        """
        projects = []

        for project_dir in os.listdir(self.base_path):
            project_path = os.path.join(self.base_path, project_dir)
            metadata_path = os.path.join(project_path, 'metadata.json')

            if os.path.isdir(project_path) and os.path.exists(metadata_path):
                try:
                    with open(metadata_path, 'r') as f:
                        metadata = json.load(f)

                    # Füge Verzeichnisnamen hinzu
                    metadata['directory'] = project_dir

                    # Zähle Bilder
                    images_path = os.path.join(project_path, 'images')
                    if os.path.exists(images_path):
                        image_files = [f for f in os.listdir(images_path)
                                       if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
                        metadata['image_count'] = len(image_files)

                    projects.append(metadata)
                except Exception as e:
                    print(f"Fehler beim Laden von Projekt {project_dir}: {e}")

        # Sortiere nach Erstellungsdatum, neueste zuerst
        projects.sort(key=lambda x: x.get('created', ''), reverse=True)

        return projects

    def get_project(self, project_dir):
        """
        Gibt Metadaten für ein bestimmtes Projekt zurück

        :param project_dir: Projektverzeichnis
        :return: Projektmetadaten
        """
        project_path = os.path.join(self.base_path, project_dir)
        metadata_path = os.path.join(project_path, 'metadata.json')

        if not os.path.exists(metadata_path):
            return None

        try:
            with open(metadata_path, 'r') as f:
                metadata = json.load(f)

            # Füge Verzeichnisnamen hinzu
            metadata['directory'] = project_dir

            # Zähle Bilder und füge Bilderpfade hinzu
            images_path = os.path.join(project_path, 'images')
            if os.path.exists(images_path):
                image_files = [f for f in os.listdir(images_path)
                               if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
                metadata['image_count'] = len(image_files)
                metadata['images'] = sorted(image_files)

            return metadata
        except Exception as e:
            print(f"Fehler beim Laden von Projekt {project_dir}: {e}")
            return None

    def add_image_to_project(self, project_dir, image_path):
        """
        Fügt ein Bild zum Projekt hinzu

        :param project_dir: Projektverzeichnis
        :param image_path: Pfad zum Bild
        :return: Pfad zum kopierten Bild
        """
        project_path = os.path.join(self.base_path, project_dir)
        images_path = os.path.join(project_path, 'images')

        # Stelle sicher, dass das Bildverzeichnis existiert
        os.makedirs(images_path, exist_ok=True)

        # Kopiere das Bild ins Projektverzeichnis
        image_filename = os.path.basename(image_path)
        destination = os.path.join(images_path, image_filename)
        shutil.copy(image_path, destination)

        # Aktualisiere Metadaten
        metadata_path = os.path.join(project_path, 'metadata.json')
        if os.path.exists(metadata_path):
            try:
                with open(metadata_path, 'r') as f:
                    metadata = json.load(f)

                # Aktualisiere Bilderzählung und Änderungsdatum
                metadata['image_count'] = len([f for f in os.listdir(images_path)
                                               if f.lower().endswith(('.jpg', '.jpeg', '.png'))])
                metadata['last_modified'] = datetime.now().isoformat()

                with open(metadata_path, 'w') as f:
                    json.dump(metadata, f, indent=4)
            except Exception as e:
                print(f"Fehler beim Aktualisieren der Projektmetadaten: {e}")

        return destination

    def delete_project(self, project_dir):
        """
        Löscht ein Projekt

        :param project_dir: Projektverzeichnis
        :return: True bei Erfolg, False bei Fehler
        """
        project_path = os.path.join(self.base_path, project_dir)

        if not os.path.exists(project_path):
            return False

        try:
            shutil.rmtree(project_path)
            return True
        except Exception as e:
            print(f"Fehler beim Löschen des Projekts {project_dir}: {e}")
            return False


# Beispiel für die Verwendung
if __name__ == "__main__":
    manager = ProjectManager()

    # Erstelle ein neues Projekt
    project_path = manager.create_project(
        name="Test Produkt",
        description="Eine 360°-Ansicht eines Testprodukts"
    )

    print(f"Neues Projekt erstellt: {project_path}")

    # Liste alle Projekte auf
    projects = manager.get_projects()
    print(f"Vorhandene Projekte: {len(projects)}")
    for project in projects:
        print(f"- {project['name']} ({project['directory']})")

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/setup_and_autostart.sh ---
#!/bin/bash
# setup_and_autostart.sh

# Farbcodes für Terminal-Ausgaben
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}==================================================${NC}"
echo -e "${BLUE}  360° Drehteller - Komplette Systemeinrichtung  ${NC}"
echo -e "${BLUE}==================================================${NC}"

# Überprüfen, ob das Skript mit sudo ausgeführt wird
if [ "$EUID" -ne 0 ]; then
  echo -e "${RED}Bitte führen Sie das Skript mit sudo aus:${NC}"
  echo -e "${YELLOW}sudo bash setup_and_autostart.sh${NC}"
  exit 1
fi

# Verzeichnis des Projekts bestimmen
PROJECT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
echo -e "${YELLOW}Projektverzeichnis: ${PROJECT_DIR}${NC}"

# Benutzernamen ermitteln (vom sudo-Aufruf)
REAL_USER=${SUDO_USER:-$USER}
REAL_USER_HOME=$(eval echo ~$REAL_USER)
echo -e "${YELLOW}Nutzerverzeichnis: ${REAL_USER_HOME}${NC}"

# 1. System-Abhängigkeiten installieren
echo -e "\n${GREEN}1. Installiere System-Abhängigkeiten...${NC}"
apt-get update
apt-get install -y \
    python3-venv \
    python3-dev \
    python3-pip \
    python3-opencv \
    fswebcam \
    v4l-utils \
    libatlas-base-dev \
    git \
    curl \
    nginx \
    gphoto2

# Installiere Arduino CLI
if ! command -v arduino-cli &> /dev/null; then
    echo -e "${YELLOW}Installiere Arduino CLI...${NC}"
    curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | BINDIR=/usr/local/bin sh
    arduino-cli core update-index
    arduino-cli core install arduino:avr
fi

# 2. Python virtuelle Umgebung einrichten
echo -e "\n${GREEN}2. Richte virtuelle Python-Umgebung ein...${NC}"
cd "$PROJECT_DIR"

# Virtuelle Umgebung erstellen, falls nicht vorhanden
if [ ! -d "myenv" ]; then
    python3 -m venv myenv
fi

# Eigentümerrechte für den tatsächlichen Benutzer setzen
chown -R $REAL_USER:$REAL_USER "$PROJECT_DIR/myenv"

# Abhängigkeiten innerhalb der virtuellen Umgebung installieren
echo -e "${YELLOW}Installiere Python-Abhängigkeiten...${NC}"
source myenv/bin/activate
pip install --upgrade pip wheel setuptools

# Wenn requirements.txt existiert, installiere daraus
if [ -f "requirements.txt" ]; then
    pip install -r requirements.txt
else
    # Installiere notwendige Pakete
    pip install flask==2.3.2
    pip install werkzeug==2.3.6
    pip install opencv-python-headless==4.7.0.72
    pip install numpy==1.24.3
    pip install pillow==9.5.0
    pip install pyserial==3.5
    pip install scipy==1.10.1
    pip install pandas==2.0.1
    pip install requests==2.30.0
    pip install imageio==2.31.1
    pip install python-dotenv
    pip install gunicorn
fi

# 3. Verzeichnisstruktur erstellen
echo -e "\n${GREEN}3. Erstelle Verzeichnisstruktur...${NC}"
mkdir -p "$PROJECT_DIR/static/photos"
mkdir -p "$PROJECT_DIR/static/sample_images"
mkdir -p "$PROJECT_DIR/projects"

# Berechtigungen setzen
chown -R $REAL_USER:$REAL_USER "$PROJECT_DIR/static"
chown -R $REAL_USER:$REAL_USER "$PROJECT_DIR/projects"

# Berechtigungen für serielle Ports und Video-Geräte
echo -e "${YELLOW}Füge Benutzer zu notwendigen Gruppen hinzu...${NC}"
usermod -a -G dialout $REAL_USER
usermod -a -G video $REAL_USER

# 4. Platzhalter-Bild erstellen, falls nicht vorhanden
echo -e "\n${GREEN}4. Erzeuge Platzhalter-Bild...${NC}"
if [ ! -f "$PROJECT_DIR/static/placeholder.jpg" ]; then
    python3 - << 'EOL'
from PIL import Image, ImageDraw, ImageFont
import os

def generate_placeholder(output_path='static/placeholder.jpg', width=640, height=480):
    # Stelle sicher, dass der Zielordner existiert
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # Erstelle ein neues Bild mit grauem Hintergrund
    image = Image.new('RGB', (width, height), color=(240, 240, 240))
    draw = ImageDraw.Draw(image)

    # Zeichne Rahmen
    draw.rectangle((0, 0, width-1, height-1), outline=(200, 200, 200), width=2)

    # Füge Text hinzu
    try:
        # Versuche, einen Standardschriftsatz zu laden
        font = ImageFont.load_default()
    except IOError:
        # Fallback auf Standardschriftart
        font = ImageFont.load_default()

    text = "Kein Bild verfügbar"
    text_width = 200  # Ungefähre Textbreite
    text_position = ((width - text_width) // 2, height // 2 - 15)
    draw.text(text_position, text, fill=(100, 100, 100), font=font)

    # Speichere das Bild
    image.save(output_path)
    print(f"Platzhalter-Bild erstellt: {output_path}")

generate_placeholder()
EOL
    # Berechtigungen setzen
    chown $REAL_USER:$REAL_USER "$PROJECT_DIR/static/placeholder.jpg"
fi

# 5. Systemd-Service für Autostart einrichten
echo -e "\n${GREEN}5. Richte Autostart-Service ein...${NC}"

# Service-Datei erstellen
cat > /etc/systemd/system/drehteller360.service << EOL
[Unit]
Description=360 Drehteller Fotografie System
After=network.target

[Service]
User=${REAL_USER}
WorkingDirectory=${PROJECT_DIR}
ExecStart=${PROJECT_DIR}/myenv/bin/python ${PROJECT_DIR}/web.py
Restart=always
Environment="PATH=${PROJECT_DIR}/myenv/bin:/usr/local/bin:/usr/bin:/bin"
Environment="PYTHONPATH=${PROJECT_DIR}"

[Install]
WantedBy=multi-user.target
EOL

# Systemd neu laden und Service aktivieren
systemctl daemon-reload
systemctl enable drehteller360.service
systemctl start drehteller360.service

echo -e "${GREEN}Service gestartet und für Autostart eingerichtet.${NC}"

# 6. Nginx als Reverse Proxy einrichten (optional)
echo -e "\n${GREEN}6. Nginx als Reverse Proxy einrichten?${NC}"
read -p "Möchten Sie Nginx als Reverse Proxy einrichten? (j/n): " setup_nginx

if [[ $setup_nginx == "j" || $setup_nginx == "J" ]]; then
    # Nginx-Konfiguration erstellen
    cat > /etc/nginx/sites-available/drehteller360 << EOL
server {
    listen 80;
    server_name _;

    location / {
        proxy_pass http://127.0.0.1:5000;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    location /static {
        alias ${PROJECT_DIR}/static;
    }
}
EOL

    # Aktiviere die Konfiguration
    ln -sf /etc/nginx/sites-available/drehteller360 /etc/nginx/sites-enabled/
    rm -f /etc/nginx/sites-enabled/default

    # Testen und neustarten
    nginx -t && systemctl restart nginx

    echo -e "${GREEN}Nginx als Reverse Proxy eingerichtet. Das System ist nun über Port 80 erreichbar.${NC}"
else
    echo -e "${YELLOW}Nginx-Setup übersprungen. Das System ist direkt über Port 5000 erreichbar.${NC}"
fi

# 7. Erstelle ein praktisches Start/Stop-Skript
echo -e "\n${GREEN}7. Erstelle Hilfsskript für Start/Stop/Status...${NC}"

cat > "${PROJECT_DIR}/drehteller.sh" << EOL
#!/bin/bash
# drehteller.sh - Hilfsskript zum Verwalten des 360° Drehteller-Systems

case "\$1" in
    start)
        sudo systemctl start drehteller360.service
        echo "360° Drehteller-System gestartet."
        ;;
    stop)
        sudo systemctl stop drehteller360.service
        echo "360° Drehteller-System gestoppt."
        ;;
    restart)
        sudo systemctl restart drehteller360.service
        echo "360° Drehteller-System neugestartet."
        ;;
    status)
        sudo systemctl status drehteller360.service
        ;;
    logs)
        sudo journalctl -u drehteller360.service -f
        ;;
    *)
        echo "Verwendung: \$0 {start|stop|restart|status|logs}"
        exit 1
        ;;
esac
exit 0
EOL

chmod +x "${PROJECT_DIR}/drehteller.sh"
chown $REAL_USER:$REAL_USER "${PROJECT_DIR}/drehteller.sh"

# 8. Abschluss
HOST_IP=$(hostname -I | cut -d' ' -f1)
echo -e "\n${GREEN}==================================================${NC}"
echo -e "${GREEN}  360° Drehteller-System erfolgreich eingerichtet!  ${NC}"
echo -e "${GREEN}==================================================${NC}"
echo -e "${YELLOW}Das System wurde gestartet und läuft automatisch beim Systemstart.${NC}"
echo -e "\n${BLUE}Zugriff auf das System:${NC}"
if [[ $setup_nginx == "j" || $setup_nginx == "J" ]]; then
    echo -e "  URL: ${GREEN}http://${HOST_IP}/${NC}"
else
    echo -e "  URL: ${GREEN}http://${HOST_IP}:5000/${NC}"
fi

echo -e "\n${BLUE}Verwaltung des Systems:${NC}"
echo -e "  ${YELLOW}./drehteller.sh start${NC}   - Startet den Dienst"
echo -e "  ${YELLOW}./drehteller.sh stop${NC}    - Stoppt den Dienst"
echo -e "  ${YELLOW}./drehteller.sh restart${NC} - Neustart des Dienstes"
echo -e "  ${YELLOW}./drehteller.sh status${NC}  - Zeigt den Status"
echo -e "  ${YELLOW}./drehteller.sh logs${NC}    - Zeigt die Logs"

echo -e "\n${GREEN}Viel Erfolg mit deinem 360° Drehteller-System!${NC}"

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/config_manager.py ---
import os
import json


class ConfigManager:
    DEFAULT_CONFIG = {
        'camera': {
            'device_path': '/dev/video0',
            'type': 'webcam',  # or 'gphoto2'
            'resolution': {
                'width': 1280,
                'height': 720
            }
        },
        'arduino': {
            'port': '/dev/ttyACM0',
            'baudrate': 9600
        },
        'rotation': {
            'default_degrees': 15,
            'default_interval': 5
        },
        'simulator': {
            'enabled': True
        }
    }

    def __init__(self, config_path=None):
        """
        Initialize configuration manager

        :param config_path: Path to the configuration file
        """
        # Determine the project directory
        self.project_dir = os.path.dirname(os.path.abspath(__file__))

        # If no config path provided, use a default in the project directory
        if config_path is None:
            config_path = os.path.join(self.project_dir, 'config.json')

        self.config_path = config_path
        self.config = self.load_config()

    def load_config(self):
        """
        Load configuration from file or create default

        :return: Configuration dictionary
        """
        try:
            # Ensure config directory exists
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)

            # Try to load existing config
            if os.path.exists(self.config_path):
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                    # Merge with default to ensure all keys exist
                    return {**self.DEFAULT_CONFIG, **config}
            else:
                # Create default config file
                config = self.DEFAULT_CONFIG
                self.save_config(config)
                return config
        except Exception as e:
            print(f"Error loading config: {e}")
            # If loading fails, use default config and try to save it
            try:
                self.save_config(self.DEFAULT_CONFIG)
            except Exception as save_error:
                print(f"Error saving default config: {save_error}")
            return self.DEFAULT_CONFIG

    def save_config(self, new_config=None):
        """
        Save configuration to file

        :param new_config: Optional new configuration to save
        """
        try:
            # Use provided config or current config
            config_to_save = new_config if new_config is not None else self.config

            # Ensure full path exists
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)

            # Save configuration
            with open(self.config_path, 'w') as f:
                json.dump(config_to_save, f, indent=4)

            # Update current config
            if new_config is not None:
                self.config = new_config
        except Exception as e:
            print(f"Error saving config: {e}")

    def get(self, key, default=None):
        """
        Get a configuration value

        :param key: Dot-separated key (e.g. 'camera.device_path')
        :param default: Default value if key not found
        :return: Configuration value
        """
        try:
            # Split the key into parts
            parts = key.split('.')

            # Navigate through nested dictionary
            value = self.config
            for part in parts:
                value = value.get(part, {})

            # Return value if found, otherwise default
            return value if value != {} else default
        except Exception as e:
            print(f"Error getting config value: {e}")
            return default


# Create a global config manager
config_manager = ConfigManager()

# Standalone usage example
if __name__ == '__main__':
    # Example usage
    print("Camera Device Path:", config_manager.get('camera.device_path'))
    print("Arduino Port:", config_manager.get('arduino.port'))

    # Example of updating config
    config_manager.save_config({
        'camera': {
            'device_path': '/dev/video1',
            'type': 'gphoto2'
        },
        'arduino': {
            'port': '/dev/ttyUSB0',
            'baudrate': 115200
        }
    })

    # Verify changes
    print("\nAfter Update:")
    print("Camera Device Path:", config_manager.get('camera.device_path'))
    print("Arduino Port:", config_manager.get('arduino.port'))


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/zeige-alles-an.py ---
import os

def zeige_dateien_und_inhalt(verzeichnis):
    # Durchlaufe rekursiv alle Unterverzeichnisse und Dateien
    for root, dirs, files in os.walk(verzeichnis):
        # Entferne .git aus der Liste der zu durchsuchenden Verzeichnisse
        if '.git' in dirs:
            dirs.remove('.git')
        if 'bin' in dirs:
            dirs.remove('bin')
        if '__pycache__' in dirs:
            dirs.remove('__pycache__')
        if '.idea' in dirs: 
            dirs.remove('.idea')
        if 'myenv' in dirs:
            dirs.remove('myenv')
        for file in files:
            dateipfad = os.path.join(root, file)
            print(f"\n--- Datei: {dateipfad} ---")
            try:
                # Versuche, die Datei im UTF-8 Format zu öffnen
                with open(dateipfad, 'r', encoding='utf-8') as f:
                    inhalt = f.read()
                    print(inhalt)
            except Exception as e:
                print(f"Fehler beim Lesen der Datei: {e}")

# Beispielnutzung
verzeichnis_pfad = "/home/alex/Dokumente/drehteller_360_grad_fotos"  # Hier den gewünschten Pfad angeben
zeige_dateien_und_inhalt(verzeichnis_pfad)



--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/generate_placeholder.py ---
from PIL import Image, ImageDraw, ImageFont
import os

def generate_placeholder(output_path='static/placeholder.jpg', width=640, height=480):
    """
    Generiert ein Platzhalter-Bild mit Text

    :param output_path: Pfad zum Speichern des Bildes
    :param width: Bildbreite in Pixeln
    :param height: Bildhöhe in Pixeln
    """
    # Stelle sicher, dass der Zielordner existiert
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # Erstelle ein neues Bild mit grauem Hintergrund
    image = Image.new('RGB', (width, height), color=(240, 240, 240))
    draw = ImageDraw.Draw(image)

    # Zeichne Rahmen
    draw.rectangle((0, 0, width-1, height-1), outline=(200, 200, 200), width=2)

    # Füge Text hinzu
    try:
        # Versuche, einen Standardschriftsatz zu laden
        font = ImageFont.load_default()
    except IOError:
        # Fallback auf Standardschriftart
        font = ImageFont.load_default()

    text = "Kein Bild verfügbar"
    text_width = 200  # Ungefähre Textbreite
    text_position = ((width - text_width) // 2, height // 2 - 15)
    draw.text(text_position, text, fill=(100, 100, 100), font=font)

    # Speichere das Bild
    image.save(output_path)
    print(f"Platzhalter-Bild erstellt: {output_path}")

    return output_path

if __name__ == "__main__":
    generate_placeholder()


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/drehteller.sh ---
#!/bin/bash
# drehteller.sh - Hilfsskript zum Verwalten des 360° Drehteller-Systems

case "$1" in
    start)
        sudo systemctl start drehteller360.service
        echo "360° Drehteller-System gestartet."
        ;;
    stop)
        sudo systemctl stop drehteller360.service
        echo "360° Drehteller-System gestoppt."
        ;;
    restart)
        sudo systemctl restart drehteller360.service
        echo "360° Drehteller-System neugestartet."
        ;;
    status)
        sudo systemctl status drehteller360.service
        ;;
    logs)
        sudo journalctl -u drehteller360.service -f
        ;;
    *)
        echo "Verwendung: $0 {start|stop|restart|status|logs}"
        exit 1
        ;;
esac
exit 0


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/config.json ---
{
    "camera": {
        "device_path": "/dev/video0",
        "type": "webcam",
        "resolution": {
            "width": 3840,
            "height": 2160
        }
    },
    "arduino": {
        "port": "/dev/ttyACM0",
        "baudrate": 9600
    },
    "rotation": {
        "default_degrees": 15,
        "default_interval": 1
    },
    "simulator": {
        "enabled": false
    }
}

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/Verzeichnisstruktur.md ---
360-drehteller/
├── web.py                      # Hauptanwendung (Flask)
├── project_manager.py          # Projektverwaltung
├── config_manager.py           # Konfigurationsmanagement
├── git_uploader.py             # Git-Upload-Werkzeug
├── arduino_drehteller_steuerung.ino  # Arduino-Sketch
├── upload_arduino_sketch.sh    # Arduino-Upload-Skript
├── install_pip_modules.sh      # Installationsskript
├── templates/                  # HTML-Templates
│   ├── index.html              # Hauptseite
│   ├── settings.html           # Einstellungen
│   ├── projects.html           # Projektverwaltung
│   ├── project_edit.html       # Projektbearbeitung
│   └── viewer.html             # 360°-Viewer
├── static/                     # Statische Dateien
│   ├── css/                    # Stylesheet-Dateien
│   ├── js/                     # JavaScript-Dateien
│   ├── photos/                 # Aufgenommene Fotos
│   └── sample_images/          # Beispielbilder für Simulator
└── projects/                   # Projektdaten

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/sample_images_generator.py ---
import os
import random
import math
from PIL import Image, ImageDraw, ImageFont


class SampleImagesGenerator:
    def __init__(self, output_path='static/sample_images', width=800, height=600):
        """
        Generate sample images for webcam simulator

        :param output_path: Directory to save generated images
        :param width: Image width
        :param height: Image height
        """
        self.output_path = output_path
        self.width = width
        self.height = height

        # Ensure output directory exists
        os.makedirs(output_path, exist_ok=True)

    def generate_color_gradient_image(self, index):
        """
        Generate an image with a color gradient

        :param index: Unique identifier for the image
        :return: Path to the generated image
        """
        # Create a new image with a gradient
        image = Image.new('RGB', (self.width, self.height))
        draw = ImageDraw.Draw(image)

        # Generate gradient colors
        for y in range(self.height):
            r = int(255 * y / self.height)
            g = int(255 * (1 - y / self.height))
            b = int(128 + 127 * math.sin(y / 50))

            draw.line([(0, y), (self.width, y)], fill=(r, g, b))

        # Add text to identify the image
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 36)
        except IOError:
            font = ImageFont.load_default()

        draw.text((50, 50), f"Sample Image {index}", font=font, fill=(255, 255, 255))

        # Save the image
        filename = os.path.join(self.output_path, f'sample_image_{index}.jpg')
        image.save(filename)
        return filename

    def generate_sample_images(self, count=10):
        """
        Generate multiple sample images

        :param count: Number of images to generate
        :return: List of generated image paths
        """
        generated_images = []
        for i in range(count):
            image_path = self.generate_color_gradient_image(i)
            generated_images.append(image_path)

        return generated_images


# Optionally, if you want to use this as a standalone script
if __name__ == '__main__':
    generator = SampleImagesGenerator()
    generated_images = generator.generate_sample_images()

    print("Generated Sample Images:")
    for img in generated_images:
        print(img)


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/upload_arduino_sketch.sh ---
#!/bin/bash
# upload_arduino_sketch.sh

# Farbcodes für Terminal-Ausgaben
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Arduino Drehteller Sketch Upload Tool${NC}"
echo "======================================"

# Überprüfen, ob Arduino CLI installiert ist
if ! command -v arduino-cli &> /dev/null
then
    echo -e "${YELLOW}Arduino CLI ist nicht installiert. Installiere Arduino CLI...${NC}"

    # Arduino CLI mit dem angegebenen Befehl installieren
    curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh

    # Füge den Pfad zur PATH-Variable hinzu, um arduino-cli direkt nutzen zu können
    export PATH=$PATH:$HOME/bin

    # Überprüfe, ob die Installation erfolgreich war
    if ! command -v arduino-cli &> /dev/null
    then
        echo -e "${RED}Konnte Arduino CLI nicht installieren.${NC}"
        echo "Bitte installieren Sie Arduino CLI manuell: https://arduino.github.io/arduino-cli/latest/installation/"
        exit 1
    fi
fi

# Aktualisiere den Index und installiere die benötigten Arduino-Plattformen
echo -e "${YELLOW}Aktualisiere Core-Index und installiere Arduino-Plattformen...${NC}"
arduino-cli core update-index
arduino-cli core install arduino:avr              # Für klassische Arduino Boards
arduino-cli core install arduino:renesas_uno      # Für Arduino UNO R4 Boards

# Überprüfen, ob der Arduino angeschlossen ist
echo -e "${YELLOW}Suche nach angeschlossenen Arduino-Boards...${NC}"

# Auch manuell nach seriellen Geräten suchen, falls arduino-cli keine Boards erkennt
BOARD_LIST=$(arduino-cli board list)
if [ -z "$BOARD_LIST" ] || [ "$BOARD_LIST" = "Port         Protocol Type Board Name FQBN Core" ]; then
    echo -e "${YELLOW}Arduino CLI konnte keine Boards erkennen. Überprüfe alternative Methoden...${NC}"

    # Prüfe, ob ACM-Geräte vorhanden sind (üblich für Arduino)
    if ls /dev/ttyACM* 1> /dev/null 2>&1; then
        echo -e "${GREEN}ACM-Geräte gefunden:${NC}"
        ls -l /dev/ttyACM*
        PORT=$(ls /dev/ttyACM* | head -1)
        echo -e "${YELLOW}Verwende $PORT als Arduino-Port${NC}"

        # Prüfe UNO R4 über lsusb
        if lsusb | grep -q "Arduino.*UNO.*R4"; then
            echo -e "${GREEN}Arduino UNO R4 erkannt!${NC}"
            FQBN="arduino:renesas_uno:unor4wifi"
        else
            echo -e "${YELLOW}Arduino-Typ nicht eindeutig erkannt, verwende UNO R3 als Standard${NC}"
            FQBN="arduino:avr:uno"
        fi
    elif ls /dev/ttyUSB* 1> /dev/null 2>&1; then
        echo -e "${GREEN}USB-Geräte gefunden:${NC}"
        ls -l /dev/ttyUSB*
        PORT=$(ls /dev/ttyUSB* | head -1)
        echo -e "${YELLOW}Verwende $PORT als Arduino-Port${NC}"
        FQBN="arduino:avr:uno"  # Standardannahme für USB-Geräte
    else
        echo -e "${RED}Kein Arduino-Board gefunden. Bitte schließen Sie ein Arduino-Board an.${NC}"
        exit 1
    fi
else
    echo -e "${GREEN}Verfügbare Boards:${NC}"
    echo "$BOARD_LIST"

    # Versuche, eine vernünftige Vorauswahl zu treffen
    DEFAULT_PORT=$(echo "$BOARD_LIST" | grep -v "Port" | head -1 | awk '{print $1}')
    DEFAULT_FQBN=$(echo "$BOARD_LIST" | grep -v "Port" | head -1 | awk '{print $5}')

    if [ -z "$DEFAULT_PORT" ]; then
        if ls /dev/ttyACM* 1> /dev/null 2>&1; then
            DEFAULT_PORT=$(ls /dev/ttyACM* | head -1)
        elif ls /dev/ttyUSB* 1> /dev/null 2>&1; then
            DEFAULT_PORT=$(ls /dev/ttyUSB* | head -1)
        fi
    fi

    if [ -z "$DEFAULT_FQBN" ]; then
        if lsusb | grep -q "Arduino.*UNO.*R4"; then
            DEFAULT_FQBN="arduino:renesas_uno:unor4wifi"
        else
            DEFAULT_FQBN="arduino:avr:uno"
        fi
    fi
fi

# Erstelle Arduino-Sketch-Verzeichnis und Datei
SKETCH_DIR="arduino_drehteller_steuerung"
mkdir -p "$SKETCH_DIR"

cat > "$SKETCH_DIR/$SKETCH_DIR.ino" << 'EOL'
// arduino_drehteller_steuerung.ino

// Definiere den Pin für das Relais
#define RELAIS_PIN 8

void setup() {
  // Initialisiere die serielle Kommunikation mit 9600 Baud
  Serial.begin(9600);

  // Konfiguriere den Relais-Pin als Ausgang
  pinMode(RELAIS_PIN, OUTPUT);

  // Stelle sicher, dass das Relais zu Beginn ausgeschaltet ist
  digitalWrite(RELAIS_PIN, LOW);

  Serial.println("Arduino Drehteller Steuerung bereit");
}

void loop() {
  // Prüfe, ob Daten verfügbar sind
  if (Serial.available() > 0) {
    // Lese eingehende Daten
    char command = Serial.read();

    // Interpretiere Befehl
    if (command == '1') {
      // Relais einschalten
      digitalWrite(RELAIS_PIN, HIGH);
      Serial.println("Relais eingeschaltet - Drehteller läuft");
    }
    else if (command == '0') {
      // Relais ausschalten
      digitalWrite(RELAIS_PIN, LOW);
      Serial.println("Relais ausgeschaltet - Drehteller gestoppt");
    }
    else {
      // Unbekannter Befehl
      Serial.println("Unbekannter Befehl empfangen. Verwende '1' zum Einschalten und '0' zum Ausschalten.");
    }
  }

  // Kurze Pause, um CPU-Last zu reduzieren
  delay(10);
}
EOL

echo -e "${YELLOW}Arduino-Sketch erstellt in $SKETCH_DIR/$SKETCH_DIR.ino${NC}"

# Frage nach dem Board-Port, wenn noch nicht bestimmt
if [ -z "$PORT" ]; then
    echo -e "${YELLOW}Welcher Port soll für den Upload verwendet werden?${NC}"
    echo "Bitte geben Sie den Port ein (z.B. /dev/ttyACM0 oder COM3): "
    read PORT

    if [ -z "$PORT" ]; then
        echo -e "${RED}Kein Port ausgewählt. Upload abgebrochen.${NC}"
        exit 1
    fi
else
    echo -e "${YELLOW}Verwende Port: $PORT${NC}"
    echo "Möchten Sie einen anderen Port verwenden? (j/N): "
    read CHANGE_PORT

    if [[ "$CHANGE_PORT" == "j" || "$CHANGE_PORT" == "J" ]]; then
        echo "Bitte geben Sie den Port ein (z.B. /dev/ttyACM0 oder COM3): "
        read NEW_PORT
        if [ ! -z "$NEW_PORT" ]; then
            PORT=$NEW_PORT
        fi
    fi
fi

# Frage nach dem Board-Typ, wenn noch nicht bestimmt
if [ -z "$FQBN" ]; then
    echo -e "${YELLOW}Welcher Board-Typ wird verwendet?${NC}"
    echo "1) Arduino UNO R3 (Classic) - arduino:avr:uno"
    echo "2) Arduino UNO R4 WiFi - arduino:renesas_uno:unor4wifi"
    echo "3) Arduino UNO R4 Minima - arduino:renesas_uno:unor4minima"
    echo "4) Arduino Nano - arduino:avr:nano"
    echo "5) Arduino Mega - arduino:avr:mega"
    echo "6) Arduino Leonardo - arduino:avr:leonardo"
    echo "Bitte wählen Sie eine Option (1-6): "
    read BOARD_CHOICE

    case $BOARD_CHOICE in
        1)
            FQBN="arduino:avr:uno"
            ;;
        2)
            FQBN="arduino:renesas_uno:unor4wifi"
            ;;
        3)
            FQBN="arduino:renesas_uno:unor4minima"
            ;;
        4)
            FQBN="arduino:avr:nano"
            ;;
        5)
            FQBN="arduino:avr:mega"
            ;;
        6)
            FQBN="arduino:avr:leonardo"
            ;;
        *)
            FQBN="arduino:avr:uno"
            echo -e "${YELLOW}Keine gültige Auswahl. Verwende Arduino Uno R3 als Standard.${NC}"
            ;;
    esac
else
    echo -e "${YELLOW}Verwende Board-Typ: $FQBN${NC}"
    echo "Möchten Sie einen anderen Board-Typ verwenden? (j/N): "
    read CHANGE_BOARD

    if [[ "$CHANGE_BOARD" == "j" || "$CHANGE_BOARD" == "J" ]]; then
        echo "1) Arduino UNO R3 (Classic) - arduino:avr:uno"
        echo "2) Arduino UNO R4 WiFi - arduino:renesas_uno:unor4wifi"
        echo "3) Arduino UNO R4 Minima - arduino:renesas_uno:unor4minima"
        echo "4) Arduino Nano - arduino:avr:nano"
        echo "5) Arduino Mega - arduino:avr:mega"
        echo "6) Arduino Leonardo - arduino:avr:leonardo"
        echo "Bitte wählen Sie eine Option (1-6): "
        read BOARD_CHOICE

        case $BOARD_CHOICE in
            1)
                FQBN="arduino:avr:uno"
                ;;
            2)
                FQBN="arduino:renesas_uno:unor4wifi"
                ;;
            3)
                FQBN="arduino:renesas_uno:unor4minima"
                ;;
            4)
                FQBN="arduino:avr:nano"
                ;;
            5)
                FQBN="arduino:avr:mega"
                ;;
            6)
                FQBN="arduino:avr:leonardo"
                ;;
        esac
    fi
fi

# Kompiliere den Sketch
echo -e "${YELLOW}Kompiliere Arduino-Sketch...${NC}"
arduino-cli compile --fqbn $FQBN "$SKETCH_DIR"

if [ $? -ne 0 ]; then
    echo -e "${RED}Kompilierung fehlgeschlagen. Bitte überprüfen Sie den Sketch und die Board-Auswahl.${NC}"
    exit 1
fi

# Upload des Sketches auf den Arduino
echo -e "${YELLOW}Lade Sketch auf den Arduino hoch...${NC}"
echo -e "${YELLOW}Verwende Befehl: arduino-cli upload -p $PORT --fqbn $FQBN \"$SKETCH_DIR\"${NC}"

# Füge Berechtigungen hinzu, falls notwendig
if [ ! -w "$PORT" ]; then
    echo -e "${YELLOW}Portberechtigungen anpassen...${NC}"
    sudo chmod a+rw $PORT
fi

# Upload durchführen
arduino-cli upload -p $PORT --fqbn $FQBN "$SKETCH_DIR"

if [ $? -ne 0 ]; then
    echo -e "${RED}Upload fehlgeschlagen. Bitte überprüfen Sie die Verbindung zum Arduino und die Board-Auswahl.${NC}"
    echo -e "${YELLOW}Mögliche Lösungen:${NC}"
    echo "1. Stelle sicher, dass der richtige Port ausgewählt ist."
    echo "2. Überprüfe, ob der richtige Board-Typ ausgewählt ist."
    echo "3. Drücke bei Arduino UNO R4 den Reset-Knopf während des Hochladens."
    echo "4. Prüfe die USB-Kabelverbindung oder versuche ein anderes Kabel."
    echo "5. Versuche, das Board neu anzuschließen."
    echo "6. Führe 'sudo chmod a+rw $PORT' aus, um Berechtigungsprobleme zu beheben."
    exit 1
fi

echo -e "${GREEN}Arduino-Sketch erfolgreich hochgeladen!${NC}"
echo "Der Arduino ist nun bereit für die Steuerung des Drehtellers."
echo "Sie können die Funktionalität mit dem folgenden Befehl testen:"
echo "python -c \"import serial, time; s = serial.Serial('$PORT', 9600); time.sleep(2); s.write(b'1'); time.sleep(2); s.write(b'0'); s.close()\""

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/arduino_drehteller_steuerung/arduino_drehteller_steuerung.ino ---
// arduino_drehteller_steuerung.ino

// Definiere den Pin für das Relais
#define RELAIS_PIN 8

void setup() {
  // Initialisiere die serielle Kommunikation mit 9600 Baud
  Serial.begin(9600);

  // Konfiguriere den Relais-Pin als Ausgang
  pinMode(RELAIS_PIN, OUTPUT);

  // Stelle sicher, dass das Relais zu Beginn ausgeschaltet ist
  digitalWrite(RELAIS_PIN, LOW);

  Serial.println("Arduino Drehteller Steuerung bereit");
}

void loop() {
  // Prüfe, ob Daten verfügbar sind
  if (Serial.available() > 0) {
    // Lese eingehende Daten
    char command = Serial.read();

    // Interpretiere Befehl
    if (command == '1') {
      // Relais einschalten
      digitalWrite(RELAIS_PIN, HIGH);
      Serial.println("Relais eingeschaltet - Drehteller läuft");
    }
    else if (command == '0') {
      // Relais ausschalten
      digitalWrite(RELAIS_PIN, LOW);
      Serial.println("Relais ausgeschaltet - Drehteller gestoppt");
    }
    else {
      // Unbekannter Befehl
      Serial.println("Unbekannter Befehl empfangen. Verwende '1' zum Einschalten und '0' zum Ausschalten.");
    }
  }

  // Kurze Pause, um CPU-Last zu reduzieren
  delay(10);
}


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/templates/project_edit.html ---
<!-- templates/project_edit.html -->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projekt bearbeiten - 360° Drehteller</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/project_edit.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h2 class="mb-0">Projekt: {{ project.name }}</h2>
                <div>
                    <a href="/viewer/{{ project.directory }}" class="btn btn-light btn-sm me-2">
                        <i class="bi bi-eye"></i> 360° Ansicht
                    </a>
                    <a href="/projects" class="btn btn-light btn-sm">
                        <i class="bi bi-arrow-left"></i> Zurück
                    </a>
                </div>
            </div>
            <div class="card-body">
                <!-- Projektverlauf -->
                <div class="mb-4">
                    <h3>Projektdetails</h3>
                    <div class="row">
                        <div class="col-md-6">
                            <dl class="row">
                                <dt class="col-sm-4">Erstellt</dt>
                                <dd class="col-sm-8">{{ project.created.split('T')[0] }}</dd>

                                <dt class="col-sm-4">Letzte Änderung</dt>
                                <dd class="col-sm-8">{{ project.last_modified.split('T')[0] }}</dd>

                                <dt class="col-sm-4">Bilder</dt>
                                <dd class="col-sm-8">{{ project.image_count }}</dd>
                            </dl>
                        </div>
                        <div class="col-md-6">
                            <div class="form-floating">
                                <textarea class="form-control" id="project-description" style="height: 100px">{{ project.description or '' }}</textarea>
                                <label for="project-description">Projektbeschreibung</label>
                            </div>
                            <button class="btn btn-sm btn-outline-secondary mt-2" id="save-description">Speichern</button>
                        </div>
                    </div>
                </div>

                <!-- 360° Aufnahmesteuerung -->
                <div class="mb-4">
                    <h3>360° Aufnahme</h3>
                    <form id="rotation-form" class="row g-3">
                        <input type="hidden" name="project_dir" value="{{ project.directory }}">

                        <div class="col-md-3">
                            <label for="rotation-degrees" class="form-label">Drehwinkel pro Schritt</label>
                            <select class="form-select" id="rotation-degrees" name="degrees">
                                <option value="5">5°</option>
                                <option value="10">10°</option>
                                <option value="15" selected>15°</option>
                                <option value="20">20°</option>
                                <option value="30">30°</option>
                                <option value="45">45°</option>
                                <option value="90">90°</option>
                            </select>
                        </div>

                        <div class="col-md-3">
                            <label for="rotation-interval" class="form-label">Intervall (Sekunden)</label>
                            <input type="number" class="form-control" id="rotation-interval" name="interval" value="5" min="1" max="60">
                        </div>

                        <div class="col-md-6 d-flex align-items-end">
                            <button type="button" id="start-single-capture" class="btn btn-primary me-2">
                                <i class="bi bi-camera"></i> Einzelaufnahme
                            </button>
                            <button type="button" id="start-full-360" class="btn btn-success">
                                <i class="bi bi-arrow-repeat"></i> Volle 360° Aufnahme
                            </button>
                        </div>
                    </form>

                    <!-- Fortschrittsanzeige -->
                    <div id="progress-container" class="mt-3" style="display: none;">
                        <div class="progress">
                            <div id="rotation-progress" class="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                        <div id="rotation-status" class="text-center mt-2"></div>
                        <button id="stop-capture" class="btn btn-danger btn-sm mt-2">
                            <i class="bi bi-stop-fill"></i> Aufnahme stoppen
                        </button>
                    </div>
                </div>

                <!-- Vorschaubereich -->
                <div class="mb-4">
                    <h3>Aktuelle Aufnahme</h3>
                    <div class="current-capture-container">
                        <img id="current-capture" src="/static/placeholder.jpg" alt="Aktuelle Aufnahme" class="img-fluid">
                    </div>
                </div>

                <!-- Bildergalerie -->
                <div>
                    <h3>Projektbilder</h3>
                    {% if project.images and project.images|length > 0 %}
                        <div class="row row-cols-2 row-cols-md-4 g-3 image-gallery">
                            {% for image in project.images %}
                                <div class="col">
                                    <div class="card h-100">
                                        <img src="/projects/image/{{ project.directory }}/{{ image }}"
                                             class="card-img-top" alt="Projektbild">
                                        <div class="card-footer">
                                            <small class="text-muted">{{ loop.index }}/{{ project.images|length }}</small>
                                        </div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% else %}
                        <div class="alert alert-info">
                            Keine Bilder vorhanden. Starten Sie eine Aufnahme, um Bilder hinzuzufügen.
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS und Abhängigkeiten -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const rotationForm = document.getElementById('rotation-form');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('rotation-progress');
            const rotationStatus = document.getElementById('rotation-status');
            const currentCapture = document.getElementById('current-capture');
            const startSingleCapture = document.getElementById('start-single-capture');
            const startFull360 = document.getElementById('start-full-360');
            const stopCapture = document.getElementById('stop-capture');

            let isCapturing = false;
            let captureAborted = false;

            // Einzelne Aufnahme
            startSingleCapture.addEventListener('click', function() {
                const formData = new FormData(rotationForm);

                // UI aktualisieren
                startSingleCapture.disabled = true;
                startFull360.disabled = true;
                rotationStatus.textContent = 'Einzelaufnahme wird durchgeführt...';
                progressContainer.style.display = 'block';
                progressBar.style.width = '50%';

                fetch('/add_rotation_to_project', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        currentCapture.src = data.photo_path;
                        progressBar.style.width = '100%';
                        rotationStatus.textContent = 'Aufnahme erfolgreich';

                        // Seite nach kurzer Verzögerung neu laden, um Galerie zu aktualisieren
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    } else {
                        progressBar.classList.add('bg-danger');
                        rotationStatus.textContent = 'Fehler: ' + data.message;
                    }
                })
                .catch(error => {
                    console.error('Fehler:', error);
                    progressBar.classList.add('bg-danger');
                    rotationStatus.textContent = 'Fehler bei der Anfrage';
                })
                .finally(() => {
                    startSingleCapture.disabled = false;
                    startFull360.disabled = false;
                });
            });

            // Vollständige 360°-Aufnahme
            startFull360.addEventListener('click', async function() {
                const degrees = parseInt(document.getElementById('rotation-degrees').value);
                const interval = parseInt(document.getElementById('rotation-interval').value);
                const totalSteps = Math.floor(360 / degrees);

                // UI aktualisieren
                startSingleCapture.disabled = true;
                startFull360.disabled = true;
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressBar.classList.remove('bg-danger');
                rotationStatus.textContent = 'Starte 360° Aufnahme...';

                isCapturing = true;
                captureAborted = false;

                for (let step = 0; step < totalSteps; step++) {
                    // Überprüfen, ob die Aufnahme abgebrochen wurde
                    if (captureAborted) {
                        break;
                    }

                    // Fortschritt aktualisieren
                    const progress = ((step + 1) / totalSteps) * 100;
                    progressBar.style.width = `${progress}%`;
                    rotationStatus.textContent = `Aufnahme ${step + 1} von ${totalSteps}`;

                    // Formular vorbereiten
                    const formData = new FormData(rotationForm);

                    try {
                        // Aufnahme durchführen
                        const response = await fetch('/add_rotation_to_project', {
                            method: 'POST',
                            body: formData
                        });

                        const data = await response.json();

                        if (data.status === 'success') {
                            currentCapture.src = data.photo_path;
                        } else {
                            throw new Error(data.message || 'Unbekannter Fehler');
                        }

                        // Warten für das Intervall
                        if (step < totalSteps - 1 && !captureAborted) {
                            await new Promise(resolve => setTimeout(resolve, interval * 1000));
                        }
                    } catch (error) {
                        console.error('Fehler:', error);
                        progressBar.classList.add('bg-danger');
                        rotationStatus.textContent = `Fehler: ${error.message}`;
                        break;
                    }
                }

                // Abschluss
                if (!captureAborted) {
                    rotationStatus.textContent = '360° Aufnahme abgeschlossen!';
                } else {
                    rotationStatus.textContent = '360° Aufnahme abgebrochen';
                }

                // UI zurücksetzen
                isCapturing = false;
                startSingleCapture.disabled = false;
                startFull360.disabled = false;

                // Seite neu laden, um Galerie zu aktualisieren
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            });

            // Aufnahme stoppen
            stopCapture.addEventListener('click', function() {
                if (isCapturing) {
                    captureAborted = true;
                    rotationStatus.textContent = 'Aufnahme wird gestoppt...';
                }
            });

            // Projektbeschreibung speichern
            document.getElementById('save-description').addEventListener('click', function() {
                const description = document.getElementById('project-description').value;
                const projectDir = rotationForm.querySelector('[name="project_dir"]').value;

                fetch('/projects/update_description', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        project_dir: projectDir,
                        description: description
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        alert('Beschreibung gespeichert');
                    } else {
                        alert('Fehler: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Fehler:', error);
                    alert('Fehler beim Speichern der Beschreibung');
                });
            });
        });
    </script>
</body>
</html>

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/templates/viewer.html ---
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Viewer - Drehteller Steuerung</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/viewer.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h2 class="mb-0">360° Produktansicht</h2>
                <div>
                    <a href="/" class="btn btn-light btn-sm me-2">
                        <i class="bi bi-house"></i> Zurück zur Steuerung
                    </a>
                    <button id="fullscreen-btn" class="btn btn-light btn-sm">
                        <i class="bi bi-fullscreen"></i>
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div id="viewer-container" class="position-relative">
                    <!-- Viewer wird hier per JavaScript eingefügt -->
                    <div id="spinner" class="position-absolute top-50 start-50 translate-middle">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Laden...</span>
                        </div>
                    </div>
                    <div id="product-viewer" class="viewer-360"></div>
                </div>

                <div class="mt-4 d-flex justify-content-between">
                    <div class="viewer-controls">
                        <button id="play-btn" class="btn btn-primary">
                            <i class="bi bi-play-fill"></i> Auto-Rotation
                        </button>
                        <button id="reset-btn" class="btn btn-secondary ms-2">
                            <i class="bi bi-arrow-counterclockwise"></i> Zurücksetzen
                        </button>
                    </div>

                    <div class="zoom-controls">
                        <button id="zoom-in-btn" class="btn btn-outline-secondary">
                            <i class="bi bi-zoom-in"></i>
                        </button>
                        <button id="zoom-out-btn" class="btn btn-outline-secondary ms-2">
                            <i class="bi bi-zoom-out"></i>
                        </button>
                    </div>
                </div>

                <div class="mt-4">
                    <div class="project-info">
                        <h4 id="project-name">Projekt: <span></span></h4>
                        <p id="image-count">Bilder: <span></span></p>
                    </div>
                </div>
            </div>

            <div class="card-footer text-center">
                <p>Bewegen Sie die Maus oder wischen Sie auf dem Touchscreen, um das Objekt zu drehen.</p>
                <small class="text-muted">Erstellt mit Drehteller 360° Steuerung</small>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/viewer.js"></script>
</body>
</html>

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/templates/settings.html ---
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drehteller Einstellungen</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/settings.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white">
                <h2 class="text-center mb-0">
                    <i class="bi bi-gear me-2"></i>Drehteller Einstellungen
                </h2>
            </div>
            <div class="card-body">
                <form id="settings-form">
                    <!-- Camera Settings -->
                    <div class="mb-3">
                        <h4>Kamera Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-8">
                                <label for="camera-device-path" class="form-label">Geräte-Pfad</label>
                                <input type="text" class="form-control" id="camera-device-path"
                                       placeholder="/dev/video0" required>
                                <div class="form-text">Pfad zum Kameragerät (z.B. /dev/video0)</div>
                            </div>
                            <div class="col-md-4">
                                <label for="camera-type" class="form-label">Kameratyp</label>
                                <select class="form-select" id="camera-type">
                                    <option value="webcam">Webcam</option>
                                    <option value="gphoto2">DSLR (gphoto2)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Arduino Settings -->
                    <div class="mb-3">
                        <h4>Arduino Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-8">
                                <label for="arduino-port" class="form-label">Serieller Port</label>
                                <input type="text" class="form-control" id="arduino-port"
                                       placeholder="/dev/ttyACM0" required>
                                <div class="form-text">Pfad zum Arduino-Port (z.B. /dev/ttyACM0)</div>
                            </div>
                            <div class="col-md-4">
                                <label for="arduino-baudrate" class="form-label">Baudrate</label>
                                <select class="form-select" id="arduino-baudrate">
                                    <option value="9600">9600</option>
                                    <option value="115200">115200</option>
                                    <option value="57600">57600</option>
                                    <option value="38400">38400</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Rotation Settings -->
                    <div class="mb-3">
                        <h4>Rotations-Einstellungen</h4>
                        <div class="row">
                            <div class="col-md-6">
                                <label for="rotation-degrees" class="form-label">Standard Drehwinkel</label>
                                <input type="number" class="form-control" id="rotation-degrees"
                                       min="1" max="90" value="15">
                                <div class="form-text">Standardwinkel pro Rotationsschritt</div>
                            </div>
                            <div class="col-md-6">
                                <label for="rotation-interval" class="form-label">Foto-Intervall</label>
                                <input type="number" class="form-control" id="rotation-interval"
                                       min="1" max="60" value="5">
                                <div class="form-text">Sekunden zwischen Fotos</div>
                            </div>
                        </div>
                    </div>


                    <!-- Camera Resolution Settings -->
                    <div class="mb-3">
                        <h4>Kamera-Auflösung</h4>
                        <div class="row g-3">
                            <div class="col-md-4">
                                <label for="camera-width" class="form-label">Breite (Pixel)</label>
                                <input type="number" class="form-control" id="camera-width"
                                       placeholder="z.B. 1280" min="160" max="3840">
                            </div>
                            <div class="col-md-4">
                                <label for="camera-height" class="form-label">Höhe (Pixel)</label>
                                <input type="number" class="form-control" id="camera-height"
                                       placeholder="z.B. 720" min="120" max="2160">
                            </div>
                            <div class="col-md-4">
                                <label for="camera-resolution-preset" class="form-label">Voreinstellungen</label>
                                <select class="form-select" id="camera-resolution-preset">
                                    <option value="custom">Benutzerdefiniert</option>
                                    <option value="640x480">640x480 (VGA)</option>
                                    <option value="1280x720">1280x720 (HD)</option>
                                    <option value="1920x1080">1920x1080 (Full HD)</option>
                                    <option value="2560x1440">2560x1440 (QHD)</option>
                                    <option value="3840x2160">3840x2160 (4K)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Simulator Controls -->
                    <div class="mt-4">
                        <h4>Simulator Einstellungen</h4>
                        <div class="row g-3">
                            <div class="col-md-4">
                                <label class="form-label">Simulator-Modus</label>
                                <div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="simulator-mode" id="simulator-on" value="true">
                                        <label class="form-check-label" for="simulator-on">
                                            Ein
                                        </label>
                                    </div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="radio" name="simulator-mode" id="simulator-off" value="false">
                                        <label class="form-check-label" for="simulator-off">
                                            Aus
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-8">
                                <label class="form-label">Simulator-Tools</label>
                                <div>
                                    <button type="button" id="generate-sample-images" class="btn btn-secondary me-2">
                                        <i class="bi bi-image me-2"></i>Beispielbilder generieren
                                    </button>
                                    <button type="button" id="test-webcam-simulator" class="btn btn-info">
                                        <i class="bi bi-camera me-2"></i>Webcam-Simulator testen
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="d-grid gap-2 d-md-flex justify-content-md-end mt-4">
                        <a href="/" class="btn btn-secondary">
                            <i class="bi bi-x-circle me-2"></i>Abbrechen
                        </a>
                        <button type="submit" class="btn btn-primary">
                            <i class="bi bi-save me-2"></i>Speichern
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/settings.js"></script>
</body>
</html>


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/templates/projects.html ---
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projektverwaltung - 360° Drehteller Steuerung</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        body {
            background-color: #f4f4f4;
            padding-top: 50px;
        }
        
        .container {
            max-width: 800px;
        }
        
        .card {
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .project-card {
            transition: transform 0.2s;
            margin-bottom: 20px;
        }
        
        .project-card:hover {
            transform: translateY(-5px);
        }
        
        .project-thumbnail {
            height: 180px;
            background-color: #e9ecef;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .project-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .project-card:hover .project-actions {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h2 class="mb-0">Projektverwaltung</h2>
                <a href="/" class="btn btn-light btn-sm">
                    <i class="bi bi-house"></i> Zurück zur Steuerung
                </a>
            </div>
            <div class="card-body">
                <div id="projects-container" class="row">
                    <!-- Projekte werden hier dynamisch eingefügt -->
                    <div class="col-12 text-center py-5" id="loading">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Lade...</span>
                        </div>
                        <p class="mt-2">Projekte werden geladen...</p>
                    </div>
                    
                    <div class="col-12 text-center py-5 d-none" id="no-projects">
                        <i class="bi bi-folder-x" style="font-size: 3rem; color: #adb5bd;"></i>
                        <h4 class="mt-3">Keine Projekte gefunden</h4>
                        <p class="text-muted">Erstellen Sie Ihr erstes 360° Projekt auf der Hauptseite.</p>
                        <a href="/" class="btn btn-primary mt-2">
                            <i class="bi bi-plus-circle"></i> Neues Projekt erstellen
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Lösch-Bestätigungsdialog -->
    <div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteModalLabel">Projekt löschen</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Schließen"></button>
                </div>
                <div class="modal-body">
                    Sind Sie sicher, dass Sie das Projekt <span id="delete-project-name" class="fw-bold"></span> löschen möchten? 
                    Diese Aktion kann nicht rückgängig gemacht werden.
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                    <button type="button" class="btn btn-danger" id="confirm-delete">Löschen</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Projekt-Template -->
    <template id="project-template">
        <div class="col-md-6 col-lg-4 project-card">
            <div class="card h-100">
                <div class="project-thumbnail">
                    <div class="project-actions">
                        <button class="btn btn-sm btn-danger delete-btn" title="Projekt löschen">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <h5 class="card-title project-name">Projektname</h5>
                    <p class="card-text">
                        <small class="text-muted project-date">Erstellungsdatum</small><br>
                        <span class="project-image-count">0 Bilder</span>
                    </p>
                </div>
                <div class="card-footer d-grid">
                    <a href="#" class="btn btn-primary view-btn">
                        <i class="bi bi-eye"></i> 360° Ansicht öffnen
                    </a>
                </div>
            </div>
        </div>
    </template>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            loadProjects();
            
            // Lösch-Dialog Setup
            const deleteModal = new bootstrap.Modal(document.getElementById('deleteModal'));
            let projectToDelete = null;
            
            document.getElementById('confirm-delete').addEventListener('click', () => {
                if (projectToDelete) {
                    deleteProject(projectToDelete);
                    deleteModal.hide();
                }
            });
        });
        
        // Projekte laden
        async function loadProjects() {
            try {
                const response = await fetch('/api/projects');
                const projects = await response.json();
                
                const loadingElement = document.getElementById('loading');
                const noProjectsElement = document.getElementById('no-projects');
                const projectsContainer = document.getElementById('projects-container');
                
                // Loading ausblenden
                loadingElement.remove();
                
                if (projects.length === 0) {
                    noProjectsElement.classList.remove('d-none');
                    return;
                }
                
                // Projekte sortieren (neueste zuerst)
                projects.sort((a, b) => b.created - a.created);
                
                // Projekte anzeigen
                projects.forEach(project => {
                    const projectElement = createProjectElement(project);
                    projectsContainer.appendChild(projectElement);
                });
                
            } catch (error) {
                console.error('Fehler beim Laden der Projekte:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle"></i> Fehler beim Laden der Projekte: ${error.message}
                    </div>
                `;
            }
        }
        
        // Projekt-Element erstellen
        function createProjectElement(project) {
            const template = document.getElementById('project-template');
            const projectElement = template.content.cloneNode(true);
            
            // Projektdaten einfügen
            const thumbnailElement = projectElement.querySelector('.project-thumbnail');
            const nameElement = projectElement.querySelector('.project-name');
            const dateElement = projectElement.querySelector('.project-date');
            const imageCountElement = projectElement.querySelector('.project-image-count');
            const viewButton = projectElement.querySelector('.view-btn');
            const deleteButton = projectElement.querySelector('.delete-btn');
            
            // Thumbnail setzen (erstes Bild im Projekt)
            if (project.images && project.images.length > 0) {
                thumbnailElement.style.backgroundImage = `url('/static/projects/${project.id}/${project.images[0]}')`;
            }
            
            // Projektname setzen
            nameElement.textContent = project.name || project.id;
            
            // Datum formatieren
            const date = new Date(project.created * 1000);
            dateElement.textContent = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            
            // Bildanzahl
            const imageCount = project.image_count || (project.images ? project.images.length : 0);
            imageCountElement.textContent = `${imageCount} Bilder`;
            
            // Link zum Viewer
            viewButton.href = `/viewer?project=${project.id}`;
            
            // Lösch-Button
            deleteButton.addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById('delete-project-name').textContent = project.name || project.id;
                projectToDelete = project.id;
                const deleteModal = new bootstrap.Modal(document.getElementById('deleteModal'));
                deleteModal.show();
            });
            
            return projectElement.firstElementChild;
        }
        
        // Projekt löschen
        async function deleteProject(projectId) {
            try {
                const response = await fetch(`/api/project/${projectId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    // Projekt erfolgreich gelöscht, Seite neu laden
                    window.location.reload();
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Unbekannter Fehler beim Löschen');
                }
            } catch (error) {
                console.error('Fehler beim Löschen des Projekts:', error);
                alert(`Fehler beim Löschen: ${error.message}`);
            }
        }
    </script>
</body>
</html>


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/templates/index.html ---
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Drehteller Steuerung</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/index.css">
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h2 class="mb-0">360° Drehteller Steuerung</h2>
                <div>
                    <a href="/projects" class="btn btn-light btn-sm me-2">
                        <i class="bi bi-folder"></i> Projekte
                    </a>
                    <a href="/settings" class="btn btn-light btn-sm">
                        <i class="bi bi-gear"></i> Einstellungen
                    </a>
                </div>
            </div>
            <div class="card-body">
                <!-- Captured Image Display -->
                <div class="text-center mb-4">
                    <img id="captured-image" src="/static/placeholder.jpg" alt="Aktuelles Foto" class="img-fluid">
                </div>

                <!-- Rotation Settings -->
                <div id="rotation-settings" class="row g-3">
                    <div class="col-md-4">
                        <label for="rotation-interval" class="form-label">Foto-Intervall (Sekunden)</label>
                        <input type="number" class="form-control" id="rotation-interval" value="5" min="1" max="60">
                    </div>
                    <div class="col-md-4">
                        <label for="rotation-degrees" class="form-label">Drehwinkel pro Schritt</label>
                        <input type="number" class="form-control" id="rotation-degrees" value="15" min="1" max="90">
                    </div>
                    <div class="col-md-4 d-flex align-items-end gap-2">
                        <button id="start-360-rotation" class="btn btn-success btn-play flex-grow-1">
                            <i class="bi bi-play-fill"></i> Start 360°
                        </button>
                        <button id="stop-rotation" class="btn btn-danger btn-stop d-none">
                            <i class="bi bi-stop-fill"></i> Stop
                        </button>
                    </div>
                </div>

                <!-- Progress Display -->
                <div id="progress-container" class="mt-3" style="display: none;">
                    <div class="progress">
                        <div id="rotation-progress" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                    <div id="rotation-status" class="text-center mt-2"></div>
                </div>

                <!-- 360° Viewer generieren -->
                <div id="generate-360-container" class="mt-4">
                    <h3>360° Viewer generieren</h3>
                    <div class="row g-3">
                        <div class="col-md-8">
                            <input type="text" class="form-control" id="project-name" placeholder="Projektname (optional)">
                        </div>
                        <div class="col-md-4">
                            <button id="generate-360-btn" class="btn btn-primary w-100">
                                <i class="bi bi-camera-video"></i> 360° Viewer erstellen
                            </button>
                        </div>
                    </div>
                    <div id="generation-status" class="mt-2"></div>
                </div>

                <!-- Manual Rotation -->
                <div class="mt-4">
                    <h3>Manuelle Rotation</h3>
                    <form id="manual-rotation-form">
                        <div class="input-group">
                            <input type="number" class="form-control" id="manual-degrees" placeholder="Drehwinkel" min="0" max="360" required>
                            <button type="submit" class="btn btn-primary">
                                <i class="bi bi-arrow-clockwise"></i> Drehen
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/index.js"></script>
    <script>
        // 360° Viewer Generierung
        document.getElementById('generate-360-btn').addEventListener('click', async () => {
            const statusElement = document.getElementById('generation-status');
            statusElement.innerHTML = '<div class="alert alert-info">Generiere 360° Viewer...</div>';
            
            const projectName = document.getElementById('project-name').value;
            
            try {
                const response = await fetch('/generate_360', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: projectName || ('Projekt ' + new Date().toLocaleDateString())
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    statusElement.innerHTML = `
                        <div class="alert alert-success">
                            360° Viewer erfolgreich erstellt! 
                            <a href="${result.url}" class="btn btn-sm btn-primary ms-2">Anzeigen</a>
                        </div>`;
                } else {
                    statusElement.innerHTML = `<div class="alert alert-danger">Fehler: ${result.error}</div>`;
                }
            } catch (error) {
                statusElement.innerHTML = `<div class="alert alert-danger">Fehler: ${error.message}</div>`;
            }
        });
    </script>
</body>
</html>


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/placeholder.jpg ---
Fehler beim Lesen der Datei: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/photos/.gitkeep ---


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/js/index.js ---
// static/js/index.js
// DOM Elements
const startButton = document.getElementById('start-360-rotation');
const stopButton = document.getElementById('stop-rotation');
const rotationIntervalInput = document.getElementById('rotation-interval');
const rotationDegreesInput = document.getElementById('rotation-degrees');
const progressContainer = document.getElementById('progress-container');
const progressBar = document.getElementById('rotation-progress');
const rotationStatus = document.getElementById('rotation-status');
const capturedImage = document.getElementById('captured-image');
const manualRotationForm = document.getElementById('manual-rotation-form');

// Rotation state
let isRotating = false;
let rotationAborted = false;

// 360° Rotation Function
async function start360Rotation() {
    const interval = parseInt(rotationIntervalInput.value);
    const stepDegrees = parseInt(rotationDegreesInput.value);
    const totalRotations = Math.floor(360 / stepDegrees);

    // Disable start button, show stop button
    startButton.disabled = true;
    stopButton.classList.remove('d-none');
    progressContainer.style.display = 'block';
    rotationStatus.textContent = 'Rotation gestartet...';
    isRotating = true;
    rotationAborted = false;

    // Reset progress
    progressBar.style.width = '0%';
    progressBar.classList.add('progress-bar-animated');

    try {
        for (let i = 0; i < totalRotations; i++) {
            // Check if rotation was aborted
            if (rotationAborted) {
                break;
            }

            // Update progress
            const progress = ((i + 1) / totalRotations) * 100;
            progressBar.style.width = `${progress}%`;
            rotationStatus.textContent = `Foto ${i + 1} von ${totalRotations}`;

            // Send rotation and photo capture request
            const response = await fetch('/rotate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `degrees=${stepDegrees}&interval=${interval}`
            });

            // Check if request was successful
            if (!response.ok) {
                throw new Error('Rotation fehlgeschlagen');
            }

            // Update image source with the latest photo
            const result = await response.text();
            capturedImage.src = result; // Assuming the response contains the photo path

            // Wait for the specified interval
            await new Promise(resolve => setTimeout(resolve, interval * 1000));
        }

        // Rotation complete
        if (!rotationAborted) {
            rotationStatus.textContent = 'Rotation abgeschlossen!';
            progressBar.classList.remove('progress-bar-animated');
        } else {
            rotationStatus.textContent = 'Rotation abgebrochen!';
            progressBar.classList.add('bg-warning');
        }
    } catch (error) {
        // Handle errors
        rotationStatus.textContent = `Fehler: ${error.message}`;
        progressBar.classList.add('bg-danger');
    } finally {
        // Re-enable start button, hide stop button
        startButton.disabled = false;
        stopButton.classList.add('d-none');
        isRotating = false;
    }
}

// Stop Rotation Function
function stopRotation() {
    if (isRotating) {
        rotationAborted = true;
        rotationStatus.textContent = 'Rotation wird gestoppt...';
    }
}

// Manual Rotation
manualRotationForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const degrees = document.getElementById('manual-degrees').value;

    try {
        const response = await fetch('/rotate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `degrees=${degrees}`
        });

        const result = await response.text();
        capturedImage.src = result; // Update image with latest photo
    } catch (error) {
        console.error('Rotation error:', error);
    }
});

// Event Listeners
startButton.addEventListener('click', start360Rotation);
stopButton.addEventListener('click', stopRotation);

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/js/viewer.js ---
/**
 * 360° Produktansicht Viewer
 * Interaktiver Viewer für 360-Grad-Produktansichten
 */

// DOM-Elemente
const viewerContainer = document.getElementById('product-viewer');
const spinner = document.getElementById('spinner');
const playButton = document.getElementById('play-btn');
const resetButton = document.getElementById('reset-btn');
const zoomInButton = document.getElementById('zoom-in-btn');
const zoomOutButton = document.getElementById('zoom-out-btn');
const fullscreenButton = document.getElementById('fullscreen-btn');
const projectNameElement = document.querySelector('#project-name span');
const imageCountElement = document.querySelector('#image-count span');

// Viewer-Konfiguration
let config = {
    images: [],            // Bildpfade
    currentImageIndex: 0,  // Aktueller Bildindex
    autoRotate: false,     // Automatische Rotation
    autoRotateSpeed: 100,  // Rotationsgeschwindigkeit in ms
    zoom: 1.0,             // Zoomstufe
    maxZoom: 2.5,          // Maximale Zoomstufe
    minZoom: 1.0,          // Minimale Zoomstufe
    zoomStep: 0.1,         // Zoom-Schritt pro Klick
    dragging: false,       // Maus/Touch-Status
    lastX: 0,              // Letzte X-Position
    autoRotateTimer: null  // Timer für Auto-Rotation
};

// Projekt-ID aus URL-Parametern holen
const urlParams = new URLSearchParams(window.location.search);
const projectId = urlParams.get('project');

/**
 * Lädt die Projektdaten vom Server
 */
async function loadProject() {
    console.log("Lade Projekt mit ID:", projectId);
    
    if (!projectId) {
        showError('Keine Projekt-ID angegeben');
        return;
    }
    
    try {
        const response = await fetch(`/api/project/${projectId}`);
        
        if (!response.ok) {
            throw new Error(`Projekt konnte nicht geladen werden (Status: ${response.status})`);
        }
        
        const projectData = await response.json();
        console.log("Projektdaten geladen:", projectData);
        
        // Projektdaten anzeigen
        projectNameElement.textContent = projectData.name || projectId;
        imageCountElement.textContent = projectData.image_count || projectData.images.length;
        
        // Bilder laden
        config.images = projectData.images.map(img => `/static/projects/${projectId}/${img}`);
        console.log("Bildpfade:", config.images);
        
        if (config.images.length > 0) {
            initViewer();
        } else {
            showError('Keine Bilder im Projekt gefunden');
        }
    } catch (error) {
        console.error('Fehler beim Laden des Projekts:', error);
        showError(`Fehler beim Laden des Projekts: ${error.message}`);
    }
}

/**
 * Initialisiert den 360° Viewer
 */
function initViewer() {
    console.log("Initialisiere Viewer mit", config.images.length, "Bildern");
    
    // Bilder vorladen
    preloadImages().then(() => {
        console.log("Alle Bilder vorgeladen");
        
        // Spinner ausblenden
        spinner.style.display = 'none';
        
        // Erstes Bild anzeigen
        showImage(0);
        
        // Event-Listener hinzufügen
        setupEventListeners();
        
        // Automatische Rotation starten
        startAutoRotate();
    }).catch(error => {
        console.error("Fehler beim Vorladen der Bilder:", error);
        showError("Fehler beim Laden der Bilder. Bitte prüfen Sie die Browser-Konsole.");
    });
}

/**
 * Lädt alle Bilder vor
 */
async function preloadImages() {
    console.log("Lade", config.images.length, "Bilder vor");
    
    // Zuerst alle vorhandenen Bilder entfernen
    const existingImages = viewerContainer.querySelectorAll('img');
    existingImages.forEach(img => img.remove());
    
    const preloadPromises = config.images.map((src, index) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            
            img.onload = () => {
                console.log(`Bild ${index + 1}/${config.images.length} geladen:`, src);
                resolve();
            };
            
            img.onerror = (err) => {
                console.error(`Fehler beim Laden von Bild ${index + 1}/${config.images.length}:`, src, err);
                // Trotz Fehler als geladen markieren, um die Anzeige nicht zu blockieren
                resolve();
            };
            
            img.src = src;
            img.alt = `Ansicht ${index + 1}`;
            img.className = 'product-image';
            img.style.display = 'none';
            img.draggable = false;
            
            viewerContainer.appendChild(img);
        });
    });
    
    return Promise.all(preloadPromises);
}

/**
 * Zeigt das Bild mit dem angegebenen Index an
 */
function showImage(index) {
    console.log("Zeige Bild", index + 1, "von", config.images.length);
    
    // Aktuelles Bild ausblenden
    const currentImage = viewerContainer.querySelector('.active');
    if (currentImage) {
        currentImage.classList.remove('active');
    }
    
    // Neues Bild anzeigen
    const images = viewerContainer.querySelectorAll('img');
    if (images.length > 0 && index >= 0 && index < images.length) {
        images[index].classList.add('active');
        config.currentImageIndex = index;
    } else {
        console.error("Ungültiger Bildindex:", index, "Verfügbare Bilder:", images.length);
    }
}

/**
 * Richtet Event-Listener für Maus/Touch-Interaktionen ein
 */
function setupEventListeners() {
    // Maus-Events
    viewerContainer.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);
    
    // Touch-Events
    viewerContainer.addEventListener('touchstart', startDrag);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', endDrag);
    
    // Zoom-Events
    zoomInButton.addEventListener('click', zoomIn);
    zoomOutButton.addEventListener('click', zoomOut);
    viewerContainer.addEventListener('wheel', handleWheel);
    
    // Steuerungs-Buttons
    playButton.addEventListener('click', toggleAutoRotate);
    resetButton.addEventListener('click', resetViewer);
    fullscreenButton.addEventListener('click', toggleFullscreen);
    
    console.log("Event-Listener eingerichtet");
}

/**
 * Startet den Drag-Vorgang
 */
function startDrag(event) {
    event.preventDefault();
    
    config.dragging = true;
    viewerContainer.style.cursor = 'grabbing';
    
    // Auto-Rotation stoppen
    stopAutoRotate();
    
    // Letzte Position speichern
    if (event.type === 'touchstart') {
        config.lastX = event.touches[0].clientX;
    } else {
        config.lastX = event.clientX;
    }
}

/**
 * Verarbeitet Drag-Bewegung
 */
function drag(event) {
    if (!config.dragging) return;
    
    event.preventDefault();
    
    let currentX;
    if (event.type === 'touchmove') {
        currentX = event.touches[0].clientX;
    } else {
        currentX = event.clientX;
    }
    
    // Bewegungsrichtung und -stärke ermitteln
    const deltaX = currentX - config.lastX;
    config.lastX = currentX;
    
    // Anzahl der Bilder berücksichtigen
    const imageCount = config.images.length;
    const step = Math.sign(deltaX);
    
    if (Math.abs(deltaX) > 5) { // Mindestbewegung für Bildwechsel
        let newIndex = config.currentImageIndex - step;
        
        // Grenzen beachten
        if (newIndex < 0) newIndex = imageCount - 1;
        if (newIndex >= imageCount) newIndex = 0;
        
        showImage(newIndex);
    }
}

/**
 * Beendet den Drag-Vorgang
 */
function endDrag() {
    config.dragging = false;
    viewerContainer.style.cursor = 'grab';
}

/**
 * Startet die automatische Rotation
 */
function startAutoRotate() {
    if (config.autoRotateTimer) return;
    
    config.autoRotate = true;
    playButton.innerHTML = '<i class="bi bi-pause-fill"></i> Pause';
    
    config.autoRotateTimer = setInterval(() => {
        let newIndex = (config.currentImageIndex + 1) % config.images.length;
        showImage(newIndex);
    }, config.autoRotateSpeed);
    
    console.log("Auto-Rotation gestartet");
}

/**
 * Stoppt die automatische Rotation
 */
function stopAutoRotate() {
    if (!config.autoRotateTimer) return;
    
    clearInterval(config.autoRotateTimer);
    config.autoRotateTimer = null;
    config.autoRotate = false;
    playButton.innerHTML = '<i class="bi bi-play-fill"></i> Auto-Rotation';
    
    console.log("Auto-Rotation gestoppt");
}

/**
 * Wechselt zwischen automatischer Rotation und Pause
 */
function toggleAutoRotate() {
    if (config.autoRotate) {
        stopAutoRotate();
    } else {
        startAutoRotate();
    }
}

/**
 * Vergrößert die Ansicht
 */
function zoomIn() {
    if (config.zoom < config.maxZoom) {
        config.zoom += config.zoomStep;
        applyZoom();
    }
}

/**
 * Verkleinert die Ansicht
 */
function zoomOut() {
    if (config.zoom > config.minZoom) {
        config.zoom -= config.zoomStep;
        applyZoom();
    }
}

/**
 * Wendet den aktuellen Zoom-Wert auf die Bilder an
 */
function applyZoom() {
    const images = viewerContainer.querySelectorAll('img');
    images.forEach(img => {
        img.style.transform = `translate(-50%, -50%) scale(${config.zoom})`;
    });
    
    console.log("Zoom angewendet:", config.zoom);
}

/**
 * Behandelt Mausrad-Events für Zoom
 */
function handleWheel(event) {
    event.preventDefault();
    
    if (event.deltaY < 0) {
        zoomIn();
    } else {
        zoomOut();
    }
}

/**
 * Setzt den Viewer zurück
 */
function resetViewer() {
    showImage(0);
    config.zoom = 1.0;
    applyZoom();
    stopAutoRotate();
    
    console.log("Viewer zurückgesetzt");
}

/**
 * Wechselt in den Vollbildmodus und zurück
 */
function toggleFullscreen() {
    const container = document.querySelector('.container');
    container.classList.toggle('fullscreen');
    
    if (container.classList.contains('fullscreen')) {
        fullscreenButton.innerHTML = '<i class="bi bi-fullscreen-exit"></i>';
    } else {
        fullscreenButton.innerHTML = '<i class="bi bi-fullscreen"></i>';
    }
    
    console.log("Vollbildmodus umgeschaltet");
}

/**
 * Zeigt eine Fehlermeldung an
 */
function showError(message) {
    console.error("Fehlermeldung:", message);
    
    // Spinner ausblenden, falls noch sichtbar
    spinner.style.display = 'none';
    
    // Bestehende Fehlermeldungen entfernen
    const existingErrors = viewerContainer.querySelectorAll('.alert');
    existingErrors.forEach(error => error.remove());
    
    // Neue Fehlermeldung anzeigen
    const errorElement = document.createElement('div');
    errorElement.className = 'alert alert-danger m-3';
    errorElement.textContent = message;
    
    viewerContainer.appendChild(errorElement);
}

// Projekt laden, wenn die Seite geladen ist
document.addEventListener('DOMContentLoaded', loadProject);

// Ein zusätzlicher Debug-Handler
window.addEventListener('error', (event) => {
    console.error('Globaler JavaScript-Fehler:', event.error);
});


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/js/settings.js ---
// Camera Resolution Preset Handling
const cameraWidthInput = document.getElementById('camera-width');
const cameraHeightInput = document.getElementById('camera-height');
const cameraResolutionPreset = document.getElementById('camera-resolution-preset');
const simulatorOnBtn = document.getElementById('simulator-on');
const simulatorOffBtn = document.getElementById('simulator-off');

// Resolution preset change handler
cameraResolutionPreset.addEventListener('change', (e) => {
    const preset = e.target.value;
    
    switch(preset) {
        case '640x480':
            cameraWidthInput.value = 640;
            cameraHeightInput.value = 480;
            break;
        case '1280x720':
            cameraWidthInput.value = 1280;
            cameraHeightInput.value = 720;
            break;
        case '1920x1080':
            cameraWidthInput.value = 1920;
            cameraHeightInput.value = 1080;
            break;
        case '2560x1440':
            cameraWidthInput.value = 2560;
            cameraHeightInput.value = 1440;
            break;
        case '3840x2160':
            cameraWidthInput.value = 3840;
            cameraHeightInput.value = 2160;
            break;
        case 'custom':
            // Clear inputs or keep current values
            break;
    }
});

// Geräteliste laden
async function loadDevices() {
    try {
        const response = await fetch('/api/devices');
        const devices = await response.json();
        
        updateDeviceUI(devices);
    } catch (error) {
        console.error('Fehler beim Laden der Geräte:', error);
    }
}

// Geräte-UI aktualisieren
function updateDeviceUI(devices) {
    // Bestehende Listen entfernen (um Duplikate zu vermeiden)
    document.querySelectorAll('.device-list').forEach(el => el.remove());
    
    // Webcams anzeigen
    const webcamList = document.createElement('div');
    webcamList.className = 'mt-2 small device-list';
    
    if (devices.cameras.webcams.length > 0) {
        devices.cameras.webcams.forEach(webcam => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary clickable-device';
            option.innerHTML = `<i class="bi bi-camera-video"></i> ${webcam}`;
            option.addEventListener('click', () => {
                document.getElementById('camera-device-path').value = webcam;
            });
            webcamList.appendChild(option);
        });
    } else {
        webcamList.innerHTML = '<div class="form-text text-muted">Keine Webcams gefunden</div>';
    }
    
    // Nach dem Kamera-Device-Pfad einfügen
    const cameraInput = document.getElementById('camera-device-path');
    cameraInput.parentNode.appendChild(webcamList);
    
    // gPhoto2-Kameras anzeigen
    const gphotoList = document.createElement('div');
    gphotoList.className = 'mt-2 small device-list';
    
    if (devices.cameras.gphoto2.length > 0) {
        devices.cameras.gphoto2.forEach(camera => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary';
            option.innerHTML = `<i class="bi bi-camera"></i> ${camera}`;
            gphotoList.appendChild(option);
        });
    } else {
        gphotoList.innerHTML = '<div class="form-text text-muted">Keine gphoto2-Kameras gefunden</div>';
    }
    
    // Nach dem Kameratyp einfügen
    const cameraType = document.getElementById('camera-type');
    cameraType.parentNode.appendChild(gphotoList);
    
    // Arduino-Geräte anzeigen
    const arduinoList = document.createElement('div');
    arduinoList.className = 'mt-2 small device-list';
    
    if (devices.arduinos.length > 0) {
        devices.arduinos.forEach(arduino => {
            const option = document.createElement('div');
            option.className = 'form-text text-primary clickable-device';
            option.innerHTML = `<i class="bi bi-cpu"></i> ${arduino.port} - ${arduino.description}`;
            option.addEventListener('click', () => {
                document.getElementById('arduino-port').value = arduino.port;
            });
            arduinoList.appendChild(option);
        });
    } else {
        arduinoList.innerHTML = '<div class="form-text text-muted">Keine Arduino-Geräte gefunden</div>';
    }
    
    // Nach dem Arduino-Port einfügen
    const arduinoInput = document.getElementById('arduino-port');
    arduinoInput.parentNode.appendChild(arduinoList);
}

// Add existing code from previous settings.js here...
document.addEventListener('DOMContentLoaded', () => {
    // Geräteliste laden
    loadDevices();
    
    // Konfiguration vom Server laden
    fetch('/get_config')
        .then(response => response.json())
        .then(config => {
            console.log('Geladene Konfiguration:', config);
            
            // Kamera-Einstellungen
            if (config.camera) {
                document.getElementById('camera-device-path').value = config.camera.device_path || '';
                document.getElementById('camera-type').value = config.camera.type || 'webcam';
                
                // Kamera-Auflösung setzen
                const cameraWidth = config.camera.resolution?.width;
                const cameraHeight = config.camera.resolution?.height;
                
                if (cameraWidth && cameraHeight) {
                    cameraWidthInput.value = cameraWidth;
                    cameraHeightInput.value = cameraHeight;
                    
                    // Set preset dropdown
                    const presetValue = `${cameraWidth}x${cameraHeight}`;
                    const presetOption = Array.from(cameraResolutionPreset.options)
                        .find(option => option.value === presetValue);
                    
                    if (presetOption) {
                        cameraResolutionPreset.value = presetValue;
                    } else {
                        cameraResolutionPreset.value = 'custom';
                    }
                }
            }
            
            // Arduino-Einstellungen
            if (config.arduino) {
                document.getElementById('arduino-port').value = config.arduino.port || '';
                document.getElementById('arduino-baudrate').value = config.arduino.baudrate || 9600;
            }
            
            // Rotations-Einstellungen
            if (config.rotation) {
                document.getElementById('rotation-degrees').value = config.rotation.default_degrees || 15;
                document.getElementById('rotation-interval').value = config.rotation.default_interval || 5;
            }
            
            // Simulator-Einstellungen
            if (config.simulator !== undefined) {
                // Hier ist der Fehler - wir müssen den richtigen Radio-Button auswählen
                if (config.simulator.enabled) {
                    simulatorOnBtn.checked = true;
                } else {
                    simulatorOffBtn.checked = true;
                }
            }
        })
        .catch(error => {
            console.error('Fehler beim Laden der Konfiguration:', error);
        });
});

// Aktualisierungsknopf für Geräteliste
const deviceRefreshButton = document.createElement('button');
deviceRefreshButton.type = 'button';
deviceRefreshButton.className = 'btn btn-outline-secondary mt-3';
deviceRefreshButton.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Geräte aktualisieren';
deviceRefreshButton.addEventListener('click', loadDevices);

// CSS für klickbare Geräte
const style = document.createElement('style');
style.textContent = `
    .clickable-device {
        cursor: pointer;
        transition: color 0.2s;
    }
    .clickable-device:hover {
        color: #0056b3 !important;
        text-decoration: underline;
    }
`;
document.head.appendChild(style);

// Knopf zum Formular hinzufügen (nach dem Laden der Seite)
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('settings-form').insertBefore(
        deviceRefreshButton,
        document.querySelector('.d-grid.gap-2.d-md-flex')
    );
});

// Debug-Button für Konfigurationstest hinzufügen
const debugButton = document.createElement('button');
debugButton.type = 'button';
debugButton.className = 'btn btn-outline-info mt-3 ms-2';
debugButton.innerHTML = '<i class="bi bi-bug"></i> Konfiguration testen';
debugButton.addEventListener('click', async (e) => {
    e.preventDefault();
    
    // Aktuelle Konfiguration abrufen und anzeigen
    try {
        const response = await fetch('/get_config');
        const config = await response.json();
        
        // Config-Nachricht erstellen
        const configMsg = document.createElement('div');
        configMsg.className = 'alert alert-info mt-3';
        configMsg.innerHTML = '<strong>Aktuelle Konfiguration:</strong><pre>' + 
                             JSON.stringify(config, null, 2) + '</pre>';
        
        // Vorhandene Nachrichten entfernen
        const existingMsg = document.querySelector('.debug-config-msg');
        if (existingMsg) existingMsg.remove();
        
        // Nachricht zur Seite hinzufügen
        configMsg.classList.add('debug-config-msg');
        document.getElementById('settings-form').appendChild(configMsg);
        
        console.log('Aktuelle Konfiguration:', config);
    } catch (error) {
        console.error('Fehler beim Laden der Konfiguration:', error);
        alert('Fehler beim Laden der Konfiguration: ' + error.message);
    }
});

// Zum Formular hinzufügen, direkt nach dem Geräte-Aktualisierungsbutton
document.addEventListener('DOMContentLoaded', () => {
    const refreshButton = document.querySelector('[id="settings-form"] button[type="button"]');
    if (refreshButton) {
        refreshButton.parentNode.insertBefore(debugButton, refreshButton.nextSibling);
    } else {
        const formActions = document.querySelector('.d-grid.gap-2.d-md-flex');
        formActions.parentNode.insertBefore(debugButton, formActions);
    }
});

// Formular-Abschicken
document.getElementById('settings-form').addEventListener('submit', async (e) => {
    e.preventDefault();

    // Prepare configuration object
    const config = {
        camera: {
            device_path: document.getElementById('camera-device-path').value,
            type: document.getElementById('camera-type').value,
            resolution: {
                width: parseInt(cameraWidthInput.value || 0),
                height: parseInt(cameraHeightInput.value || 0)
            }
        },
        arduino: {
            port: document.getElementById('arduino-port').value,
            baudrate: parseInt(document.getElementById('arduino-baudrate').value)
        },
        rotation: {
            default_degrees: parseInt(document.getElementById('rotation-degrees').value),
            default_interval: parseInt(document.getElementById('rotation-interval').value)
        },
        simulator: {
            enabled: document.getElementById('simulator-on').checked
        }
    };

    console.log("Einstellungen zum Speichern:", config);

    try {
        // Statusnachricht anzeigen
        const statusMsg = document.createElement('div');
        statusMsg.className = 'alert alert-info mt-3';
        statusMsg.textContent = 'Einstellungen werden gespeichert...';
        
        const existingMsg = document.querySelector('.save-status-msg');
        if (existingMsg) existingMsg.remove();
        
        statusMsg.classList.add('save-status-msg');
        document.getElementById('settings-form').appendChild(statusMsg);
        
        // Send configuration to server
        const response = await fetch('/save_config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(config)
        });
        
        // Antwort parsen
        const data = await response.json();
        console.log("Server-Antwort:", data);
        
        if (response.ok && data.status === 'success') {
            // Show success message
            statusMsg.className = 'alert alert-success mt-3 save-status-msg';
            statusMsg.textContent = 'Einstellungen erfolgreich gespeichert!';
            
            // Redirect to main page after a short delay
            setTimeout(() => {
                window.location.href = '/';
            }, 1500);
        } else {
            // Show error message
            statusMsg.className = 'alert alert-danger mt-3 save-status-msg';
            statusMsg.textContent = 'Fehler beim Speichern der Einstellungen: ' + 
                                  (data.message || 'Unbekannter Fehler');
            console.error('Fehler vom Server:', data);
        }
    } catch (error) {
        console.error('Verbindungsfehler:', error);
        
        const statusMsg = document.querySelector('.save-status-msg') || 
                         document.createElement('div');
        statusMsg.className = 'alert alert-danger mt-3 save-status-msg';
        statusMsg.textContent = 'Verbindungsfehler: ' + error.message;
        
        if (!document.querySelector('.save-status-msg')) {
            document.getElementById('settings-form').appendChild(statusMsg);
        }
    }
});


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/js/viewer360.js ---
class Viewer360 {
    constructor(containerId, imagesUrls, options = {}) {
        this.container = document.getElementById(containerId);
        this.images = [];
        this.imagesUrls = imagesUrls;
        this.currentIndex = 0;
        this.isPlaying = false;
        this.playInterval = null;
        this.options = {
            autoplay: true,
            autoplaySpeed: 100,
            dragSensitivity: 5,
            ...options
        };

        // Maus-/Touch-Positions-Tracking
        this.dragStartX = 0;
        this.isDragging = false;

        this.init();
    }

    async init() {
        if (!this.container) {
            console.error('Container nicht gefunden!');
            return;
        }

        // UI-Elemente erstellen
        this.container.innerHTML = `
            <div class="viewer360-container">
                <div class="viewer360-image-container">
                    <img class="viewer360-image" src="" alt="360° Ansicht">
                </div>
                <div class="viewer360-controls">
                    <button class="viewer360-play-btn">
                        <i class="bi bi-play-fill"></i>
                    </button>
                    <input type="range" class="viewer360-slider" min="0" max="100" value="0">
                </div>
            </div>
        `;

        // Elemente referenzieren
        this.imageElement = this.container.querySelector('.viewer360-image');
        this.playButton = this.container.querySelector('.viewer360-play-btn');
        this.slider = this.container.querySelector('.viewer360-slider');

        // Event-Listener
        this.playButton.addEventListener('click', () => this.togglePlayPause());
        this.slider.addEventListener('input', (e) => {
            const sliderPercentage = e.target.value / 100;
            const imageIndex = Math.floor(sliderPercentage * (this.imagesUrls.length - 1));
            this.showImage(imageIndex);
        });

        // Dragging-Funktionalität
        this.container.addEventListener('mousedown', (e) => this.onDragStart(e));
        this.container.addEventListener('touchstart', (e) => this.onDragStart(e.touches[0]), { passive: true });

        window.addEventListener('mousemove', (e) => this.onDragMove(e));
        window.addEventListener('touchmove', (e) => this.onDragMove(e.touches[0]));

        window.addEventListener('mouseup', () => this.onDragEnd());
        window.addEventListener('touchend', () => this.onDragEnd());

        // Bilder laden
        await this.loadImages();

        // Slider aktualisieren
        this.slider.max = this.imagesUrls.length - 1;

        // Erstes Bild anzeigen
        this.showImage(0);

        // Autoplay starten, wenn aktiviert
        if (this.options.autoplay) {
            this.play();
        }
    }

    async loadImages() {
        // Bilder vorladen für flüssigere Anzeige
        const loadPromises = this.imagesUrls.map(url => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
                this.images.push(img);
            });
        });

        try {
            await Promise.all(loadPromises);
            console.log(`${this.images.length} Bilder erfolgreich geladen.`);
        } catch (error) {
            console.error('Fehler beim Laden der Bilder:', error);
        }
    }

    showImage(index) {
        if (index < 0) index = this.imagesUrls.length - 1;
        if (index >= this.imagesUrls.length) index = 0;

        this.currentIndex = index;
        this.imageElement.src = this.imagesUrls[index];
        this.slider.value = index;
    }

    play() {
        if (this.isPlaying) return;

        this.isPlaying = true;
        this.playButton.innerHTML = '<i class="bi bi-pause-fill"></i>';

        this.playInterval = setInterval(() => {
            this.showImage((this.currentIndex + 1) % this.imagesUrls.length);
        }, this.options.autoplaySpeed);
    }

    pause() {
        if (!this.isPlaying) return;

        this.isPlaying = false;
        clearInterval(this.playInterval);
        this.playButton.innerHTML = '<i class="bi bi-play-fill"></i>';
    }

    togglePlayPause() {
        if (this.isPlaying) {
            this.pause();
        } else {
            this.play();
        }
    }

    onDragStart(event) {
        this.isDragging = true;
        this.dragStartX = event.clientX;

        // Autoplay bei Interaktion pausieren
        this.pause();
    }

    onDragMove(event) {
        if (!this.isDragging) return;

        const dragDelta = event.clientX - this.dragStartX;

        // Wenn genug bewegt wurde, ändern wir das Bild
        if (Math.abs(dragDelta) > this.options.dragSensitivity) {
            // Nach rechts ziehen zeigt vorheriges Bild (Drehung gegen den Uhrzeigersinn)
            // Nach links ziehen zeigt nächstes Bild (Drehung im Uhrzeigersinn)
            const direction = dragDelta > 0 ? -1 : 1;
            this.showImage((this.currentIndex + direction + this.imagesUrls.length) % this.imagesUrls.length);

            this.dragStartX = event.clientX;
        }
    }

    onDragEnd() {
        this.isDragging = false;
    }
}

// Beispiel für die Verwendung:
// const viewer = new Viewer360('viewer-container', ['/static/photos/image1.jpg', '/static/photos/image2.jpg']);

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/sample_images/.gitkeep ---


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/css/index.css ---
/* static/css/index.css */
body {
    background-color: #f4f4f4;
    padding-top: 50px;
}

.container {
    max-width: 800px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#captured-image {
    max-width: 100%;
    max-height: 400px;
    object-fit: contain;
    margin-bottom: 20px;
}

.btn-play, .btn-stop {
    font-size: 2rem;
    padding: 10px 20px;
}

#progress-container {
    margin-top: 20px;
}

#rotation-settings {
    margin-top: 20px;
}

@media (max-width: 768px) {
    body {
        padding-top: 20px;
    }
    .container {
        padding: 0 15px;
    }
}

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/css/project_edit.css ---
/* static/css/project_edit.css */
body {
    background-color: #f4f4f4;
    padding-top: 50px;
}

.container {
    max-width: 1000px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    margin-bottom: 50px;
}

.current-capture-container {
    display: flex;
    justify-content: center;
    margin: 20px 0;
    background-color: #f8f9fa;
    border-radius: 5px;
    padding: 10px;
}

#current-capture {
    max-height: 300px;
    object-fit: contain;
}

.image-gallery .card-img-top {
    height: 150px;
    object-fit: cover;
}

#progress-container {
    margin-top: 20px;
}

@media (max-width: 768px) {
    body {
        padding-top: 20px;
    }

    .container {
        padding: 0 15px;
    }

    #current-capture {
        max-height: 200px;
    }
}

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/css/projects.css ---
/* static/css/projects.css */
body {
    background-color: #f4f4f4;
    padding-top: 50px;
}

.container {
    max-width: 900px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    margin-bottom: 50px;
}

@media (max-width: 768px) {
    body {
        padding-top: 20px;
    }

    .container {
        padding: 0 15px;
    }
}

--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/css/settings.css ---
body {
    background-color: #f4f4f4;
    padding-top: 50px;
}

.container {
    max-width: 600px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

@media (max-width: 768px) {
    body {
        padding-top: 20px;
    }
    .container {
        padding: 0 15px;
    }
}

/* Optional: Add some subtle styling to form elements */
.form-control, .form-select {
    transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.form-control:focus, .form-select:focus {
    border-color: #0d6efd;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

/* Simulator mode radio buttons */
.form-check-input:checked {
    background-color: #0d6efd;
    border-color: #0d6efd;
}


--- Datei: /home/alex/Dokumente/drehteller_360_grad_fotos/static/css/viewer.css ---
body {
    background-color: #f4f4f4;
    padding-top: 20px;
    padding-bottom: 20px;
}

.container {
    max-width: 1200px;
}

.card {
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

#viewer-container {
    position: relative;
    width: 100%;
    height: 500px;
    background-color: #fff;
    overflow: hidden;
    touch-action: none; /* Verhindert Browser-Scrolling bei Touch-Gesten */
}

.viewer-360 {
    width: 100%;
    height: 100%;
    position: relative;
    cursor: grab;
}

.viewer-360:active {
    cursor: grabbing;
}

.viewer-360 img {
    position: absolute;
    max-width: 100%;
    max-height: 100%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    object-fit: contain;
    display: none !important; /* Wichtig! */
}

.viewer-360 img.active {
    display: block !important; /* Wichtig! */
}

/* Zoom-Effekt */
.viewer-360.zoomed {
    overflow: hidden;
}

/* Fullscreen-Modus */
.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 9999;
    background-color: #fff;
    padding: 20px;
}

.fullscreen #viewer-container {
    height: calc(100vh - 150px);
}

/* Spinner */
#spinner {
    z-index: 10;
}

/* Fehlermeldungen */
.alert {
    position: relative;
    z-index: 20;
}

/* Responsive Anpassungen */
@media (max-width: 768px) {
    #viewer-container {
        height: 350px;
    }
    
    .container {
        padding: 0 10px;
    }
    
    .viewer-controls, .zoom-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }
}

@media (max-width: 576px) {
    #viewer-container {
        height: 300px;
    }
    
    .card-header {
        flex-direction: column;
        gap: 10px;
    }
    
    .btn-sm {
        padding: 5px 8px;
        font-size: 0.8rem;
    }
}

